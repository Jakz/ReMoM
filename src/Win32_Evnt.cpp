
/*
    Windows-specifc
    Handle Windows Event Messages

    ∵   Application-Type: Game
    ∴   1 Window's Window Window-Class
        1 Window's Window
        1 Window's Event Message Handler
*/

#include "MoX_TYPE.H"
#include "MoX_DEF.H"

#include "MoM_main.H"   /* g_State_Run, g_Current_Screen, */
#include "Input.H"      /* g_Key_Pressed, scan_code_char_code */
#include "MoM.H"      /* platform_mouse_click_x, platform_mouse_click_y, platform_mouse_button_status; Update_Mouse_Position() */

// #define STU_DEBUG 1
#ifdef STU_DEBUG
#include "STU_DBG.H"
#endif

#include "Win32.hpp"

#include "windows.h"
#include "windowsx.h"   /* GET_X_LPARAM(), GET_Y_LPARAM() */
#include "winuser.h"


uint8_t g_KbHit;



/*! @defgroup mods Modifier key flags
 *  @brief Modifier key flags.
 *
 *  See [key input](@ref input_key) for how these are used.
 *
 *  @ingroup input
 *  @{ */

/*! @brief If this bit is set one or more Shift keys were held down.
 *
 *  If this bit is set one or more Shift keys were held down.
 */
#define GLFW_MOD_SHIFT           0x0001
/*! @brief If this bit is set one or more Control keys were held down.
 *
 *  If this bit is set one or more Control keys were held down.
 */
#define GLFW_MOD_CONTROL         0x0002
/*! @brief If this bit is set one or more Alt keys were held down.
 *
 *  If this bit is set one or more Alt keys were held down.
 */
#define GLFW_MOD_ALT             0x0004
/*! @brief If this bit is set one or more Super keys were held down.
 *
 *  If this bit is set one or more Super keys were held down.
 */
#define GLFW_MOD_SUPER           0x0008
/*! @brief If this bit is set the Caps Lock key is enabled.
 *
 *  If this bit is set the Caps Lock key is enabled and the @ref
 *  GLFW_LOCK_KEY_MODS input mode is set.
 */
#define GLFW_MOD_CAPS_LOCK       0x0010
/*! @brief If this bit is set the Num Lock key is enabled.
 *
 *  If this bit is set the Num Lock key is enabled and the @ref
 *  GLFW_LOCK_KEY_MODS input mode is set.
 */
#define GLFW_MOD_NUM_LOCK        0x0020

// Retrieves and translates modifier keys
//
static int getKeyMods(void)
{
    int mods = 0;

    if (GetKeyState(VK_SHIFT) & 0x8000)
        mods |= GLFW_MOD_SHIFT;
    if (GetKeyState(VK_CONTROL) & 0x8000)
        mods |= GLFW_MOD_CONTROL;
    if (GetKeyState(VK_MENU) & 0x8000)
        mods |= GLFW_MOD_ALT;
    if ((GetKeyState(VK_LWIN) | GetKeyState(VK_RWIN)) & 0x8000)
        mods |= GLFW_MOD_SUPER;
    if (GetKeyState(VK_CAPITAL) & 1)
        mods |= GLFW_MOD_CAPS_LOCK;
    if (GetKeyState(VK_NUMLOCK) & 1)
        mods |= GLFW_MOD_NUM_LOCK;

    return mods;
}

// //////////////////////////////////////////////////////////////////////////
// //////                         GLFW event API                       //////
// //////////////////////////////////////////////////////////////////////////
// 
// // Notifies shared code of a physical key event
// //
// void _glfwInputKey(_GLFWwindow* window, int key, int scancode, int action, int mods)
// {
//     assert(window != NULL);
//     assert(key >= 0 || key == GLFW_KEY_UNKNOWN);
//     assert(key <= GLFW_KEY_LAST);
//     assert(action == GLFW_PRESS || action == GLFW_RELEASE);
//     assert(mods == (mods & GLFW_MOD_MASK));
// 
//     if (key >= 0 && key <= GLFW_KEY_LAST)
//     {
//         GLFWbool repeated = GLFW_FALSE;
// 
//         if (action == GLFW_RELEASE && window->keys[key] == GLFW_RELEASE)
//             return;
// 
//         if (action == GLFW_PRESS && window->keys[key] == GLFW_PRESS)
//             repeated = GLFW_TRUE;
// 
//         if (action == GLFW_RELEASE && window->stickyKeys)
//             window->keys[key] = _GLFW_STICK;
//         else
//             window->keys[key] = (char) action;
// 
//         if (repeated)
//             action = GLFW_REPEAT;
//     }
// 
//     if (!window->lockKeyMods)
//         mods &= ~(GLFW_MOD_CAPS_LOCK | GLFW_MOD_NUM_LOCK);
// 
//     if (window->callbacks.key)
//         window->callbacks.key((GLFWwindow*) window, key, scancode, action, mods);
// }



/*

http://www.kbdedit.com/manual/low_level_vk_list.html

List of Virtual Key Codes
Following is a full list of VK codes that can be assigned to physical keys ("scan codes") in the Low-level editor.

The list is divided in two categories:

"Mappable" codes, to which Unicode characters can be assigned in the High-level editor
"Non-mappable" codes (modifiers, special keys)

*) VK_ICO_00 virtual code produces '00' (two zeros) when pressed. Windows does not allow mapping of arbitrary Unicode codepoints to this VK code.
**) "mouse button" quasi VK codes are generated by Windows when user clicks left/middle/right/X1/X2 mouse buttons. KbdEdit allows these codes to be assigned to physical keys, but such mappings make no sense: pressing a key with VK_LBUTTON assigned to it will NOT make Windows act as if physical mouse button was pressed.

"Mappable" codes

Name    Numeric value    Description
VK_ABNT_C1    0xC1    Abnt C1
VK_ABNT_C2    0xC2    Abnt C2
VK_ADD    0x6B    Numpad +
VK_ATTN    0xF6    Attn
VK_BACK    0x08    Backspace
VK_CANCEL    0x03    Break
VK_CLEAR    0x0C    Clear
VK_CRSEL    0xF7    Cr Sel
VK_DECIMAL    0x6E    Numpad .
VK_DIVIDE    0x6F    Numpad /
VK_EREOF    0xF9    Er Eof
VK_ESCAPE    0x1B    Esc
VK_EXECUTE    0x2B    Execute
VK_EXSEL    0xF8    Ex Sel
VK_ICO_CLEAR    0xE6    IcoClr
VK_ICO_HELP    0xE3    IcoHlp
VK_KEY_0                0x30 ('0')    0
VK_KEY_1                0x31 ('1')    1
VK_KEY_2                0x32 ('2')    2
VK_KEY_3                0x33 ('3')    3
VK_KEY_4                0x34 ('4')    4
VK_KEY_5                0x35 ('5')    5
VK_KEY_6                0x36 ('6')    6
VK_KEY_7                0x37 ('7')    7
VK_KEY_8                0x38 ('8')    8
VK_KEY_9                0x39 ('9')    9
VK_KEY_A                0x41 ('A')    A
VK_KEY_B                0x42 ('B')    B
VK_KEY_C                0x43 ('C')    C
VK_KEY_D                0x44 ('D')    D
VK_KEY_E                0x45 ('E')    E
VK_KEY_F                0x46 ('F')    F
VK_KEY_G                0x47 ('G')    G
VK_KEY_H                0x48 ('H')    H
VK_KEY_I                0x49 ('I')    I
VK_KEY_J                0x4A ('J')    J
VK_KEY_K                0x4B ('K')    K
VK_KEY_L                0x4C ('L')    L
VK_KEY_M                0x4D ('M')    M
VK_KEY_N                0x4E ('N')    N
VK_KEY_O                0x4F ('O')    O
VK_KEY_P                0x50 ('P')    P
VK_KEY_Q                0x51 ('Q')    Q
VK_KEY_R                0x52 ('R')    R
VK_KEY_S                0x53 ('S')    S
VK_KEY_T                0x54 ('T')    T
VK_KEY_U                0x55 ('U')    U
VK_KEY_V                0x56 ('V')    V
VK_KEY_W                0x57 ('W')    W
VK_KEY_X                0x58 ('X')    X
VK_KEY_Y                0x59 ('Y')    Y
VK_KEY_Z                0x5A ('Z')    Z
VK_MULTIPLY             0x6A    Numpad *
VK_NONAME               0xFC    NoName
VK_NUMPAD0              0x60    Numpad 0
VK_NUMPAD1              0x61    Numpad 1
VK_NUMPAD2              0x62    Numpad 2
VK_NUMPAD3              0x63    Numpad 3
VK_NUMPAD4              0x64    Numpad 4
VK_NUMPAD5              0x65    Numpad 5
VK_NUMPAD6              0x66    Numpad 6
VK_NUMPAD7              0x67    Numpad 7
VK_NUMPAD8              0x68    Numpad 8
VK_NUMPAD9              0x69    Numpad 9
VK_OEM_1    0xBA    OEM_1 (: ;)
VK_OEM_102    0xE2    OEM_102 (> <)
VK_OEM_2    0xBF    OEM_2 (? /)
VK_OEM_3    0xC0    OEM_3 (~ `)
VK_OEM_4    0xDB    OEM_4 ({ [)
VK_OEM_5    0xDC    OEM_5 (| \)
VK_OEM_6    0xDD    OEM_6 (} ])
VK_OEM_7    0xDE    OEM_7 (" ')
VK_OEM_8    0xDF    OEM_8 (§ !)
VK_OEM_ATTN    0xF0    Oem Attn
VK_OEM_AUTO    0xF3    Auto
VK_OEM_AX    0xE1    Ax
VK_OEM_BACKTAB    0xF5    Back Tab
VK_OEM_CLEAR    0xFE    OemClr
VK_OEM_COMMA    0xBC    OEM_COMMA (< ,)
VK_OEM_COPY    0xF2    Copy
VK_OEM_CUSEL    0xEF    Cu Sel
VK_OEM_ENLW    0xF4    Enlw
VK_OEM_FINISH    0xF1    Finish
VK_OEM_FJ_LOYA    0x95    Loya
VK_OEM_FJ_MASSHOU    0x93    Mashu
VK_OEM_FJ_ROYA    0x96    Roya
VK_OEM_FJ_TOUROKU    0x94    Touroku
VK_OEM_JUMP    0xEA    Jump
VK_OEM_MINUS    0xBD    OEM_MINUS (_ -)
VK_OEM_PA1    0xEB    OemPa1
VK_OEM_PA2    0xEC    OemPa2
VK_OEM_PA3    0xED    OemPa3
VK_OEM_PERIOD    0xBE    OEM_PERIOD (> .)
VK_OEM_PLUS    0xBB    OEM_PLUS (+ =)
VK_OEM_RESET    0xE9    Reset
VK_OEM_WSCTRL    0xEE    WsCtrl
VK_PA1    0xFD    Pa1
VK_PACKET    0xE7    Packet
VK_PLAY    0xFA    Play
VK_PROCESSKEY    0xE5    Process
VK_RETURN    0x0D    Enter
VK_SELECT    0x29    Select
VK_SEPARATOR    0x6C    Separator
VK_SPACE    0x20    Space
VK_SUBTRACT    0x6D    Num -
VK_TAB    0x09    Tab
VK_ZOOM    0xFB    Zoom

"Non-mappable" codes

Name    Numeric value    Description
VK__none_               0xFF    no VK mapping
VK_ACCEPT               0x1E    Accept
VK_APPS                 0x5D    Context Menu
VK_BROWSER_BACK         0xA6    Browser Back
VK_BROWSER_FAVORITES    0xAB    Browser Favorites
VK_BROWSER_FORWARD      0xA7    Browser Forward
VK_BROWSER_HOME         0xAC    Browser Home
VK_BROWSER_REFRESH      0xA8    Browser Refresh
VK_BROWSER_SEARCH       0xAA    Browser Search
VK_BROWSER_STOP         0xA9    Browser Stop
VK_CAPITAL              0x14    Caps Lock
VK_CONVERT              0x1C    Convert
VK_DELETE               0x2E    Delete
VK_DOWN                 0x28    Arrow Down
VK_END                  0x23    End
VK_F1                   0x70    F1
VK_F10                  0x79    F10
VK_F11                  0x7A    F11
VK_F12                  0x7B    F12
VK_F13                  0x7C    F13
VK_F14                  0x7D    F14
VK_F15                  0x7E    F15
VK_F16                  0x7F    F16
VK_F17                  0x80    F17
VK_F18                  0x81    F18
VK_F19                  0x82    F19
VK_F2                   0x71    F2
VK_F20                  0x83    F20
VK_F21                  0x84    F21
VK_F22                  0x85    F22
VK_F23                  0x86    F23
VK_F24                  0x87    F24
VK_F3                   0x72    F3
VK_F4                   0x73    F4
VK_F5                   0x74    F5
VK_F6                   0x75    F6
VK_F7                   0x76    F7
VK_F8                   0x77    F8
VK_F9                   0x78    F9
VK_FINAL                0x18    Final
VK_HELP                 0x2F    Help
VK_HOME                 0x24    Home
VK_ICO_00               0xE4    Ico00 *
VK_INSERT               0x2D    Insert
VK_JUNJA                0x17    Junja
VK_KANA                 0x15    Kana
VK_KANJI                0x19    Kanji
VK_LAUNCH_APP1          0xB6    App1
VK_LAUNCH_APP2          0xB7    App2
VK_LAUNCH_MAIL          0xB4    Mail
VK_LAUNCH_MEDIA_SELECT  0xB5    Media
VK_LBUTTON              0x01    Left Button **
VK_LCONTROL             0xA2    Left Ctrl
VK_LEFT                 0x25    Arrow Left
VK_LMENU                0xA4    Left Alt
VK_LSHIFT               0xA0    Left Shift
VK_LWIN                 0x5B    Left Win
VK_MBUTTON              0x04    Middle Button **
VK_MEDIA_NEXT_TRACK     0xB0    Next Track
VK_MEDIA_PLAY_PAUSE     0xB3    Play / Pause
VK_MEDIA_PREV_TRACK     0xB1    Previous Track
VK_MEDIA_STOP           0xB2    Stop
VK_MODECHANGE   0x1F    Mode Change
VK_NEXT         0x22    Page Down
VK_NONCONVERT   0x1D    Non Convert
VK_NUMLOCK      0x90    Num Lock
VK_OEM_FJ_JISHO 0x92    Jisho
VK_PAUSE        0x13    Pause
VK_PRINT        0x2A    Print
VK_PRIOR        0x21    Page Up
VK_RBUTTON      0x02    Right Button **
VK_RCONTROL     0xA3    Right Ctrl
VK_RIGHT        0x27    Arrow Right
VK_RMENU        0xA5    Right Alt
VK_RSHIFT       0xA1    Right Shift
VK_RWIN         0x5C    Right Win
VK_SCROLL       0x91    Scrol Lock
VK_SLEEP        0x5F    Sleep
VK_SNAPSHOT     0x2C    Print Screen
VK_UP           0x26    Arrow Up
VK_VOLUME_DOWN  0xAE    Volume Down
VK_VOLUME_MUTE  0xAD    Volume Mute
VK_VOLUME_UP    0xAF    Volume Up
VK_XBUTTON1     0x05    X Button 1 **
VK_XBUTTON2     0x06    X Button 2 **

*/


uint16_t VK_to_SCCS[128] = {
    /*   0 0x00 */  0x0000,
    /*   1 0x01 */  0x0000,
    /*   2 0x02 */  0x0000,
    /*   3 0x03 */  0x0000,
    /*   4 0x04 */  0x0000,
    /*   5 0x05 */  0x0000,
    /*   6 0x06 */  0x0000,
    /*   7 0x07 */  0x0000,
    /*   8 0x08 */  0x0000,
    /*   9 0x09 */  0x0000,
    /*  10 0x0A */  0x0000,
    /*  11 0x0B */  0x0000,
    /*  12 0x0C */  0x0000,
    /*  13 0x0D */  0x0000,
    /*  14 0x0E */  0x0000,
    /*  15 0x0F */  0x0000,
    /*  16 0x10 */  0x0000,
    /*  17 0x11 */  0x0000,
    /*  18 0x12 */  0x0000,
    /*  19 0x13 */  0x0000,
    /*  20 0x14 */  0x0000,
    /*  21 0x15 */  0x0000,
    /*  22 0x16 */  0x0000,
    /*  23 0x17 */  0x0000,
    /*  24 0x18 */  0x0000,
    /*  25 0x19 */  0x0000,
    /*  26 0x1A */  0x0000,
    /*  27 0x1B */  0x011B,  /* VK_ESCAPE */
    /*  28 0x1C */  0x0000,
    /*  29 0x1D */  0x0000,
    /*  30 0x1E */  0x0000,
    /*  31 0x1F */  0x0000,
    /*  32 0x20 */  0x3920,  /* VK_SPACE */
    /*  33 0x21 */  0x0000,
    /*  34 0x22 */  0x0000,
    /*  35 0x23 */  0x0000,
    /*  36 0x24 */  0x0000,
    /*  37 0x25 */  0x0000,
    /*  38 0x26 */  0x0000,
    /*  39 0x27 */  0x0000,
    /*  40 0x28 */  0x0000,
    /*  41 0x29 */  0x0000,
    /*  42 0x2A */  0x0000,
    /*  43 0x2B */  0x0000,
    /*  44 0x2C */  0x0000,
    /*  45 0x2D */  0x0000,
    /*  46 0x2E */  0x0000,
    /*  47 0x2F */  0x0000,
    /*  48 0x30 */  0x0B30,  /* VK_0 */
    /*  49 0x31 */  0x0231,  /* VK_1 */
    /*  50 0x32 */  0x0332,  /* VK_2 */
    /*  51 0x33 */  0x0433,  /* VK_3 */
    /*  52 0x34 */  0x0534,  /* VK_4 */
    /*  53 0x35 */  0x0635,  /* VK_5 */
    /*  54 0x36 */  0x0736,  /* VK_6 */
    /*  55 0x37 */  0x0837,  /* VK_7 */
    /*  56 0x38 */  0x0938,  /* VK_8 */
    /*  57 0x39 */  0x0A39,  /* VK_9 */
    /*  58 0x3A */  0x0000,  /* unassigned */
    /*  59 0x3B */  0x0000,  /* unassigned */
    /*  60 0x3C */  0x0000,  /* unassigned */
    /*  61 0x3D */  0x0000,  /* unassigned */
    /*  62 0x3E */  0x0000,  /* unassigned */
    /*  63 0x3F */  0x0000,  /* unassigned */
    /*  64 0x40 */  0x0000,  /* unassigned */
    /*  65 0x41 */  0x1E61,  /* VK_A */
    /*  66 0x42 */  0x3062,  /* VK_B */
    /*  67 0x43 */  0x2E63,  /* VK_C */
    /*  68 0x44 */  0x2064,  /* VK_D */
    /*  69 0x45 */  0x1265,  /* VK_E */
    /*  70 0x46 */  0x2166,  /* VK_F */
    /*  71 0x47 */  0x2267,  /* VK_G */
    /*  72 0x48 */  0x2368,  /* VK_H */
    /*  73 0x49 */  0x1769,  /* VK_I */
    /*  74 0x4A */  0x246A,  /* VK_J */
    /*  75 0x4B */  0x256B,  /* VK_K */
    /*  76 0x4C */  0x266C,  /* VK_L */
    /*  77 0x4D */  0x326D,  /* VK_M */
    /*  78 0x4E */  0x316E,  /* VK_N */
    /*  79 0x4F */  0x186F,  /* VK_O */
    /*  80 0x50 */  0x1970,  /* VK_P */
    /*  81 0x51 */  0x1071,  /* VK_Q */
    /*  82 0x52 */  0x1372,  /* VK_R */
    /*  83 0x53 */  0x1F73,  /* VK_S */
    /*  84 0x54 */  0x1474,  /* VK_T */
    /*  85 0x55 */  0x1675,  /* VK_U */
    /*  86 0x56 */  0x2F76,  /* VK_V */
    /*  87 0x57 */  0x1177,  /* VK_W */
    /*  88 0x58 */  0x2D78,  /* VK_X */
    /*  89 0x59 */  0x1579,  /* VK_Y */
    /*  90 0x5A */  0x2C7A,  /* VK_Z */
    /*  91 0x5B */  0x0000,
    /*  92 0x5C */  0x0000,
    /*  93 0x5D */  0x0000,
    /*  94 0x5E */  0x0000,
    /*  95 0x5F */  0x0000,
    /*  96 0x60 */  0x0000,
    /*  97 0x61 */  0x0000,
    /*  98 0x62 */  0x0000,
    /*  99 0x63 */  0x0000,
    /* 100 0x64 */  0x0000,
    /* 101 0x65 */  0x0000,
    /* 102 0x66 */  0x0000,
    /* 103 0x67 */  0x0000,
    /* 104 0x68 */  0x0000,
    /* 105 0x69 */  0x0000,
    /* 106 0x6A */  0x0000,
    /* 107 0x6B */  0x0000,
    /* 108 0x6C */  0x0000,
    /* 109 0x6D */  0x0000,
    /* 110 0x6E */  0x0000,
    /* 111 0x6F */  0x0000,
    /* 112 0x70 */  0x0000,
    /* 113 0x71 */  0x0000,
    /* 114 0x72 */  0x0000,
    /* 115 0x73 */  0x0000,
    /* 116 0x74 */  0x0000,
    /* 117 0x75 */  0x0000,
    /* 118 0x76 */  0x0000,
    /* 119 0x77 */  0x0000,
    /* 120 0x78 */  0x0000,
    /* 121 0x79 */  0x0000,
    /* 122 0x7A */  0x0000,
    /* 123 0x7B */  0x0000,
    /* 124 0x7C */  0x0000,
    /* 125 0x7D */  0x0000,
    /* 126 0x7E */  0x0000,
    /* 127 0x7F */  0x0000
};

// spits it back like ye 'ol INT 16,11
uint16_t WindowsVirtualKeyCode_to_ScanCodeCharCode(uint16_t VK_Code, uint16_t Shift, uint16_t Control, uint16_t Alt)
{
    uint16_t scan_code_char_code;

    if( (Shift == ST_TRUE) + (Control == ST_TRUE) + (Alt == ST_TRUE) > 1 )
    {
        return ST_NULL;
    }

    if(Shift == ST_TRUE)
    {
        // scan_code_char_code = VK_to_SCCS_Shift[VK_Code];
    }
    else if(Control == ST_TRUE)
    {
        // scan_code_char_code = VK_to_SCCS_Ctrl[VK_Code];
    }
    else if(Alt == ST_TRUE)
    {
        // scan_code_char_code = VK_to_SCCS_Alt[VK_Code];
    }
    else
    {
        scan_code_char_code = VK_to_SCCS[VK_Code];
    }

    return scan_code_char_code;
}

// VK_LCONTROL     0xA2    Left Ctrl
// VK_LMENU        0xA4    Left Alt
// VK_LSHIFT       0xA0    Left Shift
// VK_LWIN         0x5B    Left Win
// VK_RCONTROL     0xA3    Right Ctrl
// VK_RMENU        0xA5    Right Alt
// VK_RSHIFT       0xA1    Right Shift
// VK_RWIN         0x5C    Right Win

enum Key_Modifiers
{
    KMOD_NONE   = 0x0000,
    KMOD_LSHIFT = 0x0001,
    KMOD_RSHIFT = 0x0002,
    KMOD_LCTRL  = 0x0040,
    KMOD_RCTRL  = 0x0080,
    KMOD_LALT   = 0x0100,
    KMOD_RALT   = 0x0200,
    KMOD_LGUI   = 0x0400,
    KMOD_RGUI   = 0x0800,
    KMOD_NUM    = 0x1000,
    KMOD_CAPS   = 0x2000,
    KMOD_MODE   = 0x4000,
    KMOD_SCROLL = 0x8000,

    KMOD_SHIFT = KMOD_LSHIFT | KMOD_RSHIFT,
    KMOD_CTRL = KMOD_LCTRL | KMOD_RCTRL,
    KMOD_ALT = KMOD_LALT | KMOD_RALT,
    KMOD_GUI = KMOD_LGUI | KMOD_RGUI,

    KMOD_OVERRUN
};


#define ST_KMOD_SHIFT           0x0001
#define ST_KMOD_CONTROL         0x0002
#define ST_KMOD_ALT             0x0004
#define ST_KMOD_SUPER           0x0008  // ? "SUPER" "GUI" ? Windows (Logo) Key
#define ST_KMOD_CAPS_LOCK       0x0010
#define ST_KMOD_NUM_LOCK        0x0020

// Retrieves and translates modifier keys
int16_t Get_Key_Modifiers(void)
{
    int16_t mods = 0;

    // int16_t key_shift = GetKeyState(VK_SHIFT);    // VK_SHIFT    0x10  SHIFT key
    // int16_t key_ctrl  = GetKeyState(VK_CONTROL);  // VK_CONTROL  0x11  CTRL key
    // int16_t key_alt   = GetKeyState(VK_MENU);     // VK_MENU     0x12  ALT key
    // Left Alt:  if (GetKeyState(VK_LMENU) & 0x8000)
    // Right Alt: if (GetKeyState(VK_RMENU) & 0x8000)

    if (GetKeyState(VK_SHIFT) & 0x8000)
        mods |= ST_KMOD_SHIFT;

    if (GetKeyState(VK_CONTROL) & 0x8000)
        mods |= ST_KMOD_CONTROL;

    if (GetKeyState(VK_MENU) & 0x8000)
        mods |= ST_KMOD_ALT;

    if ((GetKeyState(VK_LWIN) | GetKeyState(VK_RWIN)) & 0x8000)
        mods |= ST_KMOD_SUPER;

    if (GetKeyState(VK_CAPITAL) & 1)
        mods |= ST_KMOD_CAPS_LOCK;

    if (GetKeyState(VK_NUMLOCK) & 1)
        mods |= ST_KMOD_NUM_LOCK;

    return mods;
}


// NOTE(JimBalcomb,20230615): moved to Win32_MoM - ? platform-layer intermediate *services* that the platform proves to the game
// void Poll_Messages(void)
// {
//         MSG Message;
//         while(PeekMessageA(&Message, 0, 0, 0, PM_REMOVE))
//         {
//             if (Message.message == WM_QUIT)
//             {
//                 g_State_Run = false;
//             }
//             TranslateMessage(&Message);
//             DispatchMessageA(&Message);
//         }
// }

LRESULT CALLBACK MainWindowCallback(HWND Window, UINT Message, WPARAM WParam, LPARAM LParam)
{
    LRESULT Result = 0;

    switch (Message)
    {
        case WM_CREATE:
        {
            ShowCursor(FALSE);
        } break;

        case WM_CLOSE:
        {
            OutputDebugStringA("WM_CLOSE\n");
            g_State_Run = false;
        } break;
    
        case WM_DESTROY:
        {
            OutputDebugStringA("WM_DESTROY\n");
            g_State_Run = false;
        } break;

        // https://yakvi.github.io/handmade-hero-notes/html/day6.html#keyboardinput
        case WM_SYSKEYDOWN:
            OutputDebugStringA("WM_SYSKEYDOWN\n");
        case WM_SYSKEYUP:
            OutputDebugStringA("WM_SYSKEYUP\n");
        case WM_KEYDOWN:
            OutputDebugStringA("WM_KEYDOWN\n");
        case WM_KEYUP:
        {
            OutputDebugStringA("WM_KEYUP\n");

//             WORD VK_Code = LOWORD(WParam);                                 // virtual-key code
//             WORD Key_Flags = HIWORD(LParam);
//             WORD Scan_Code = LOBYTE(Key_Flags);                             // scan code
//             BOOL isExtendedKey = (Key_Flags & KF_EXTENDED) == KF_EXTENDED; // extended-key flag, 1 if scancode has 0xE0 prefix
//             if (isExtendedKey)
//                 Scan_Code = MAKEWORD(Scan_Code, 0xE0);
//             BOOL wasKeyDown = (Key_Flags & KF_REPEAT) == KF_REPEAT;        // previous key-state flag, 1 on autorepeat
//             WORD repeatCount = LOWORD(LParam);                            // repeat count, > 0 if several keydown messages was combined into one message
//             BOOL isKeyReleased = (Key_Flags & KF_UP) == KF_UP;             // transition-state flag, 1 on keyup
// 
//             // if we want to distinguish these keys:
//             switch(VK_Code)
//             {
//                 case VK_SHIFT:   // converts to VK_LSHIFT or VK_RSHIFT
//                 case VK_CONTROL: // converts to VK_LCONTROL or VK_RCONTROL
//                 case VK_MENU:    // converts to VK_LMENU or VK_RMENU
//                 VK_Code = LOWORD(MapVirtualKeyW(Scan_Code, MAPVK_VSC_TO_VK_EX));
//             } break;
// 
//             unsigned int scancode = ( LParam >> 16 ) & 0xff;
//             unsigned int extended = ( LParam >> 24 ) & 0x1;
//             if ( extended ) {
//                 scancode |= 0xE000;
//             }



            uint32_t VKCode = WParam;  // the virtual-key code of the key
#ifdef STU_DEBUG
    dbg_prn("DEBUG: [%s, %d]: VKCode: %d\n", __FILE__, __LINE__, VKCode);
#endif

            int16_t key_shift = GetKeyState(VK_SHIFT);    // VK_SHIFT    0x10  SHIFT key
            int16_t key_ctrl  = GetKeyState(VK_CONTROL);  // VK_CONTROL  0x11  CTRL key
            int16_t key_alt   = GetKeyState(VK_MENU);     // VK_MENU     0x12  ALT key
            if (GetKeyState(VK_LMENU) & 0x8000)
            {
                    // Left ALT key is down.
            }
            if (GetKeyState(VK_RMENU) & 0x8000)
            {
                    // Right ALT key is down.
            }


            if (key_ctrl && key_alt && VKCode == 'Q')
            {
                OutputDebugStringA("Ctrl-Alt-Q\n");
                g_State_Run = false;
#ifdef STU_DEBUG
    dbg_prn("DEBUG: [%s, %d]: Ctrl-Alt-Q\n", __FILE__, __LINE__);
#endif
            }

            /*
                not extended, no modifer
                ? just ASCII ?
            */
            g_Key_Pressed = ST_TRUE;
            scan_code_char_code = VK_to_SCCS[VKCode];
#ifdef STU_DEBUG
    // MapVirtualKey() does not work with extended keys, try using MapVirtualKeyEx()
    char keyName[10];
    int length = GetKeyNameTextA(LParam, keyName, sizeof(keyName));
    dbg_prn("DEBUG: [%s, %d]: VKCode: %d\n", __FILE__, __LINE__, VKCode);
    dbg_prn("DEBUG: [%s, %d]: keyName: %s\n", __FILE__, __LINE__, keyName);

    dbg_prn("DEBUG: [%s, %d]: scan_code_char_code: %d\n", __FILE__, __LINE__, scan_code_char_code);
    dbg_prn("DEBUG: [%s, %d]: g_Key_Pressed: %d\n", __FILE__, __LINE__, g_Key_Pressed);
#endif

        } break;



        case WM_MOUSEMOVE:
        {
            // https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-mousemove
            // Do not use the LOWORD or HIWORD macros to extract the x- and y- coordinates of the cursor position ...
            // https://learn.microsoft.com/en-us/windows/win32/api/windowsx/nf-windowsx-get_x_lparam
            // Use GET_X_LPARAM instead of LOWORD to extract signed coordinate data. Negative screen coordinates may be returned on multiple monitor systems.
            // int win32_mouse_x = GET_X_LPARAM(LParam); 
            // int win32_mouse_y = GET_Y_LPARAM(LParam);
            // ? POINTS win32_mouse_points = MAKEPOINTS(LParam);

            POINT ptMouse;
            GetCursorPos(&ptMouse);
            ScreenToClient(g_Window, &ptMouse);
            Update_Mouse_Position((int16_t)ptMouse.x, (int16_t)ptMouse.y);

        } break;


        /*
            Windows Mouse Clicks

            platform_mouse_click_x |-> Pointer_X() <-| mouse_x
            platform_mouse_click_y |-> Pointer_Y() <-| mouse_y
            platform_mouse_button_status |-> MD_GetButtonStatus()

            ? ~ Process_Mouse_Click() ?
            Mouse Buttons - Left, Right, Middle, x1, x2
            Mouse Wheel
            ? Client Area vs. Non Client Area ?
        */
        case WM_LBUTTONDOWN:
        {
            OutputDebugStringA("WM_LBUTTONDOWN\n");
            POINT pt;
            pt.x = GET_X_LPARAM(LParam);
            pt.y = GET_Y_LPARAM(LParam);
            platform_mouse_click_x = (int16_t)pt.x;
            platform_mouse_click_y = (int16_t)pt.y;
            platform_mouse_button_status = 0b00000001;
        } break;
        case WM_LBUTTONUP:
        {
            OutputDebugStringA("WM_LBUTTONUP\n");
            platform_mouse_click_x = 0;
            platform_mouse_click_y = 0;
            platform_mouse_button_status = 0b00000000;
        } break;
        case WM_RBUTTONDOWN:
        {
            OutputDebugStringA("WM_RBUTTONDOWN\n");
            POINT pt;
            pt.x = GET_X_LPARAM(LParam);
            pt.y = GET_Y_LPARAM(LParam);
            platform_mouse_click_x = (int16_t)pt.x;
            platform_mouse_click_y = (int16_t)pt.y;
            platform_mouse_button_status = 0b00000010;
#ifdef STU_DEBUG
    dbg_prn("DEBUG: [%s, %d]: WM_RBUTTONDOWN\n", __FILE__, __LINE__);
    dbg_prn("DEBUG: [%s, %d]: platform_mouse_click_x: %d\n", __FILE__, __LINE__, platform_mouse_click_x);
    dbg_prn("DEBUG: [%s, %d]: platform_mouse_click_y: %d\n", __FILE__, __LINE__, platform_mouse_click_y);
    dbg_prn("DEBUG: [%s, %d]: platform_mouse_button_status: %d\n", __FILE__, __LINE__, platform_mouse_button_status);
#endif

        } break;
        case WM_RBUTTONUP:
        {
            OutputDebugStringA("WM_RBUTTONUP\n");
            platform_mouse_click_x = 0;
            platform_mouse_click_y = 0;
            platform_mouse_button_status = 0b00000000;
        } break;


        case WM_PAINT:
        {
            PAINTSTRUCT Paint;
            HDC DeviceContext = BeginPaint(Window, &Paint);
            win32_window_dimension Dimension = Win32GetWindowDimension(Window);
            Win32DisplayBufferInWindow(&GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);
            EndPaint(Window, &Paint);
        } break;

        case WM_SIZE:
        {
            OutputDebugStringA("WM_SIZE\n");
        } break;

        case WM_ACTIVATEAPP:
        {
            OutputDebugStringA("WM_ACTIVATEAPP\n");
        } break;

        default:
        {
            Result = DefWindowProc(Window, Message, WParam, LParam);
        } break;
    }

    return Result;
}
