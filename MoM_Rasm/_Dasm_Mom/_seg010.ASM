;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

include	uni.inc	; see unicode subdir of	ida for	info on	unicode

.386
.model large

include	MAGIC_rprd2.inc



; Segment type:	Pure code
seg010 segment byte public 'CODE' use16
assume cs:seg010
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_0_0(int argLbxFileName, int argLbxEntryNumber)
LBX_Load_Entry_0_0_0 proc far
			; CODE XREF: _main+389P
			; LBX_Load_NewGameData+15P
			; LBX_Load_NewGameData+27P
			; LBX_Load_NewGameData+39P
			; LBX_Load_NewGameData+4BP
			; LBX_Load_NewGameData+5DP
			; LBX_Load_NewGameData+6FP
			; LBX_Load_NewGameData+81P
			; LBX_Load_NewGameData+9EP
			; LBX_Load_FontsStyleData+18P
			; LBX_Load_FontsStyleData+27P
			; ST_LoadSoundDrivers+143P
			; ST_LoadSoundDrivers+16BP
			; ST_LoadSoundDrivers+64AP
			; ST_LoadSoundDrivers+678P

argLbxFileName=	word ptr  6
argLbxEntryNumber= word	ptr  8

push	bp
mov	bp, sp


xor	ax, ax		; Logical Exclusive OR
push	ax		; argSomethingElseOrZero
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg6_DI
xor	ax, ax		; argSrc
push	ax		; argPtrBuffer_EMS
push	[bp+argLbxEntryNumber] ; argLbxEntryNumber
push	[bp+argLbxFileName] ; argLbxFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	;
			; LBX_Load_Entry(argLbxFileName,
			;		 argLbxEntryNumber,
			;		 0,
			;		 0,
			;		 0)


add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
LBX_Load_Entry_0_0_0 endp ; sp-analysis	failed



; Returns varLbxMemBuf,	from LBX_Load_Entry
;
; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_1(int argLbxFileName, int argEntryNumber, int argPtrBuffer_EMS)
LBX_Load_Entry_0_1 proc	far
			; CODE XREF: ILSe_prepare_palette+17P
			; sub_3CFC0+26P
			; sub_3DBA6+13P
			; sub_3E1DE+6FP
			; sub_3EBA0+24P
			; sub_3F3C6+13P
			; idk_Load_NEWGAME_LBX+11P
			; sub_3F7D8+25P
			; sub_3FBE0+5BP
			; sub_4067D+3AP
			; LBX_NewGame_s41A5F:loc_41A85P
			; sub_4D5B0:loc_4D5DBP
			; sub_4D8FA+1BP
			; sub_4DB4D+28P
			; ST_LoadMusicSoundfxIntro+1CP
			; sub_56450:loc_564A8P

argLbxFileName=	word ptr  6
argEntryNumber=	word ptr  8
argPtrBuffer_EMS= word ptr  0Ah

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; arg 5
mov	ax, 1		; argSrc
push	ax		; arg 4
push	[bp+argPtrBuffer_EMS] ;	arg 3
push	[bp+argEntryNumber] ; arg 2
push	[bp+argLbxFileName] ; arg 1
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Returns a pointer to a buffer	of the record data that	was read?
			;
			; LBX_Load_Entry(argLbxFileName,
			;		 argEntryNumber,
			;		 argPtrBuffer_EMS,
			;		 1,
			;		 0)
			;
			; LBX_Load_Entry(argLbxFileName,
			;		 argEntryNumber,
			;		 argPtrBuffer_EMS,
			;		 arg_idk_FLAG_0_1_2,
			;		 argSomethingElseOrZero)
			;
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
LBX_Load_Entry_0_1 endp	; sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry_0_2(int argEntryNumber, int argFileName, int	arg4_Int)
LBX_Load_Entry_0_2 proc	far
			; CODE XREF: sub_3CFC0+3DP
			; sub_3CFC0+5AP
			; sub_3CFC0+82P
			; sub_3CFC0+AAP
			; sub_3DBA6+2AP
			; sub_3DBA6+41P
			; sub_3DBA6+58P
			; sub_3DBA6+6FP
			; sub_3DBA6+86P
			; sub_3DBA6+9DP
			; sub_3DBA6+B4P
			; sub_3DBA6+CBP
			; sub_3E1DE+86P
			; sub_3E1DE+9DP
			; sub_3E1DE+B4P
			; sub_3E1DE+CBP
			; sub_3E1DE+E2P
			; sub_3E1DE+F9P
			; sub_3E1DE+110P
			; sub_3EBA0+41P
			; sub_3EBA0+70P
			; sub_3EBA0+8DP
			; sub_3F3C6+34P
			; sub_3F3C6+5AP
			; idk_Load_NEWGAME_LBX+28P
			; sub_3F7D8+3CP
			; sub_3F7D8+59P
			; sub_3F7D8+7BP
			; sub_3FBE0+72P
			; sub_3FBE0+89P
			; sub_3FBE0+A0P
			; sub_3FBE0+B7P
			; sub_3FBE0+D4P
			; sub_4067D+51P
			; sub_4067D+68P
			; sub_4067D+85P
			; sub_4067D+A7P
			; sub_4067D+BEP
			; sub_4067D+D5P
			; LBX_NewGame_s41A5F+3DP
			; LBX_NewGame_s41A5F+54P
			; LBX_NewGame_s41A5F:loc_41ACAP
			; LBX_NewGame_s41A5F+82P
			; LBX_NewGame_s41A5F:loc_41AF8P
			; LBX_NewGame_s41A5F:loc_41B0FP
			; LBX_NewGame_s41A5F:loc_41B26P
			; LBX_NewGame_s41A5F:loc_41B43P
			; LBX_NewGame_s41A5F+106P
			; LBX_NewGame_s41A5F+11DP
			; LBX_NewGame_s41A5F+134P
			; sub_4D5B0:loc_4D5F2P
			; sub_4D5B0:loc_4D609P
			; sub_4D5B0:loc_4D620P
			; sub_4D8FA+32P
			; sub_4D8FA+49P
			; sub_4D8FA+60P
			; sub_4DB4D:loc_4DB8CP
			; sub_4DB4D+56P
			; sub_4DB4D+6DP
			; sub_4DB4D+84P
			; sub_4DB4D+9BP
			; sub_4DB4D+B2P
			; sub_4DB4D+C9P
			; sub_4DB4D+E0P
			; sub_4DB4D+F7P
			; sub_4DB4D+10EP
			; sub_4DB4D+125P
			; sub_4DB4D+13CP
			; sub_4DB4D+159P
			; sub_4DB4D+175P
			; idk_ResourceLbx+4BP
			; idk_ResourceLbx+62P
			; idk_ResourceLbx+79P
			; idk_ResourceLbx+93P
			; idk_ResourceLbx+AAP
			; idk_ResourceLbx+C1P
			; idk_ResourceLbx+DBP
			; idk_ResourceLbx+F2P
			; idk_ResourceLbx+109P
			; idk_ResourceLbx+122P
			; idk_ResourceLbx+139P
			; idk_ResourceLbx+150P
			; idk_ResourceLbx+16FP
			; ST_LoadMusicSoundfxIntro+3DP
			; ST_LoadMusicSoundfxIntro+19BP
			; ST_LoadMusicSoundfxIntro+1B2P
			; ST_LoadMusicSoundfxIntro+210P
			; ST_LoadMusicSoundfxIntro+227P
			; ST_LoadMusicSoundfxIntro+26BP
			; ST_LoadMusicSoundfxIntro+282P
			; ST_LoadMusicSoundfxIntro+2C7P
			; idk_OVR_LoadLbxHelp+12AP
			; idk_OVR_LoadLbxHelp+215P
			; idk_OVR_LoadLbxHelp+22CP
			; idk_OVR_LoadLbxHelp+3B6P

argEntryNumber=	word ptr  6
argFileName= word ptr  8
arg4_Int= word ptr  0Ah

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; argSomethingElseOrZero
mov	ax, 2		; argSrc
push	ax		; arg6_DI
push	[bp+arg4_Int]	; argPtrBuffer_EMS
push	[bp+argFileName] ; argLbxEntryNumber
push	[bp+argEntryNumber] ; argLbxFileName
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
LBX_Load_Entry_0_2 endp	; sp-analysis failed



; 52,  36, 0, 0, "BUILDDAT"
; 36, 215, 0, 0, "SPELLDAT"
;  6, 770, 0, 0, "TERRSTAT"
;
; BUILDDAT.LBX:	count 1, type 5
; SPELLDAT.LBX:	count 1, type 5
; TERRSTAT.LBX:	count 2, type 5
;
; NOTE:	There are other	LBX's
;  that	have the same/similar count and	type.
;
; All three trace back on a single path	to main().
; SPELLDAT and TERRSTAT	are called directly from main(),
; BUILDDAT follow a long series	of other calls.
; Attributes: bp-based frame

LBX_PreLoad_s15453 proc	far
			; CODE XREF: fncLoadTERRSTAT+15P
			; LBX_SpellDat+15P
			; idk_BuildingWorlds+17P

argString_DI= word ptr	6
argLbxName_SI= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh

push	bp
mov	bp, sp
push	[bp+arg_8]	; int
push	[bp+arg_6]	; int
push	[bp+arg_4]	; int
xor	ax, ax		; Logical Exclusive OR
push	ax		; int
xor	ax, ax		; int
push	ax		; int
push	[bp+argLbxName_SI] ; argLbxName_SI
push	[bp+argString_DI] ; argString_DI
nop			; No Operation
push	cs
call	near ptr LBX_Load_s15453 ; Call	Procedure
add	sp, 0Eh		; Add
pop	bp
retf			; Return Far from Procedure
LBX_PreLoad_s15453 endp	; sp-analysis failed

push	bp

loc_14F9F:
mov	bp, sp
push	word ptr [bp+10h]
push	word ptr [bp+0Eh]

loc_14FA7:
push	word ptr [bp+0Ch]

loc_14FAA:
mov	ax, 1
push	ax

loc_14FAE:
push	word ptr [bp+0Ah]

loc_14FB1:
push	word ptr [bp+8]

loc_14FB4:
push	word ptr [bp+6]
nop			; No Operation
push	cs

loc_14FB9:		; Call Procedure
call	near ptr LBX_Load_s15453

loc_14FBC:		; Add
add	sp, 0Eh

loc_14FBF:
pop	bp

locret_14FC0:		; Return Far from Procedure
retf

loc_14FC1:
push	bp
mov	bp, sp
push	word ptr [bp+10h]
push	word ptr [bp+0Eh]

loc_14FCA:
push	word ptr [bp+0Ch]

loc_14FCD:
mov	ax, 2
push	ax
push	word ptr [bp+0Ah]

loc_14FD4:
push	word ptr [bp+8]

loc_14FD7:
push	word ptr [bp+6]

loc_14FDA:		; No Operation
nop

loc_14FDB:
push	cs
call	near ptr LBX_Load_s15453 ; Call	Procedure

loc_14FDF:		; Add
add	sp, 0Eh

loc_14FE2:
pop	bp
retf			; Return Far from Procedure
push	bp
mov	bp, sp

loc_14FE7:
mov	ax, 1
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_14FED:
push	ax
xor	ax, ax		; Logical Exclusive OR

loc_14FF0:
push	ax
push	word ptr [bp+8]

loc_14FF4:
push	word ptr [bp+6]

loc_14FF7:		; No Operation
nop
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp

locret_15000:		; Return Far from Procedure
retf


; Attributes: bp-based frame

sub_15001 proc far
push	bp

loc_15002:
mov	bp, sp

loc_15004:
mov	ax, 1

loc_15007:		; argSomethingElseOrZero
push	ax

loc_15008:		; argSrc
mov	ax, 1

loc_1500B:		; arg6_DI
push	ax

loc_1500C:		; argPtrBuffer_EMS
push	word ptr [bp+0Ah]

loc_1500F:		; argLbxEntryNumber
push	word ptr [bp+8]
push	word ptr [bp+6]	; argLbxFileName
nop			; No Operation
push	cs

loc_15017:		; Call Procedure
call	near ptr LBX_Load_Entry

loc_1501A:		; Add
add	sp, 0Ah

loc_1501D:
pop	bp

locret_1501E:		; Return Far from Procedure
retf

loc_1501F:
push	bp

loc_15020:
mov	bp, sp
mov	ax, 1
push	ax		; argSomethingElseOrZero

loc_15026:		; argSrc
mov	ax, 2
push	ax		; arg6_DI
push	word ptr [bp+0Ah] ; argPtrBuffer_EMS
push	word ptr [bp+8]	; argLbxEntryNumber

loc_15030:		; argLbxFileName
push	word ptr [bp+6]
nop			; No Operation
push	cs
call	near ptr LBX_Load_Entry	; Call Procedure
add	sp, 0Ah		; Add
pop	bp
retf			; Return Far from Procedure
sub_15001 endp ; sp-analysis failed



; Returns varLbxMemBuf
;
; LBX_Load_Entry(argEntryNumber,
;		 argFileNameBase,
;		 argPtrBuffer_EMS,
;		 arg_idk_FLAG_0_1_2,
;		 argSomethingElseOrZero)
;
; Attributes: bp-based frame

; int __cdecl __far LBX_Load_Entry(int argLbxFileName, int argLbxEntryNumber, int argPtrBuffer_EMS, int	arg6_DI, int argSomethingElseOrZero)
LBX_Load_Entry proc far	; CODE XREF: LBX_Load_Entry_0_0_0+14p
			; LBX_Load_Entry_0_1+15p
			; LBX_Load_Entry_0_2+15p
			; seg010:00D9p
			; sub_15001:loc_15017p
			; sub_15001+34p

varDest= byte ptr -6Ch
varDst=	byte ptr -30h
var_idkMemberSize= word	ptr -1Ch
var2_SI= dword ptr -1Ah
varMemberOffsetEnd_Word2= word ptr -16h
varMemberOffsetStart_Word1= word ptr -14h
varMemberOffsetStart_Word2= word ptr -12h
var0_offsetDX= word ptr	-10h
var2_offsetCX= word ptr	-0Eh
varBytes= word ptr -0Ch
varBuffer= word	ptr -0Ah
varBytesToAllocate= word ptr -8
var8_SI= word ptr -6
varOffsetToMemberOffsetStart= word ptr -4
varLbxMemBuf= word ptr -2
argLbxFileName=	word ptr  6
argLbxEntryNumber= word	ptr  8
argPtrBuffer_EMS= word ptr  0Ah
arg6_DI= word ptr  0Ch
argSomethingElseOrZero=	word ptr  0Eh

si_argLbxFileName = si
push	bp
mov	bp, sp
sub	sp, 108		; Integer Subtraction
push	si_argLbxFileName
push	di


mov	si_argLbxFileName, [bp+argLbxFileName]
mov	di, [bp+argLbxEntryNumber]
or	di, di		; If (DI == 0) Then Set	(ZF = 1)
jge	short OK_StringNotEmpty	; Jump if Greater or Equal (SF=OF)

NoNameDefaultNotFound:
push	di
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

OK_StringNotEmpty:	; CODE XREF: LBX_Load_Entry+10j
cmp	LBX_FLAG_NoMalloc, 0 ; Compare Two Operands
jnz	short loc_15077	; Jump if Not Zero (ZF=0)
mov	LBX_FLAG_NoMalloc, 1
mov	ax, 32		; int
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	g_ptrBufferReadFile, ax

loc_15077:		; CODE XREF: LBX_Load_Entry+25j
push	si_argLbxFileName ; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
cmp	[bp+argSomethingElseOrZero], 0 ; Compare Two Operands
jz	short NO_ArgNbr3 ; Jump	if Zero	(ZF=1)

loc_15084:		; Compare Two Operands
cmp	LBX_Flag_w35B7A, 2
jnz	short loc_15092	; Jump if Not Zero (ZF=0)

NO_ArgNbr3:		; CODE XREF: LBX_Load_Entry+45j
mov	[bp+var8_SI], 0
jmp	short loc_15097	; Jump

loc_15092:		; CODE XREF: LBX_Load_Entry+4Cj
mov	[bp+var8_SI], 1

loc_15097:		; CODE XREF: LBX_Load_Entry+53j
push	[bp+var8_SI]	; int
push	[bp+arg6_DI]	; int
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer_EMS
push	di		; int
push	si_argLbxFileName ; int
call	LBX_EmsMapMem	; Return:
			; FAILURE: AX =	0
			; OR
			; SUCCESS: AX =	DI
add	sp, 0Ah		; Add
mov	[bp+varLbxMemBuf], ax
cmp	[bp+varLbxMemBuf], 0 ; Compare Two Operands
jz	short GOT_ZERO	; Jump if Zero (ZF=1)
jmp	loc_15443	; Jump

GOT_ZERO:		; CODE XREF: LBX_Load_Entry+74j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short DIFFERENT_FILE_OPEN ; Jump if Zero (ZF=1)

idk_CurrentFileOpen:
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	si_argLbxFileName ; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short DIFFERENT_FILE_OPEN ; Jump if Not	Zero (ZF=0)

idk_AlreadyReadHeader:
mov	ax, g_CurrentLbxFilePosition
cmp	ax, [bp+var8_SI] ;
			; var8_SI is still 0 or	1?
			;  based on var	of flag?
			;
jnz	short DIFFERENT_FILE_OPEN ; Jump if Not	Zero (ZF=0)
jmp	CheckEntryCount	; Jump

DIFFERENT_FILE_OPEN:	; CODE XREF: LBX_Load_Entry+7Ej
			; LBX_Load_Entry+8Ej
			; LBX_Load_Entry+96j
mov	ax, [bp+var8_SI]
mov	g_CurrentLbxFilePosition, ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short loc_150EF	; Jump if Zero (ZF=1)
push	g_CurrentLbxFileHandle
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_150EF:		; CODE XREF: LBX_Load_Entry+A6j
push	si_argLbxFileName
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; argDest
call	_strcpy		; copy LBX File	Name Base
			;  from	SI to ptrLbxMemberName
			;
pop	cx
pop	cx
push	si_argLbxFileName
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; Copy LBX File	Name Base
			;  from	SI to local varDst
			;
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; Add ".LBX"
			;  to local copy of LBX	File Name Base
			;
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; 0 =	Error;
			;
jnz	short SUCCESS_FILE_OPEN	; Jump if Not Zero (ZF=0)

COULD_NOT_OPEN_FILE:	; Compare Two Operands
cmp	byte ptr g_LbxDirectoryPath, 0
jnz	short TRY_SOME_OTHER_FILENAME ;	Jump if	Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

TRY_SOME_OTHER_FILENAME:
			; CODE XREF: LBX_Load_Entry+F2j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; copy idk_LBX_argSrc_w35B7C
			;  to varDest
			;
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; Append LBX File Name
			;  to varDest
			;
pop	cx
pop	cx
lea	ax, [bp+varDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax ; File Handle
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short SUCCESS_FILE_OPEN	; Jump if Not Zero (ZF=0)

COULD_NOT_OPEN_FILE_STILL: ; argLbxEntryNumber
push	di
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_FILE_OPEN:	; CODE XREF: LBX_Load_Entry+EBj
			; LBX_Load_Entry+132j
cmp	g_CurrentLbxFilePosition, 0 ; Compare Two Operands
jz	short FILE_POSITION_IS_ZERO ; Jump if Zero (ZF=1)
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], LBX_HEADER_LENGTH
jmp	short loc_1519C	; Jump

FILE_POSITION_IS_ZERO:	; CODE XREF: LBX_Load_Entry+147j
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], 0

loc_1519C:		; CODE XREF: LBX_Load_Entry+153j
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+var2_offsetCX] ; CX
push	[bp+var0_offsetDX] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; IF (AX == 0) Then Set	(ZF = 1)
jnz	short SEEK_SUCCESS1 ; Jump if Not Zero (ZF=0)

SEEK_FAILURE1:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short Check_Lbx_MagSig ; Jump

SEEK_SUCCESS1:		; CODE XREF: LBX_Load_Entry+173j
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, LBX_HEADER_LENGTH
push	ax		; argBytes
push	g_ptrBufferReadFile ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

Check_Lbx_MagSig:	; CODE XREF: LBX_Load_Entry+180j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short GetEntryCount ; JZ: LBX_MagSig matched

noLbxMagSig:		; argLbxEntryNumber
push	di
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

GetEntryCount:		; CODE XREF: LBX_Load_Entry+1A8j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	g_CurrentLbxEntryCount,	ax

CheckEntryCount:	; CODE XREF: LBX_Load_Entry+98j
cmp	di, g_CurrentLbxEntryCount ;
			; DI is	argEntryNumber
			;
jl	short GetEntryOffsets ;	Jump if	Less (SF!=OF)

EXCEEDS_ENTRY_COUNT:	; argLbxEntryNumber
push	di
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

GetEntryOffsets:	; CODE XREF: LBX_Load_Entry+1CDj
mov	ax, di		; AX = LBX Entry Number	Requested
mov	cl, 2		; argLbxEntryNumber
shl	ax, cl		; Shift	Left (multiply by the power of 2)
			;
			; LBX Member Number * 2^2
			; e.g.,
			; LBX Member Number = 11
			; Shift	Left: 11 * 2^2 = 11 * 4	= 44
			;
			;   0 *	4 + 8 =	  8
			;   1 *	4 + 8 =	 12
			;   2 *	4 + 8 =	 16
			;   3 *	4 + 8 =	 20
			; ...
			; 125 *	4 + 8 =	508
			;

loc_15220:		;
add	ax, 8		; add 8	to offset from the 8 byte Header Preamble
			;
mov	[bp+varOffsetToMemberOffsetStart], ax
push	[bp+varOffsetToMemberOffsetStart]
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMemberOffsetStart_Word2], dx
mov	[bp+varMemberOffsetStart_Word1], ax ;
			;
			;
mov	ax, [bp+varOffsetToMemberOffsetStart]
add	ax, 4		;
			; add 4	to move	offset to Entry	Offset End
			;
push	ax
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMemberOffsetEnd_Word2], dx
mov	word ptr [bp+var2_SI+2], ax ; varMemberOffsetEnd_Word1
			;
			;
mov	ax, [bp+varMemberOffsetEnd_Word2]
mov	dx, word ptr [bp+var2_SI+2] ; varMemberOffsetEnd_Word1
			;
			; ...swapped AX	& DX
			;
sub	dx, [bp+varMemberOffsetStart_Word1] ; arg2_ErrNo
sbb	ax, [bp+varMemberOffsetStart_Word2] ; ~= Record	Size = (End - Start)
			;
mov	word ptr [bp+var2_SI], ax ;
			;
			; AX = OffsetEnd_Word2 - OffsetStart_Word2
			;
mov	[bp+var_idkMemberSize],	dx ;
			;
			; DX = OffsetEnd_Word1 - OffsetStart_Word1
			;
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+varMemberOffsetStart_Word2]	; arg2_OffsetHigh
push	[bp+varMemberOffsetStart_Word1]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SEEK_SUCCESS2 ; Jump if Not Zero (ZF=0)

SEEK_FAILURE2:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_SUCCESS2:		; CODE XREF: LBX_Load_Entry+23Bj
xor	ax, ax		; Logical Exclusive OR
mov	dx, 16		; ?divide by 16	bytes/paragraph?
push	ax
push	dx		; argPtrSrcBuf
push	word ptr [bp+var2_SI] ;	argPtrSrcBuf
push	[bp+var_idkMemberSize]
call	LDIV@		; Long Division
			; ...
			; BCpp says
			; ldiv(long numerator, long denominator)
			;   returns struct ldiv_t {long	quotient, long remainder}
			; ...
			; not sure about the push 0, push 16
			; maybe	the 16 in the number base?
			;
inc	ax		; ?add a paragraph?
mov	[bp+varBytesToAllocate], ax
mov	ax, [bp+arg6_DI]
or	ax, ax		; Logical Inclusive OR
jz	short Srtgy0_Malloc ; Jump if Zero (ZF=1)

NOT_Srtgy0:		; Compare Two Operands
cmp	ax, 1
jz	short Srtgy1_check ; Jump if Zero (ZF=1)

NOT_Srtgy1:		; Compare Two Operands
cmp	ax, 2
jnz	short Srtgy3	; Jump if Not Zero (ZF=0)

Srtgy2_jmp:		; Jump
jmp	Srtgy2_check

Srtgy3:			; CODE XREF: LBX_Load_Entry+273j
jmp	loc_153BD	; Jump

Srtgy0_Malloc:		; CODE XREF: LBX_Load_Entry+269j
push	[bp+varBytesToAllocate]
call	malloc_s14954	; void*	malloc (size_t size);
			; Allocate memory block
			; Allocates a block of size bytes of memory, returning a pointer to the	beginning of the block.
pop	cx
mov	[bp+varLbxMemBuf], ax
cmp	[bp+varLbxMemBuf], 0 ; Compare Two Operands
jnz	short loc_152D8	; Jump if Not Zero (ZF=0)

FAILURE_MALLOC:		; argLbxEntryNumber
push	di
mov	ax, e_INSUFFICIENT_MEMORY ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_152D8:		; CODE XREF: LBX_Load_Entry+28Bj
jmp	loc_153BD	; int

Srtgy1_check:		; CODE XREF: LBX_Load_Entry+26Ej
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short Srtgy1_g2g ; Jump	if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

Srtgy1_g2g:		; CODE XREF: LBX_Load_Entry+2A9j
mov	ax, 8
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_1532D	; Jump if Not Below (CF=0)
mov	ax, 8
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; Integer Subtraction
inc	dx		; arg2_ErrNo
push	dx		; int
push	di		; argLbxEntryNumber
mov	ax, e_MISALLOCATED ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_1532D:		; CODE XREF: LBX_Load_Entry+2CBj
mov	ax, [bp+argPtrBuffer_EMS]
inc	ax		; Increment by 1
mov	[bp+varLbxMemBuf], ax
mov	ax, [bp+varBytesToAllocate]
inc	ax		; Increment by 1
push	ax		; argValue

loc_15339:		; CODE XREF: LBX_Load_Entry+37Dj
mov	ax, 10
push	ax		; argOffset
push	[bp+argPtrBuffer_EMS] ;	argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_153BD	; int

Srtgy2_check:		; CODE XREF: LBX_Load_Entry:Srtgy2_jmpj
push	[bp+argPtrBuffer_EMS] ;	argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short Srtgy2_g2g ; Jump	if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

Srtgy2_g2g:		; CODE XREF: LBX_Load_Entry+318j
push	[bp+argPtrBuffer_EMS]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_15390	; Jump if Not Below (CF=0)
push	[bp+argPtrBuffer_EMS]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; arg2_ErrNo
push	dx		; int
push	di		; argLbxEntryNumber
mov	ax, e_ALLOCATION_TOO_SMALL ; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs

loc_1538A:		; Call Procedure
call	near ptr LBX_Load_ErrorHandler

loc_1538D:		; Add
add	sp, 8

loc_15390:		; CODE XREF: LBX_Load_Entry+334j
mov	ax, 10
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+argPtrBuffer_EMS]
add	dx, ax		; Add
mov	[bp+varLbxMemBuf], dx
mov	ax, 10
push	ax
push	[bp+argPtrBuffer_EMS] ;	argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
add	dx, ax		; arg2_ErrNo
push	dx
jmp	loc_15339	; int

loc_153BD:		; CODE XREF: LBX_Load_Entry:Srtgy3j
			; LBX_Load_Entry:loc_152D8j
			; LBX_Load_Entry+30Bj
mov	ax, [bp+varLbxMemBuf]
mov	[bp+varBuffer],	ax
mov	[bp+varBytes], 32768
jmp	short loc_153FC	; Jump

ReadLbxMemberData:	; CODE XREF: LBX_Load_Entry+3C3j
			; LBX_Load_Entry+3CCj
sub	[bp+var_idkMemberSize],	32768 ;	Maybe this is calculating how many 32K chunks to read, for the loop count?
			;
			; [NOTE(JWB): 32,768 (32KB) is the largest power of two	that can be represented	in 16 bits.]
			;
			; [bp+var_idkMemberSize] = ([bp+var_idkMemberSize] - 32,768)
			; sets the OF and CF flags to indicate a borrow	in the signed or unsigned result, respectively
			; SF flag indicates the	sign of	the signed result
			;
sbb	word ptr [bp+var2_SI], 0 ; Subtract with Borrow
			;
			;
			;
			;
push	g_CurrentLbxFileHandle ; Buffer
push	[bp+varBytes]	; Bytes
			; 064 mov     [bp+varBytes], 32768
push	[bp+varBuffer]	; Handle
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SUCCESS_DOS_fread	; Jump if Not Zero (ZF=0)
push	di		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_DOS_fread:	; CODE XREF: LBX_Load_Entry+3AAj
add	[bp+varBuffer],	2048 ; Add

loc_153FC:		; CODE XREF: LBX_Load_Entry+38Bj
cmp	word ptr [bp+var2_SI], 0 ;
			; 2020-12-18:
			; ...still no thoughts on the 'add 2048'
			; Otherwise, now I am thinking that LDIV turns into
			;  the number of iterations and	the other one is the
			;  'bytes remaining'
			; Then,	they loop that many times at 32KB
			; and on-exit they check if 32KB remains and
			;  just	run that loop manually one more	time or
			;  they	change the 'byte to read' to exactly the
			;  'bytes remaining' and read the balance.
			; Not sure how that would look in-the-code, but
			; I did	something similar in the ATS CRC32 function.
jg	short ReadLbxMemberData	; Jump if Greater (ZF=0	& SF=OF)
jl	short loc_1540B	; Jump if Less (SF!=OF)
cmp	[bp+var_idkMemberSize],	32768 ;	32,768 - [bp+var_idkMemberSize]
jnb	short ReadLbxMemberData	; Jump if Not Below (CF=0)

loc_1540B:		; CODE XREF: LBX_Load_Entry+3C5j
cmp	word ptr [bp+var2_SI], 0 ; Compare Two Operands
jl	short loc_15443	; Jump if Less (SF!=OF)
jg	short Read_LTE_32KB ; Jump if Greater (ZF=0 & SF=OF)
cmp	[bp+var_idkMemberSize],	0 ; Compare Two	Operands
jbe	short loc_15443	; Jump if Below	or Equal (CF=1 | ZF=1)

Read_LTE_32KB:		; CODE XREF: LBX_Load_Entry+3D4j
mov	ax, [bp+var_idkMemberSize]
mov	[bp+varBytes], ax
push	g_CurrentLbxFileHandle ; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15443	; Jump if Not Zero (ZF=0)

READ_FAILURE:		; argLbxEntryNumber
push	di
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	si_argLbxFileName ; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15443:		; CODE XREF: LBX_Load_Entry+76j
			; LBX_Load_Entry+3D2j
			; LBX_Load_Entry+3DAj
			; LBX_Load_Entry+3F6j
call	ST_UpdateWorstFreeKb ; Call Procedure
mov	ax, [bp+varLbxMemBuf]
jmp	short $+2	; Jump
pop	di
pop	si_argLbxFileName
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
LBX_Load_Entry endp ; sp-analysis failed



; Attributes: bp-based frame

LBX_Load_s15453	proc far
			; CODE XREF: LBX_PreLoad_s15453+1Ap
			; seg010:loc_14FB9p
			; seg010:00BCp

varDst=	byte ptr -84h
varChrPtrDst= byte ptr -34h
var_20=	word ptr -20h
var_1E=	word ptr -1Eh
var_1C=	word ptr -1Ch
varMbrOffEnd1= word ptr	-1Ah
varMbrOffBeg2= word ptr	-18h
varMbrOffBeg1= word ptr	-16h
var0_offsetDX= word ptr	-14h
var2_offsetCX= word ptr	-12h
varEntryOffsetEnd= word	ptr -10h
varBytes= word ptr -0Eh
varBuffer= word	ptr -0Ch
varBytesToAllocate= word ptr -0Ah
varEntryOffsetStart= word ptr -8
var_6= word ptr	-6
varMemberOffset= word ptr -4
var_2= word ptr	-2
argString_DI= word ptr	6
argLbxName_SI= word ptr	 8
arg0_DestES= dword ptr	0Ah
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h
arg_C= word ptr	 12h

push	bp
mov	bp, sp
sub	sp, 84h		; argSrc
push	si		; src
push	di		; src
mov	di, [bp+argString_DI]
mov	si, [bp+argLbxName_SI]
or	si, si		; Logical Inclusive OR
jge	short loc_15474	; Jump if Greater or Equal (SF=OF)
push	si		; argLbxEntryNumber

loc_15467:		; arg0_LbxFileName
mov	ax, e_NOT_FOUND
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15474:		; CODE XREF: LBX_Load_s15453+11j
cmp	LBX_FLAG_NoMalloc, 0 ; Compare Two Operands
jnz	short loc_1548E	; Jump if Not Zero (ZF=0)
mov	LBX_FLAG_NoMalloc, 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	g_ptrBufferReadFile, ax

loc_1548E:		; CODE XREF: LBX_Load_s15453+26j
push	di		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
push	[bp+arg_C]
push	[bp+arg_A]
push	[bp+arg_8]
push	word ptr [bp+arg0_DestES+2]
push	word ptr [bp+arg0_DestES]
push	si
push	di
call	idk_PreEmmPgCnt	; Call Procedure
add	sp, 0Eh		; Add
mov	[bp+var_2], ax
mov	[bp+var_6], 0
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_154BF	; Jump if Zero (ZF=1)
jmp	loc_1590B	; Jump

loc_154BF:		; CODE XREF: LBX_Load_s15453+67j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short loc_154E1	; Jump if Zero (ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	di		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_154E1	; Jump if Not Zero (ZF=0)
mov	ax, g_CurrentLbxFilePosition
cmp	ax, [bp+var_6]	; Compare Two Operands
jnz	short loc_154E1	; Jump if Not Zero (ZF=0)

j_TEST_ENTRY_COUNT:	; Jump
jmp	TEST_ENTRY_COUNT

loc_154E1:		; CODE XREF: LBX_Load_s15453+71j
			; LBX_Load_s15453+81j
			; LBX_Load_s15453+89j
mov	ax, [bp+var_6]
mov	g_CurrentLbxFilePosition, ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short loc_154F8	; Jump if Zero (ZF=1)
push	g_CurrentLbxFileHandle
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_154F8:		; CODE XREF: LBX_Load_s15453+99j
push	di
mov	ax, offset g_CurrentLbxFileNameBase ; argSrc
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	di		; argSrc
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax		; argSrc
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short loc_1558B	; Jump if Not Zero (ZF=0)
cmp	byte ptr g_LbxDirectoryPath, 0 ; Compare Two Operands
jnz	short loc_15548	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15548:		; CODE XREF: LBX_Load_s15453+E5j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+varChrPtrDst] ;	Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short loc_1558B	; Jump if Not Zero (ZF=0)

NOT_FOUND:		; argLbxEntryNumber
push	si
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1558B:		; CODE XREF: LBX_Load_s15453+DEj
			; LBX_Load_s15453+128j
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short SEEK_0	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_0:			; CODE XREF: LBX_Load_s15453+13Dj
mov	[bp+var2_offsetCX], 0
mov	[bp+var0_offsetDX], 0
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+var2_offsetCX] ; arg2_OffsetHigh
push	[bp+var0_offsetDX] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short READ_LBX_HEADER ;	Jump if	Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short READ_TEST_MAGSIG ; Jump

READ_LBX_HEADER:	; CODE XREF: LBX_Load_s15453+16Bj
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	g_ptrBufferReadFile ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

READ_TEST_MAGSIG:	; CODE XREF: LBX_Load_s15453+178j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short READ_ENTRY_COUNT ; Jump if Zero (ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation

loc_155FC:
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

READ_ENTRY_COUNT:	; CODE XREF: LBX_Load_s15453+1A0j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	g_CurrentLbxEntryCount,	ax

TEST_ENTRY_COUNT:	; CODE XREF: LBX_Load_s15453:j_TEST_ENTRY_COUNTj
cmp	si, g_CurrentLbxEntryCount ; Compare Two Operands
jl	short MemberOffsetMath ; Jump if Less (SF!=OF)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

MemberOffsetMath:	; CODE XREF: LBX_Load_s15453+1C5j
mov	ax, si
mov	cl, 2		; arg4_LbxEntryNumber
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+varMemberOffset], ax
push	[bp+varMemberOffset]
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMbrOffBeg1], dx
mov	[bp+varMbrOffBeg2], ax
mov	ax, [bp+varMemberOffset]
add	ax, 4		; Add
push	ax
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+varMbrOffEnd1], dx
mov	[bp+var_1C], ax
mov	ax, [bp+varMbrOffEnd1]
mov	dx, [bp+var_1C]
sub	dx, [bp+varMbrOffBeg2] ; arg2_ErrNo
sbb	ax, [bp+varMbrOffBeg1] ; Integer Subtraction with Borrow
mov	[bp+var_1E], ax
mov	[bp+var_20], dx
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+varMbrOffBeg1] ; arg2_OffsetHigh
push	[bp+varMbrOffBeg2] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15699	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber

loc_15689:
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName

loc_15690:		; arg6_MemShort
push	ax
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15699:		; CODE XREF: LBX_Load_s15453+233j
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+varEntryOffsetStart] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+varEntryOffsetEnd] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
cmp	[bp+varEntryOffsetEnd],	0 ; Compare Two	Operands
jz	short loc_156CF	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_C]
cmp	ax, [bp+varEntryOffsetEnd] ; Compare Two Operands
jz	short loc_156E0	; Jump if Zero (ZF=1)

loc_156CF:		; CODE XREF: LBX_Load_s15453+272j
push	si		; argLbxEntryNumber
mov	ax, e_INCORRECT_RECORD_SIZE
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_156E0:		; CODE XREF: LBX_Load_s15453+27Aj
mov	ax, [bp+arg_8]
add	ax, [bp+arg_A]	; Add
cmp	ax, [bp+varEntryOffsetStart] ; Compare Two Operands
jbe	short loc_156FC	; Jump if Below	or Equal (CF=1 | ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_DEFINED_RECORDS
push	ax		; ErrNo

loc_156F0:		; arg0_LbxFileName
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; arg6_MemShort

loc_156F4:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_156FC:		; CODE XREF: LBX_Load_s15453+296j
mov	bx, [bp+arg_8]
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+varEntryOffsetEnd]
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
add	ax, 4		; Add
adc	dx, 0		; arg2_ErrNo
add	[bp+varMbrOffBeg2], ax ; Add
adc	[bp+varMbrOffBeg1], dx ; Add with Carry
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+varMbrOffBeg1] ; arg2_OffsetHigh
push	[bp+varMbrOffBeg2] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1573E	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1573E:		; CODE XREF: LBX_Load_s15453+2D8j
mov	bx, [bp+arg_A]
xor	cx, cx		; Logical Exclusive OR
mov	ax, [bp+varEntryOffsetEnd]
xor	dx, dx		; Logical Exclusive OR
call	LXMUL@		; Call Procedure
mov	[bp+var_1E], dx
mov	[bp+var_20], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 10h		; arg2_ErrNo
push	ax
push	dx		; arg2_SI
push	[bp+var_1E]
push	[bp+var_20]	; int
call	LDIV@		;   xor	    cx,	cx
			;   jmp	    short loc_1064E
inc	ax		; ?add a paragraph?
mov	[bp+varBytesToAllocate], ax
mov	ax, word ptr [bp+arg0_DestES+2]
or	ax, ax		; Logical Inclusive OR
jz	short loc_15780	; Jump if Zero (ZF=1)

loc_15770:		; Compare Two Operands
cmp	ax, 1
jz	short loc_157A3	; Jump if Zero (ZF=1)
cmp	ax, 2		; Compare Two Operands
jnz	short loc_1577D	; Jump if Not Zero (ZF=0)
jmp	loc_15812	; Jump

loc_1577D:		; CODE XREF: LBX_Load_s15453+325j
jmp	loc_15885	; Jump

loc_15780:		; CODE XREF: LBX_Load_s15453+31Bj
push	[bp+varBytesToAllocate]
call	malloc_s14954	; Call Procedure
pop	cx
mov	[bp+var_2], ax
cmp	[bp+var_2], 0	; Compare Two Operands
jnz	short loc_157A0	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_INSUFFICIENT_MEMORY ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_157A0:		; CODE XREF: LBX_Load_s15453+33Dj
jmp	loc_15885	; int

loc_157A3:		; CODE XREF: LBX_Load_s15453+320j
push	word ptr [bp+arg0_DestES] ; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_157BE	; Jump if Not Zero (ZF=0)

loc_157B0:		; argLbxEntryNumber
push	si
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_157BE:		; CODE XREF: LBX_Load_s15453+35Bj
mov	ax, 8
push	ax

loc_157C2:		; argOffset
push	word ptr [bp+arg0_DestES]
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
dec	ax		; Decrement by 1
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_157F5	; Jump if Not Below (CF=0)
mov	ax, 8
push	ax
push	word ptr [bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; Integer Subtraction
inc	dx		; arg2_ErrNo
push	dx		; int
push	si		; argLbxEntryNumber
mov	ax, e_MISALLOCATED ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_157F5:		; CODE XREF: LBX_Load_s15453+37Dj
mov	ax, word ptr [bp+arg0_DestES]
inc	ax		; Increment by 1
mov	[bp+var_2], ax
mov	ax, [bp+varBytesToAllocate]
inc	ax		; Increment by 1
push	ax		; argValue

loc_15801:		; CODE XREF: LBX_Load_s15453+42Fj
mov	ax, 10
push	ax		; argOffset
push	word ptr [bp+arg0_DestES] ; argSegment
call	fncStoSW	; Call Procedure
add	sp, 6		; Add
jmp	short loc_15885	; int

loc_15812:		; CODE XREF: LBX_Load_s15453+327j
push	word ptr [bp+arg0_DestES] ; argPtrBuffer
call	ST_Chk_12FA_4ECF ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1582D	; Jump if Not Zero (ZF=0)

loc_1581F:		; argLbxEntryNumber
push	si

loc_15820:		; arg0_LbxFileName
mov	ax, e_CORRUPTED
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1582D:		; CODE XREF: LBX_Load_s15453+3CAj
push	word ptr [bp+arg0_DestES]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
cmp	ax, [bp+varBytesToAllocate] ; Compare Two Operands
jnb	short loc_15858	; Jump if Not Below (CF=0)
push	word ptr [bp+arg0_DestES]
call	fncSub2ndW1stW	;   mov	    si,	[bp+arg_0]
			;   mov	    ax,	8
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   push    ax
			;   mov	    ax,	10
			;   push    ax
			;   push    si
			;   call    fncLoadSW;AX=[bp+arg_0];SI=[bp+arg_2];??:DS=AX=[bp+arg_0]
			;   pop	    dx
			;   sub	    dx,	ax
			;   mov	    [bp+var_2],	dx
			;   mov	    ax,	[bp+var_2]
			;   jmp	    short $+2
pop	cx
mov	dx, [bp+varBytesToAllocate]
sub	dx, ax		; arg2_ErrNo
push	dx		; int
push	si		; argLbxEntryNumber
mov	ax, e_ALLOCATION_TOO_SMALL ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 8		; Add

loc_15858:		; CODE XREF: LBX_Load_s15453+3E6j
mov	ax, 10
push	ax
push	word ptr [bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, word ptr [bp+arg0_DestES]
add	dx, ax		; Add
mov	[bp+var_2], dx

loc_1586E:
mov	ax, 10
push	ax
push	word ptr [bp+arg0_DestES] ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	dx, [bp+varBytesToAllocate]

loc_1587F:		; arg2_ErrNo
add	dx, ax
push	dx
jmp	loc_15801	; int

loc_15885:		; CODE XREF: LBX_Load_s15453:loc_1577Dj
			; LBX_Load_s15453:loc_157A0j
			; LBX_Load_s15453+3BDj
mov	ax, [bp+var_2]
mov	[bp+varBuffer],	ax
mov	[bp+varBytes], 32768

loc_15890:		; Jump
jmp	short loc_158C4

loc_15892:		; CODE XREF: LBX_Load_s15453+475j
			; LBX_Load_s15453+47Ej
sub	[bp+var_20], 32768 ; Integer Subtraction
sbb	[bp+var_1E], 0	; Integer Subtraction with Borrow

loc_1589B:		; argFileHandle
push	g_CurrentLbxFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_158BF	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_158BF:		; CODE XREF: LBX_Load_s15453+45Cj
add	[bp+varBuffer],	2048 ; Add

loc_158C4:		; CODE XREF: LBX_Load_s15453:loc_15890j
cmp	[bp+var_1E], 0	; Compare Two Operands
jg	short loc_15892	; Jump if Greater (ZF=0	& SF=OF)

loc_158CA:		; Jump if Less (SF!=OF)
jl	short loc_158D3
cmp	[bp+var_20], 8000h ; Compare Two Operands
jnb	short loc_15892	; Jump if Not Below (CF=0)

loc_158D3:		; CODE XREF: LBX_Load_s15453:loc_158CAj
cmp	[bp+var_1E], 0	; Compare Two Operands
jl	short loc_1590B	; Jump if Less (SF!=OF)
jg	short loc_158E1	; Jump if Greater (ZF=0	& SF=OF)
cmp	[bp+var_20], 0	; Compare Two Operands
jbe	short loc_1590B	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_158E1:		; CODE XREF: LBX_Load_s15453+486j
mov	ax, [bp+var_20]
mov	[bp+varBytes], ax
push	g_CurrentLbxFileHandle ; argFileHandle
push	[bp+varBytes]	; argBytes
push	[bp+varBuffer]	; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1590B	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1590B:		; CODE XREF: LBX_Load_s15453+69j
			; LBX_Load_s15453+484j
			; LBX_Load_s15453+48Cj
			; LBX_Load_s15453+4A8j
call	ST_UpdateWorstFreeKb ; Call Procedure
mov	ax, [bp+var_2]
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
LBX_Load_s15453	endp ; sp-analysis failed



; Attributes: bp-based frame

; int __fastcall __far LBX_Load_HelpNewTerrCity(int, int, int, int, int, int, int, int,	int)
LBX_Load_HelpNewTerrCity proc far
			; CODE XREF: LBX_HelpEntry_s13EEE+1AP
			; LBX_HelpEntry_s3D9F3+1AP
			; LBX_NewGame_s41A5F+1B2P
			; LBX_HelpEntry_s433B8+1AP
			; LBX_HelpEntry_s433EB+1AP
			; LBX_HelpEntry_s4341E+1AP
			; LBX_HelpEntry_s43451+1AP
			; LBX_HelpEntry_s43484+1AP
			; LBX_HelpEntry_s434C3+1AP
			; LBX_HelpEntry_s434F6+1AP
			; LBX_Terrtype_s472C7+2AP
			; LBX_Terrtype_s4763F+2AP
			; LBX_Terrtype_s48821+2AP
			; LBX_Cityname_s4B973+27P
			; LBX_Cityname_s4B973+ADP
			; idk_OVR_LoadLbxHelp:loc_55D8DP
			; idk_OVR_LoadLbxHelp+268P
			; idk_OVR_LoadLbxHelp:loc_56014P

argDest= byte ptr -80h
argDst=	byte ptr -30h
var_1C=	word ptr -1Ch
var_1A=	word ptr -1Ah
var_18=	word ptr -18h
var_16=	word ptr -16h
var_14=	word ptr -14h
var_12=	word ptr -12h
arg0_OffsetLow=	word ptr -10h
arg2_OffsetHigh= word ptr -0Eh
var_C= word ptr	-0Ch
argByteCount= word ptr -0Ah
argBuffer= word	ptr -8
var_6_ZERO= word ptr -6
var_4= word ptr	-4
var_2= word ptr	-2
argString= word	ptr  6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
arg_A= word ptr	 10h

push	bp
mov	bp, sp
sub	sp, 80h		; Integer Subtraction
push	si
push	di
mov	di, [bp+argString]
mov	si, [bp+arg_2]
or	si, si		; Logical Inclusive OR
jge	short loc_1593C	; Jump if Greater or Equal (SF=OF)
push	si		; argLbxEntryNumber

loc_1592F:		; arg0_LbxFileName
mov	ax, e_NOT_FOUND
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_1593C:		; CODE XREF: LBX_Load_HelpNewTerrCity+11j
cmp	LBX_FLAG_NoMalloc, 0 ; Compare Two Operands
jnz	short loc_15956	; Jump if Not Zero (ZF=0)
mov	LBX_FLAG_NoMalloc, 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	g_ptrBufferReadFile, ax

loc_15956:		; CODE XREF: LBX_Load_HelpNewTerrCity+26j
push	di		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
push	[bp+arg_A]
push	[bp+arg_8]
push	[bp+arg_6]
push	[bp+arg_4]
push	si
push	di
call	EMS_s17408	; Call Procedure
add	sp, 0Ch		; Add
mov	[bp+var_2], ax
mov	[bp+var_6_ZERO], 0
cmp	[bp+var_2], 0	; Compare Two Operands
jz	short loc_15984	; Jump if Zero (ZF=1)
jmp	loc_15C3F	; Jump

loc_15984:		; CODE XREF: LBX_Load_HelpNewTerrCity+64j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short loc_159A6	; Jump if Zero (ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	di		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_159A6	; Jump if Not Zero (ZF=0)
mov	ax, g_CurrentLbxFilePosition
cmp	ax, [bp+var_6_ZERO] ; Compare Two Operands
jnz	short loc_159A6	; Jump if Not Zero (ZF=0)
jmp	loc_15AC1	; Jump

loc_159A6:		; CODE XREF: LBX_Load_HelpNewTerrCity+6Ej
			; LBX_Load_HelpNewTerrCity+7Ej
			; LBX_Load_HelpNewTerrCity+86j
mov	ax, [bp+var_6_ZERO]
mov	g_CurrentLbxFilePosition, ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short loc_159BD	; Jump if Zero (ZF=1)
push	g_CurrentLbxFileHandle
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

loc_159BD:		; CODE XREF: LBX_Load_HelpNewTerrCity+96j
push	di
mov	ax, 0A5CCh
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	di
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short loc_15A4D	; Jump if Not Zero (ZF=0)
cmp	byte ptr g_LbxDirectoryPath, 0 ; Compare Two Operands
jnz	short loc_15A0D	; Jump if Not Zero (ZF=0)

loc_159FF:		; argLbxEntryNumber
push	si
mov	ax, e_NOT_FOUND	; arg0_LbxFileName
push	ax		; ErrNo

loc_15A04:		; arg6_MemShort
push	di

loc_15A05:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15A0D:		; CODE XREF: LBX_Load_HelpNewTerrCity+E2j
mov	ax, offset g_LbxDirectoryPath
push	ax		; argSrc
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; Compare Two	Operands
jnz	short loc_15A4D	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber

loc_15A40:		; arg0_LbxFileName
mov	ax, e_NOT_FOUND
push	ax		; ErrNo
push	di		; arg6_MemShort

loc_15A45:		; No Operation
nop
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15A4D:		; CODE XREF: LBX_Load_HelpNewTerrCity+DBj
			; LBX_Load_HelpNewTerrCity+122j
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 0
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+arg2_OffsetHigh] ; arg2_OffsetHigh
push	[bp+arg0_OffsetLow] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15A7A	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short loc_15A8B	; Jump

loc_15A7A:		; CODE XREF: LBX_Load_HelpNewTerrCity+150j
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	g_ptrBufferReadFile ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

loc_15A8B:		; CODE XREF: LBX_Load_HelpNewTerrCity+15Dj
add	sp, 6		; Add
mov	ax, 2
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short loc_15AB0	; Jump if Zero (ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_NOT_AN_LBX ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15AB0:		; CODE XREF: LBX_Load_HelpNewTerrCity+185j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	g_CurrentLbxEntryCount,	ax

loc_15AC1:		; CODE XREF: LBX_Load_HelpNewTerrCity+88j
cmp	si, g_CurrentLbxEntryCount ; Compare Two Operands
jl	short loc_15AD5	; Jump if Less (SF!=OF)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_LBX_ENTRIES ; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15AD5:		; CODE XREF: LBX_Load_HelpNewTerrCity+1AAj
mov	ax, si
mov	cl, 2		; arg4_LbxEntryNumber
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+var_4], ax
push	[bp+var_4]
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_12], dx
mov	[bp+var_14], ax
mov	ax, [bp+var_4]
add	ax, 4		; Add
push	ax
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_16], dx
mov	[bp+var_18], ax
mov	ax, [bp+var_16]
mov	dx, [bp+var_18]
sub	dx, [bp+var_14]	; arg2_ErrNo
sbb	ax, [bp+var_12]	; Integer Subtraction with Borrow
mov	[bp+var_1A], ax
mov	[bp+var_1C], dx
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+var_12]	; arg2_OffsetHigh
push	[bp+var_14]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short SEEK_SUCCESS ; Jump if Not Zero (ZF=0)

SEEK_FAILURE:		; argLbxEntryNumber
push	si
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SEEK_SUCCESS:		; CODE XREF: LBX_Load_HelpNewTerrCity+218j
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+argBuffer] ; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 2
push	ax		; argByteCount
lea	ax, [bp+var_C]	; Load Effective Address
push	ax		; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
cmp	[bp+var_C], 0	; Compare Two Operands
jz	short loc_15B7C	; Jump if Zero (ZF=1)
mov	ax, [bp+arg_A]
cmp	ax, [bp+var_C]	; Compare Two Operands
jz	short loc_15B8D	; Jump if Zero (ZF=1)

loc_15B7C:		; CODE XREF: LBX_Load_HelpNewTerrCity+257j
push	si		; argLbxEntryNumber
mov	ax, e_INCORRECT_RECORD_SIZE
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15B8D:		; CODE XREF: LBX_Load_HelpNewTerrCity+25Fj
mov	ax, [bp+arg_6]
add	ax, [bp+arg_8]	; Add
cmp	ax, [bp+argBuffer] ; Compare Two Operands
jbe	short loc_15BA9	; Jump if Below	or Equal (CF=1 | ZF=1)
push	si		; argLbxEntryNumber
mov	ax, e_EXCEEDS_DEFINED_RECORDS
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15BA9:		; CODE XREF: LBX_Load_HelpNewTerrCity+27Bj
mov	ax, [bp+arg_6]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
add	ax, 4		; Add
adc	dx, 0		; arg2_ErrNo
add	[bp+var_14], ax	; Add
adc	[bp+var_12], dx	; Add with Carry
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+var_12]	; arg2_OffsetHigh
push	[bp+var_14]	; arg0_OffsetLow
call	ST_DOS_fseek_BOF ; Call	Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15BEE	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED
push	ax		; ErrNo
mov	ax, offset g_CurrentLbxFileNameBase ; arg0_LbxFileName
push	ax		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15BEE:		; CODE XREF: LBX_Load_HelpNewTerrCity+2C0j
mov	ax, [bp+arg_8]
cwd			; AX ->	DX:AX (with sign)
push	ax
mov	ax, [bp+var_C]
push	dx
xor	dx, dx		; Logical Exclusive OR
pop	cx
pop	bx
call	LXMUL@		; Call Procedure
mov	[bp+var_1A], dx
mov	[bp+var_1C], ax
xor	ax, ax		; Logical Exclusive OR
mov	dx, 0EA60h	; arg2_ErrNo
push	ax
push	dx
push	[bp+var_1A]
push	[bp+var_1C]
call	F_LMOD@		;   mov	    ax,	[bp+arg_6]
			;   mov	    dx,	[bp+arg_8]
			;   mov	    bx,	[bp+arg_A]
			;   mov	    cx,	[bp+arg_C]
mov	[bp+argByteCount], ax
push	g_CurrentLbxFileHandle ; argFileHandle
push	[bp+argByteCount] ; argByteCount
push	[bp+arg_4]	; argBuffer
call	ST_DOS_ReadFromFileHandle_1 ; Call Procedure
add	sp, 6		; Add
or	ax, ax		; Logical Inclusive OR
jnz	short loc_15C3F	; Jump if Not Zero (ZF=0)
push	si		; argLbxEntryNumber
mov	ax, e_CORRUPTED	; arg0_LbxFileName
push	ax		; ErrNo
push	di		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15C3F:		; CODE XREF: LBX_Load_HelpNewTerrCity+66j
			; LBX_Load_HelpNewTerrCity+314j
call	ST_UpdateWorstFreeKb ; Call Procedure
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
LBX_Load_HelpNewTerrCity endp ;	sp-analysis failed



; LBX_Load_Entry_4bytes(0,
;			var_E,
;			arg0_OffsetLow,
;			g_IntroLbxEntryNumber,
;			g_IntroLbxFileName)
; Attributes: bp-based frame

; int __fastcall __far LBX_Load_Entry_4bytes(int, int, int, int, int, int, int,	int)
LBX_Load_Entry_4bytes proc far
			; CODE XREF: LBX_AllocMem+B4P
			; LBX_s16A80+B4P
			; LBX_MemAndRead+35P

argDest= byte ptr -70h
argDst=	byte ptr -20h
arg0_OffsetLow=	word ptr -0Ch
arg2_OffsetHigh= word ptr -0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4
varFlag_0_1= word ptr -2
arg_g_IntroLbxFileName=	word ptr  6
arg_g_IntroLbxEntryNumber= word	ptr  8
arg_RecordOffsetStart= word ptr	 0Ah
arg_RecordOffsetEnd= word ptr  0Ch
arg_8_ZERO= word ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 112		; argSrc
push	si		; src
push	di		; src
mov	si, [bp+arg_g_IntroLbxFileName]
mov	di, [bp+arg_g_IntroLbxEntryNumber]
or	di, di		; If (AX == 0) Then Set	(ZF = 1)
jge	short loc_15C6A	; Jump if Greater or Equal (SF=OF)
push	di		; argLbxName
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax		; argLbxErrorNumber
push	si		; argLbxEntryNumber
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15C6A:		; CODE XREF: LBX_Load_Entry_4bytes+10j
cmp	LBX_FLAG_NoMalloc, 0 ; If (AX != 0) Then Set (ZF = 1)
jnz	short UPPERCASE	; Jump if Not Zero (ZF=0)
mov	LBX_FLAG_NoMalloc, 1
mov	ax, 32
push	ax		; argKiloBytes
call	ST_FarMalloc	; Call Procedure
pop	cx
mov	g_ptrBufferReadFile, ax

UPPERCASE:		; CODE XREF: LBX_Load_Entry_4bytes+25j
push	si		; argNameCharArr
nop			; No Operation
push	cs
call	near ptr ST_RemoveExtensionUppercaseName ; Call	Procedure
pop	cx
cmp	[bp+arg_8_ZERO], 0 ; Compare Two Operands
jz	short loc_15C98	; Jump if Zero (ZF=1)
cmp	LBX_Flag_w35B7A, 2 ; Compare Two Operands
jnz	short NOT_TWO	; Jump if Not Zero (ZF=0)

loc_15C98:		; CODE XREF: LBX_Load_Entry_4bytes+45j
mov	[bp+varFlag_0_1], 0
jmp	short loc_15CA4	; Jump

NOT_TWO:		; CODE XREF: LBX_Load_Entry_4bytes+4Cj
mov	[bp+varFlag_0_1], 1

loc_15CA4:		; CODE XREF: LBX_Load_Entry_4bytes+53j
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short OPEN_DIFFERENT_LBX ; Jump	if Zero	(ZF=1)
mov	ax, offset g_CurrentLbxFileNameBase
push	ax
push	si		; str1
call	_stricmp	; Case-Insensitive String Comparison (i.e. strcasecmp)
			; int stricmp (	const char * str1, const char *	str2 );
			;   str1  C string to be compared.
			;   str2  C string to be compared.
			; Return Value
			;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
			;   =0	  the contents of both strings are equal
			;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
pop	cx
pop	cx
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short OPEN_DIFFERENT_LBX ; Jump	if Not Zero (ZF=0)

REQUESTED_LBX_IS_GLOBAL_LBX:
mov	ax, g_CurrentLbxFilePosition
cmp	ax, [bp+varFlag_0_1] ; Compare Two Operands
jnz	short OPEN_DIFFERENT_LBX ; Jump	if Not Zero (ZF=0)

REQUESTED_POS_IS_GLOBAL_POS: ; Jump
jmp	CHECK_ENTRYCOUNT

OPEN_DIFFERENT_LBX:	; CODE XREF: LBX_Load_Entry_4bytes+5Fj
			; LBX_Load_Entry_4bytes+6Fj
			; LBX_Load_Entry_4bytes+77j
mov	ax, [bp+varFlag_0_1]
mov	g_CurrentLbxFilePosition, ax
db 83h,3Eh,68h,3Eh,0FFh	; <BAD>cmp     g_CurrentLbxFileHandle, 0FFFFh ;	Compare	Two Operands
jz	short CONTINUE_NO_GLOBAL_LBX_HANDLE ; Jump if Zero (ZF=1)

CLOSE_GLOBAL_LBX_HANDLE:
push	g_CurrentLbxFileHandle
call	DOS_CloseFileWithHandle	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			;   argFileHandle = BX = file handle
pop	cx

CONTINUE_NO_GLOBAL_LBX_HANDLE:
			; CODE XREF: LBX_Load_Entry_4bytes+87j
push	si
mov	ax, offset g_CurrentLbxFileNameBase
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
push	si
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+argDst]	; Load Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; If (AX != 0) Then Set (ZF =	1)
jnz	short SUCCESS_OPEN_FILE	; Jump if Not Zero (ZF=0)

FAILURE_OPEN_FILE:	; Compare Two Operands
cmp	byte ptr g_LbxDirectoryPath, 0
jnz	short loc_15D2D	; Jump if Not Zero (ZF=0)
push	di
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

loc_15D2D:		; CODE XREF: LBX_Load_Entry_4bytes+D3j
mov	ax, offset g_LbxDirectoryPath
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
lea	ax, [bp+argDst]	; Load Effective Address
push	ax
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+argDest] ; Load	Effective Address
push	ax
call	DOS_OpenFile	; DOS -	OPEN DISK FILE WITH HANDLE (AX = 3D00h)
			;   argFileName
			; Return:
			;   AX = file handle
pop	cx
mov	g_CurrentLbxFileHandle,	ax
cmp	g_CurrentLbxFileHandle,	0 ; If (AX != 0) Then Set (ZF =	1)
jnz	short SUCCESS_OPEN_FILE	; Jump if Not Zero (ZF=0)
push	di
mov	ax, e_NOT_FOUND	; Case 0x0: Not	Found
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

SUCCESS_OPEN_FILE:	; CODE XREF: LBX_Load_Entry_4bytes+CCj
			; LBX_Load_Entry_4bytes+113j
cmp	g_CurrentLbxFilePosition, 0 ; If (AX !=	0) Then	Set (ZF	= 1)
jz	short loc_15D80	; Jump if Zero (ZF=1)
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 512
jmp	short LSEEK	; Jump

loc_15D80:		; CODE XREF: LBX_Load_Entry_4bytes+128j
mov	[bp+arg2_OffsetHigh], 0
mov	[bp+arg0_OffsetLow], 0

LSEEK:			; CODE XREF: LBX_Load_Entry_4bytes+134j
push	g_CurrentLbxFileHandle ; arg4_FileHandle
push	[bp+arg2_OffsetHigh] ; arg2_OffsetHigh
push	[bp+arg0_OffsetLow] ; arg0_OffsetLow
call	ST_DOS_fseek_BOF ;
			; CX:DX	= (signed) offset, from	origin,	of new file position
			; CX:DX	     Offset, in	bytes (signed 32-bit integer)
			; cx = 0 - positive offset 0x0000FFFD (65533)
			;
add	sp, 6		; Add
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short LSEEK_SUCCESS ; Jump if Not Zero (ZF=0)

LSEEK_FAILURE:
push	di
mov	ax, e_CORRUPTED	; Case 0x1: Corrupted
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
jmp	short Check_LBX_MagSig ; Jump

LSEEK_SUCCESS:		; CODE XREF: LBX_Load_Entry_4bytes+154j
push	g_CurrentLbxFileHandle ; argFileHandle
mov	ax, 512
push	ax		; argBytes
push	g_ptrBufferReadFile ; argBuffer
call	ST_DOS_fread	; DOS -	READ FROM FILE OR DEVICE (AH = 3Fh)
			;   DX = argBuffer = Buffer = word_35B78
			;   CX = argBytes = Bytes  = 512
			;   BX = argFileHandle = Handle	= word_3C2DA
			; Return:
			;  -1 =	Success
			;   0 =	Failure

Check_LBX_MagSig:	; CODE XREF: LBX_Load_Entry_4bytes+161j
add	sp, 6		; Add
mov	ax, 2
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
cmp	ax, e_LBX_MagSig ; Check SimTex	LBX File Type ID
jz	short VALID_LBX	; Jump if Zero (ZF=1)
push	di
mov	ax, e_NOT_AN_LBX ; Case	0x6: Invalid LBX
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add

VALID_LBX:		; CODE XREF: LBX_Load_Entry_4bytes+189j
xor	ax, ax		; Logical Exclusive OR
push	ax
push	g_ptrBufferReadFile ; argOffset
call	ST_Read_2B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	g_CurrentLbxEntryCount,	ax

CHECK_ENTRYCOUNT:	; CODE XREF: LBX_Load_Entry_4bytes:REQUESTED_POS_IS_GLOBAL_POSj
cmp	di, g_CurrentLbxEntryCount ; Compare Two Operands
jl	short ENTRYCOUNT_OK ; Jump if Less (SF!=OF)
push	di
mov	ax, e_EXCEEDS_LBX_ENTRIES ; Case 0x7: Exceeds Entry Count
push	ax
push	si		; arg6_MemShort
nop			; No Operation
push	cs
call	near ptr LBX_Load_ErrorHandler ; Call Procedure
add	sp, 6		; Add
Calculate offset into Offset Table, for	Entry Number
Read Record Offset Start
Read Record Offset End

ENTRYCOUNT_OK:		; CODE XREF: LBX_Load_Entry_4bytes+1AEj
mov	ax, di
mov	cl, 2
shl	ax, cl		; Shift	Logical	Left
add	ax, 8		; Add
mov	[bp+var_4], ax	; ...calculated	offset,	based on Entry Number
push	[bp+var_4]
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	bx, [bp+arg_RecordOffsetStart]
mov	[bx+2],	dx	; ...something high offset/addres
mov	[bx], ax	; ...something low offset/addres
mov	ax, [bp+var_4]
add	ax, 4		; Add
push	ax
push	g_ptrBufferReadFile
call	ST_Read_4B_From_Buffer_At_Offset ; Call	Procedure
pop	cx
pop	cx
mov	[bp+var_6], dx
mov	[bp+var_8], ax
mov	bx, [bp+arg_RecordOffsetStart]
mov	ax, [bp+var_6]
mov	dx, [bp+var_8]
sub	dx, [bx]	; Integer Subtraction
sbb	ax, [bx+2]	; Integer Subtraction with Borrow
mov	bx, [bp+arg_RecordOffsetEnd]
mov	[bx+2],	ax
mov	[bx], dx
mov	ax, g_CurrentLbxFileHandle
jmp	short $+2	; Jump
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
LBX_Load_Entry_4bytes endp ; sp-analysis failed



; Attributes: bp-based frame

ST_Set_LbxDirectoryPath	proc far

argDirectoryPath= word ptr  6

push	bp
mov	bp, sp
push	[bp+argDirectoryPath]
mov	ax, offset g_LbxDirectoryPath
push	ax		; argDest
call	_strcpy		; String Copy
			;  from	argDirectoryPath
			;  to g_LbxDirectoryPath
			;
pop	cx
pop	cx
pop	bp
retf			; Return Far from Procedure
ST_Set_LbxDirectoryPath	endp



; Attributes: noreturn bp-based	frame

; int __fastcall __far LBX_Load_ErrorHandler(char *arg0_LbxFileName, int arg2_ErrNo, int arg4_LbxEntryNumber, int arg6_MemShort)
LBX_Load_ErrorHandler proc far
			; CODE XREF: LBX_Load_Entry+1Ap
			; LBX_Load_Entry+FCp
			; LBX_Load_Entry+13Cp
			; LBX_Load_Entry+17Dp
			; LBX_Load_Entry+1B2p
			; LBX_Load_Entry+1D7p
			; LBX_Load_Entry+248p
			; LBX_Load_Entry+295p
			; LBX_Load_Entry+2B3p
			; LBX_Load_Entry+2EAp
			; LBX_Load_Entry+322p
			; LBX_Load_Entry:loc_1538Ap
			; LBX_Load_Entry+3B4p
			; LBX_Load_Entry+400p
			; LBX_Load_s15453+1Bp
			; LBX_Load_s15453+EFp
			; LBX_Load_s15453+132p
			; LBX_Load_s15453+147p
			; LBX_Load_s15453+175p
			; LBX_Load_s15453+1AAp
			; LBX_Load_s15453+1CFp
			; LBX_Load_s15453+240p
			; LBX_Load_s15453+287p
			; LBX_Load_s15453+2A3p
			; LBX_Load_s15453+2E5p
			; LBX_Load_s15453+347p
			; LBX_Load_s15453+365p
			; LBX_Load_s15453+39Cp
			; LBX_Load_s15453+3D4p
			; LBX_Load_s15453+3FFp
			; LBX_Load_s15453+466p
			; LBX_Load_s15453+4B2p
			; LBX_Load_HelpNewTerrCity+1Bp
			; LBX_Load_HelpNewTerrCity+ECp
			; LBX_Load_HelpNewTerrCity+12Cp
			; LBX_Load_HelpNewTerrCity+15Ap
			; LBX_Load_HelpNewTerrCity+18Fp
			; LBX_Load_HelpNewTerrCity+1B4p
			; LBX_Load_HelpNewTerrCity+225p
			; LBX_Load_HelpNewTerrCity+26Cp
			; LBX_Load_HelpNewTerrCity+288p
			; LBX_Load_HelpNewTerrCity+2CDp
			; LBX_Load_HelpNewTerrCity+31Ep
			; LBX_Load_Entry_4bytes+1Ap
			; LBX_Load_Entry_4bytes+DDp
			; LBX_Load_Entry_4bytes+11Dp
			; LBX_Load_Entry_4bytes+15Ep
			; LBX_Load_Entry_4bytes+193p
			; LBX_Load_Entry_4bytes+1B8p
			; LBX_LoadFileMemory+78P
			; LBX_LoadFileMemory+200P
			; LBX_AllocMem+86P
			; LBX_AllocMem+DFP
			; LBX_AllocMem+13BP
			; LBX_s16A80:loc_16B06P
			; LBX_s16A80+F0P
			; LBX_s16A80+136P
			; LBX_s16A80+18EP
			; LBX_EmsMapMem+56P
			; LBX_s16F45+3BP
			; LBX_s16F45+ABP
			; LBX_s16F45+CBP
			; LBX_s16F45+F3P
			; LBX_s16F45+134P
			; LBX_s16F45+156P
			; sub_17BB8+5BP
			; LBX_Load_IntroLbx_s21977+E5P
			; LBX_MemAndRead+1AP
			; LBX_MemAndRead+71P
			; LBX_MemAndRead+B6P

varString_itoa=	byte ptr -8Ch
varDestString= byte ptr	-78h
argLbxName= word ptr  6
argLbxErrorNumber= word	ptr  8
argLbxEntryNumber= word	ptr  0Ah
argAllocShortPages= word ptr  0Ch

push	bp
mov	bp, sp
sub	sp, 8Ch		; Integer Subtraction
push	si
mov	si, [bp+argLbxName]
push	si		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, 10
push	ax		; argBaseRadix
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argLbxEntryNumber] ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
mov	ax, offset strLbxEntryPrefix ; ".LBX [entry "
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strLbxEntrySuffix ; "] "
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	bx, [bp+argLbxErrorNumber]
dec	bx		; Decrement by 1
cmp	bx, 15		; switch 16 cases
jbe	short ErrNoLTE15 ; Jump	if Below or Equal (CF=1	| ZF=1)

UNKNOWN_ERROR:		; default
jmp	loc_16006

ErrNoLTE15:		; CODE XREF: LBX_Load_ErrorHandler+60j
shl	bx, 1		; Shift	Logical	Left
jmp	cs:off_16015[bx] ; switch jump

LbxErrNo_1:		; DATA XREF: seg010:off_16015o
mov	ax, offset strNotFound ; case 0x0

loc_15EE5:		; CODE XREF: LBX_Load_ErrorHandler+81j
			; LBX_Load_ErrorHandler+BAj
			; LBX_Load_ErrorHandler+BFj
			; LBX_Load_ErrorHandler+F7j
			; LBX_Load_ErrorHandler+FDj
			; LBX_Load_ErrorHandler+103j
			; LBX_Load_ErrorHandler+109j
			; LBX_Load_ErrorHandler+10Fj
			; LBX_Load_ErrorHandler+130j
			; LBX_Load_ErrorHandler+136j
			; LBX_Load_ErrorHandler+13Cj
			; LBX_Load_ErrorHandler+17Ej
push	ax		; argSrc
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
jmp	loc_16006	; default

LbxErrNo_2:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strCorrupted	; case 0x1
jmp	short loc_15EE5	; Jump

CASE_0x2:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffMem	; case 0x2
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx

loc_15F08:
mov	ax, 0Ah
push	ax
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	nRequiredMEM_583 ; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strKFree ; "K free. Try removing all	TSR's."
jmp	short loc_15EE5	; Jump

CASE_0x3:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strNotAllocated ; case 0x3
jmp	short loc_15EE5	; Jump

LbxErrNo_5:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strAllocationTooSmall ; case	0x4
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, 10
push	ax
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax		; argPtrCharArr
push	[bp+argAllocShortPages]	; argNumber
call	_itoa		; argNumber,argPtrCharArr,argConversionBase
add	sp, 6		; Add
lea	ax, [bp+varString_itoa]	; Load Effective Address
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strPages ; "	pages"
jmp	loc_15EE5	; Jump

LbxErrNo_7:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strNotAnLbx ; case 0x6
jmp	loc_15EE5	; Jump

LbxErrNo_8:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strExceedsCount ; case 0x7
jmp	loc_15EE5	; Jump

CASE_0x8:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strIncorrectSize ; case 0x8
jmp	loc_15EE5	; Jump

loc_15F82:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strExceedsRecords ; case 0x9
jmp	loc_15EE5	; Jump

loc_15F88:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
push	si		; case 0xA
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDest
call	_strcpy		; argDest,argSrc
pop	cx
pop	cx
mov	ax, offset strLBXext ; ".LBX"
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strCannotBeReloaded ; " cannot be reloaded into EMS w/o being "...
jmp	loc_15EE5	; Jump

CASE_0xB:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffEMM	; case 0xB
jmp	loc_15EE5	; Jump

CASE_0xC:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strOnlyPictures ; case 0xC
jmp	loc_15EE5	; Jump

loc_15FB5:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strInsuffEMM	; case 0xD
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strReservedEmm ; " (Reserved	EMM) "
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_15FD3:		; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strLbxTo ; case 0xE
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strInsuffEMM	; " EMM	loading	error. Insufficient EMM."
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx
mov	ax, offset strReservedEmm ; " (Reserved	EMM) "
jmp	loc_15EE5	; Jump

VGA_ANIM_FRAME_TOO_BIG:	; CODE XREF: LBX_Load_ErrorHandler+67j
			; DATA XREF: seg010:off_16015o
mov	ax, offset strVgaAnimFrameTooBig ; case	0xF
push	ax
lea	ax, [bp+varDestString] ; Load Effective	Address
push	ax		; argDst
call	_strcat		; char*	strcat(char* destination, const	char* source)
pop	cx
pop	cx

loc_16006:		; CODE XREF: LBX_Load_ErrorHandler:UNKNOWN_ERRORj
			; LBX_Load_ErrorHandler+67j
			; LBX_Load_ErrorHandler+7Bj
			; DATA XREF: seg010:off_16015o
lea	ax, [bp+varDestString] ; default
push	ax		; arg0_PrintString
call	EXIT_CleanUp	; Call Procedure
pop	cx
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
LBX_Load_ErrorHandler endp

off_16015 dw offset LbxErrNo_1
			; DATA XREF: LBX_Load_ErrorHandler+67r
dw offset LbxErrNo_2	; jump table for switch	statement
dw offset CASE_0x2
dw offset CASE_0x3
dw offset LbxErrNo_5
dw offset loc_16006
dw offset LbxErrNo_7
dw offset LbxErrNo_8
dw offset CASE_0x8
dw offset loc_15F82
dw offset loc_15F88
dw offset CASE_0xB
dw offset CASE_0xC
dw offset loc_15FB5
dw offset loc_15FD3
dw offset VGA_ANIM_FRAME_TOO_BIG


; ~ASCII case folding
;
; for(i=0;str[i]!=0;i++)
;   if(str[i]<='z' && str[i]>='a')
;     str[i]-=32;
;
; Also,	this means they	are not	using the boolean operation approach.
; To upper case:
;
;  char	upperChar = 'l' & 0x5f
; To lower case:
;    char lowerChar = 'L' ^ 0x20
;
; Attributes: bp-based frame

; char *__cdecl	__far ST_RemoveExtensionUppercaseName(char *argNameCharArr)
ST_RemoveExtensionUppercaseName	proc far
			; CODE XREF: LBX_Load_Entry+3Dp
			; LBX_Load_s15453+3Ep
			; LBX_Load_HelpNewTerrCity+3Ep
			; LBX_Load_Entry_4bytes+3Dp
			; LBX_LoadFileMemory+BP
			; LBX_AllocMem+BP
			; LBX_s16A80+BP
			; sub_17671+1AP

argNameCharArr=	dword ptr  6

push	bp
mov	bp, sp
mov	cx, word ptr [bp+argNameCharArr]
xor	dx, dx		; DX = 0
jmp	short WHILE_NOT_ZERO ; Jump

NOT_ZERO:		; CODE XREF: ST_RemoveExtensionUppercaseName+39j
mov	bx, cx
add	bx, dx		; Add
cmp	byte ptr [bx], 60h ;
			; If Below ASCII Value 61h ("a"), Then NOT_LOWERCASE
jle	short NOT_LOWERCASE ; Jump if Less or Equal (ZF=1 | SF!=OF)

TO_UPPERCASE:
mov	bx, cx
add	bx, dx		; Add
mov	al, [bx]
add	al, -20h	; Subtract 20h to convert to UPPERCASE
			; e.g. 61h(97)("a") - 20h(32) =	41h(61)("A")
mov	bx, cx
add	bx, dx		; Add
mov	[bx], al	; replace with upper-cased character

NOT_LOWERCASE:		; CODE XREF: ST_RemoveExtensionUppercaseName+11j
mov	bx, cx
add	bx, dx		; Add
cmp	byte ptr [bx], '.' ; Check for the period character in the filename
jnz	short NEXT_BYTE	; Jump if Not Zero (ZF=0)

GotTheDot:
mov	bx, cx
add	bx, dx		; Add
mov	byte ptr [bx], 0 ; replace . with 0 to force the loop exit condition

NEXT_BYTE:		; CODE XREF: ST_RemoveExtensionUppercaseName+28j
inc	dx		; Increment by 1

WHILE_NOT_ZERO:		; CODE XREF: ST_RemoveExtensionUppercaseName+8j
mov	bx, cx		; reset	to string value
add	bx, dx		; reset	to string position
cmp	byte ptr [bx], 0 ; Check for End of String (NULL)
jnz	short NOT_ZERO	; Jump if Not Zero (ZF=0)

STRING_END:
pop	bp
retf			; Return Far from Procedure
ST_RemoveExtensionUppercaseName	endp



; Attributes: bp-based frame

setRequiredMEM proc far	; CODE XREF: _main+289P

arg_0= word ptr	 6

push	bp

loc_16073:
mov	bp, sp

loc_16075:
mov	ax, [bp+arg_0]

loc_16078:
mov	nRequiredMEM_583, ax

loc_1607B:
pop	bp

locret_1607C:		; Return Far from Procedure
retf
setRequiredMEM endp

seg010 ends
