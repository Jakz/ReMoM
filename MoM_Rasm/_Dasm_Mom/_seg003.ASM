;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

include	uni.inc	; see unicode subdir of	ida for	info on	unicode

.386
.model large

include	MAGIC_rprd2.inc



; Segment type:	Pure code
seg003 segment byte public 'CODE' use16
assume cs:seg003
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
byte_13FF0 db 0B0h, 0, 0CFh

loc_13FF3:
push	bp

loc_13FF4:
mov	bp, sp

loc_13FF6:
push	es

loc_13FF7:
push	di

loc_13FF8:
push	si

loc_13FF9:
push	ds

loc_13FFA:		;
mov	al, 24h		; Get Interrupt	Vector:	24h, Error Handler
			; Return: ES:BX	-> current interrupt handler

loc_13FFC:
mov	ah, 35h

loc_13FFE:		; DOS -	2+ - GET INTERRUPT VECTOR
int	21h		; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector

loc_14000:		;
mov	offOldInt24ErrorHandler, bx ; Store Segment Offset of original vector

loc_14004:		; Store	Segment	Address	of original vector
mov	segOldInt24ErrorHandler, es

loc_14008:		;
mov	ax, cs		; CS = ?Code Segment?

loc_1400A:		;
mov	ds, ax		; DS = ?CS?
assume ds:seg003

loc_1400C:		;
mov	dx, 0		; Offset of new	handler
			; DS:DX	= ?CS:0?

loc_1400F:		;
mov	al, 24h		; Set Interrupt	Vector:	24h, Error Handler
			; DS:DX	-> new interrupt handler

loc_14011:
mov	ah, 25h

loc_14013:		; DOS -	SET INTERRUPT VECTOR
int	21h		; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt

loc_14015:
mov	dx, [bp+6]

loc_14018:		; Compare Two Operands
cmp	dx, 3

loc_1401B:		; Jump if Sign (SF=1)
js	short loc_14023

loc_1401D:
mov	dx, 1

loc_14020:		; Jump
jmp	short loc_1402B
byte_14022 db 90h	; One-byte nop (0x90) is synonymous with xchg (e)ax,(e)ax.

loc_14023:		; CODE XREF: seg003:loc_1401Bj
cmp	dx, 0		; Compare Two Operands

loc_14026:		; Jump if Not Zero (ZF=0)
jnz	short loc_1402B

loc_14028:
mov	dx, 1

loc_1402B:		; CODE XREF: seg003:loc_14020j
			; seg003:loc_14026j
mov	ah, 36h

loc_1402D:		; DOS -	2+ - GET DISK SPACE
int	21h		; DL = drive code (0 = default,	1 = A, 2 = B, etc.)

loc_1402F:
push	ax

loc_14030:
mov	dx, ds:3CBEh

loc_14034:
mov	ds, word ptr ds:3CC0h
assume ds:seg012

loc_14038:		;
mov	al, 24h		; Set Interrupt	Vector:	24h, Error Handler
			; DS:DX	-> new interrupt handler

loc_1403A:
mov	ah, 25h

loc_1403C:		; DOS -	SET INTERRUPT VECTOR
int	21h		; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt

loc_1403E:
pop	ax

loc_1403F:		; Compare Two Operands
cmp	ax, 0FFFFh

loc_14042:		; Jump if Zero (ZF=1)
jz	short loc_14047

loc_14044:
mov	ax, 0

loc_14047:		; CODE XREF: seg003:loc_14042j
pop	ds
assume ds:dseg

loc_14048:
pop	si
pop	di
pop	es
pop	bp

locret_1404C:		; Return Far from Procedure
retf
byte_1404D db 6, 1Eh, 56h, 57h,	0B4h, 19h, 0CDh, 21h
db 32h,	0E4h, 5Fh, 5Eh,	1Fh, 7,	0CBh

loc_1405C:
push	bp
mov	bp, sp

loc_1405F:
push	es

loc_14060:
push	di
push	ds

loc_14062:
push	si

loc_14063:
mov	dx, [bp+6]
mov	ah, 41h
int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)

loc_1406A:		; Logical Exclusive OR
xor	ah, ah
pop	si
pop	ds
pop	di

loc_1406F:
pop	es

loc_14070:
pop	bp
retf			; Return Far from Procedure


; char *argFileName {AX	= FileSize DX =	FileName}
; Attributes: bp-based frame

; int __cdecl __far DOS_FindFirst(BCpp30_DOSH_dosSearchInfo *argFileName)
DOS_FindFirst proc far	; CODE XREF: sub_14489+29P
			; LBX_LoadFileMemory+B6P
			; sub_17BB8+3DP
			; ST_LoadSaveGamByNbr+50P
			; ST_MagicSet_ReadCreateWrite+1FP
			; sub_3E1DE+132P

varDTA_BX26= BCpp30_DOSH_dosSearchInfo ptr -4

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	di
push	ds
push	si
push	ds
call	Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E = 0
mov	ah, 2Fh
int	21h		; DOS -	GET DISK TRANSFER AREA ADDRESS
			; Return: ES:BX	-> DTA
add	bx, 26		; Add
mov	word ptr [bp+varDTA_BX26.ds_drive], bx
mov	bx, es
mov	word ptr [bp+varDTA_BX26.ds_pattern+1],	bx
push	ds
mov	ah, 4Eh
mov	cx, 0
mov	dx, word ptr [bp+varDTA_BX26.ds_pattern+9]
int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive, path,	and wildcards allowed)
pop	ds
jb	short NOT_FOUND	; Jump if Below	(CF=1)

loc_1409F:
mov	ax, word ptr [bp+varDTA_BX26.ds_pattern+1]
mov	es, ax

loc_140A4:
mov	di, word ptr [bp+varDTA_BX26.ds_drive]

loc_140A7:		; AX = DTA offset 26 = File size in bytes
mov	ax, es:[di]

loc_140AA:		; Add
add	di, 2
mov	dx, es:[di]	; DX = DTA offset 30 = Filename	with extension

loc_140B0:
pop	ds
push	ax
push	dx

loc_140B3:		; FLAG_w3609E =	FLAG_w360BE
call	Restore_Set_FLAG_Mouse_Skip

loc_140B8:
pop	dx
pop	ax
pop	si
pop	ds
pop	di

loc_140BD:
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

NOT_FOUND:		; CODE XREF: DOS_FindFirst+2Bj
mov	ax, 0

loc_140C5:
mov	dx, 0
pop	ds
push	ax
push	dx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE

loc_140D0:
pop	dx
pop	ax
pop	si

loc_140D3:
pop	ds
pop	di

loc_140D5:
pop	es

loc_140D6:
mov	sp, bp

loc_140D8:
pop	bp
retf			; Return Far from Procedure
DOS_FindFirst endp



; Attributes: bp-based frame

NoXrefs_DosGetDtaFindFirst proc	far

var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6

push	bp

loc_140DB:
mov	bp, sp

loc_140DD:		; Integer Subtraction
sub	sp, 4

loc_140E0:
push	es

loc_140E1:
push	di
push	ds
push	si
push	ds

loc_140E5:		; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0
call	Disable_Set_FLAG_Mouse_Skip

loc_140EA:
mov	ah, 2Fh

loc_140EC:		; DOS -	GET DISK TRANSFER AREA ADDRESS
int	21h		; Return: ES:BX	-> DTA

loc_140EE:		; Add
add	bx, 16h

loc_140F1:
mov	[bp+var_4], bx

loc_140F4:
mov	bx, es
mov	[bp+var_2], bx
push	ds
mov	ah, 4Eh
mov	cx, 0
mov	dx, [bp+arg_0]
int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive, path,	and wildcards allowed)
pop	ds
mov	ax, [bp+var_2]

loc_14108:
mov	es, ax
mov	di, [bp+var_4]
mov	ax, es:[di]
add	di, 2		; Add
mov	dx, es:[di]

loc_14116:
pop	ds
push	ax
push	dx
call	Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	dx
pop	ax

loc_14120:
pop	si
pop	ds
pop	di
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
NoXrefs_DosGetDtaFindFirst endp



; Attributes: bp-based frame

sub_14128 proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	es
push	ds
push	si
push	di

loc_1412F:
mov	ax, [bp+arg_0]
push	ax
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
pop	dx
push	ax
push	dx
mov	al, dl
mov	ah, 0Eh
int	21h		; DOS -	SELECT DISK
			; DL = new default drive number	(0 = A,	1 = B, etc.)
			; Return: AL = number of logical drives

loc_14140:
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
pop	bx
pop	dx
cmp	al, bl		; Compare Two Operands
jnz	short loc_14150	; Jump if Not Zero (ZF=0)
mov	bx, 0FFFFh

loc_1414D:		; Jump
jmp	short loc_14153
nop			; No Operation

loc_14150:		; CODE XREF: sub_14128+20j
mov	bx, 0

loc_14153:		; CODE XREF: sub_14128:loc_1414Dj
push	bx

loc_14154:
mov	ah, 0Eh

loc_14156:		; DOS -	SELECT DISK
int	21h		; DL = new default drive number	(0 = A,	1 = B, etc.)
			; Return: AL = number of logical drives
pop	ax
pop	di
pop	si
pop	ds
pop	es
pop	bp
retf			; Return Far from Procedure
sub_14128 endp



; Attributes: bp-based frame

sub_1415F proc far

arg_0= word ptr	 6

push	bp
mov	bp, sp
push	si
push	di

loc_14164:
push	es
push	ds

loc_14166:
mov	ah, 19h

loc_14168:		; DOS -	GET DEFAULT DISK NUMBER
int	21h

loc_1416A:
mov	si, [bp+arg_0]

loc_1416D:		; Add
add	al, 'A'
mov	ah, ':'
mov	[si], ax

loc_14173:		; Add
add	si, 2

loc_14176:
mov	al, '\'

loc_14178:
mov	[si], al

loc_1417A:		; Add
add	si, 1

loc_1417D:
mov	dx, 0

loc_14180:
mov	ah, 47h

loc_14182:		; DOS -	2+ - GET CURRENT DIRECTORY
int	21h		; DL = drive (0=default, 1=A, etc.)
			; DS:SI	points to 64-byte buffer area

loc_14184:		; Logical Exclusive OR
xor	ah, ah

loc_14186:
pop	ds

loc_14187:
pop	es

loc_14188:
pop	di

loc_14189:
pop	si

loc_1418A:
pop	bp

locret_1418B:		; Return Far from Procedure
retf
sub_1415F endp

seg003 ends
