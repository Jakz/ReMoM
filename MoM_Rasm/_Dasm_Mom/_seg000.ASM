;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

include	uni.inc	; see unicode subdir of	ida for	info on	unicode

.386
.model large

include	MAGIC_rprd2.inc



; Segment type:	Pure code
seg000 segment byte public 'CODE' use16
assume cs:seg000
assume es:nothing, ss:seg054, ds:nothing, fs:nothing, gs:nothing


; BORLANDC\LIB\STARTUP\C0.ASM
;
; Attributes: library function

public STARTX
STARTX proc far		; DATA XREF: seg038:ofs_STARTXo

; FUNCTION CHUNK AT 02AD SIZE 00000017 BYTES

mov	dx, seg	dseg	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov dx, DGROUP ; DX =	GROUP Segment address

loc_10003:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	cs:DGROUP@, dx	; IFNDEF  __BOSS__
			;     mov cs:DGROUP@@, dx ; __BOSS__
			; ENDIF

loc_10008:
mov	ah, 30h

loc_1000A:		; DOS -	GET DOS	VERSION
int	21h		; Return: AL = major version number (00h for DOS 1.x)

loc_1000C:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	bp, ds:PSPHigh	; mov bp, ds:[PSPHigh];	BP = Highest Memory Segment Addr
mov	bx, ds:PSPEnv	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov bx, ds:[PSPEnv]; BX = Environment	Segment	address
mov	ds, dx
assume ds:dseg
mov	word ptr _version@, ax ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _version@, ax ; Leep major and minor version number
mov	_psp@, es	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _psp@, es	; Keep Program Segment Prefix address
			; [NOTE: IDA auto-named	this "segx"]
mov	_envseg@, bx	; BORLANDC\LIB\STARTUP\C0.ASM
			; mv _envseg@, bx ; Keep Environment Segment address
mov	word ptr _heaptop@+2, bp ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov word ptr _heaptop@ + 2, bp
call	SaveVectors	; BORLANDC\LIB\STARTUP\C0.ASM
			; ;
			; ; Save several vectors and install default divide by zero handler.
			; ;
			;
mov	ax, _envseg@
mov	es, ax		; Extra	Segment	= Environment Segment
xor	ax, ax		; AX = 0
mov	bx, ax
mov	di, ax		; 0 = AX = BX =	DI
mov	cx, 7FFFh	; BORLANDC\LIB\STARTUP\C0.ASM
			; mv cx, 07FFFh	; Environment cann be >	32 Kbytes
cld			; Clear	Direction Flag

@@EnvLoop:		; CODE XREF: STARTX+3Fj
repne scasb		; Compare String
jcxz	short InitFailed ; Jump	if CX is 0
inc	bx		; BORLANDC\LIB\STARTUP\C0.ASM
			; inc bx ; BX =	Nb environment variables
cmp	es:[di], al	; Compare Two Operands
jnz	short @@EnvLoop	; BORLANDC\LIB\STARTUP\C0.ASM
			; jne @@EnvLoop	; Next variable	...

SaveEnv:		; BORLANDC\LIB\STARTUP\C0.ASM
or	ch, 10000000b
neg	cx		; Two's Complement Negation
mov	_envLng@, cx	; BORLANDC\LIB\STARTUP\C0.ASM
mov	cx, dPtrSize_div2 ; BORLANDC\LIB\STARTUP\C0.ASM
			; mov cx, dPtrSize / 2
			; (dPtrSize / 2	= 1)
shl	bx, cl		; Shift	Logical	Left
add	bx, dPtrSize_mul4 ; BORLANDC\LIB\STARTUP\C0.ASM
			; add bx, dPtrSize * 4
			; (dPtrSize * 4	= 8)
db 83h,0E3h,0F8h ; <BAD>and	bx, 0FFF8h ; BORLANDC\LIB\STARTUP\C0.ASM
			; and bx, not ((dPtrSize * 4) -	1)
mov	_envSize@, bx	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov _envSize@, bx ; Save Environment Variable	Nb.
			;
			;
			; IFNDEF __BOSS__
			;
mov	dx, ds		; BORLANDC\LIB\STARTUP\C0.ASM
			;
			; ; Determine the amount of memory that	we need	to keep
			;
			;
sub	bp, dx		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; BP = remaining size	in paragraphs
mov	di, __stklen	; BORLANDC\LIB\STARTUP\C0.ASM
			; ; DI = Requested stack size
cmp	di, MINSTACK_mul2 ; BORLANDC\LIB\STARTUP\C0.ASM
			;
			; IFDEF	  __NOFLOAT__
			; MINSTACK	  equ	  128	  ; minimal stack size in words
			; ELSE
			; MINSTACK	  equ	  256	  ; minimal stack size in words
			; ENDIF
			;
			; ;
			; ; Make sure that the requested stack size is at least	MINSTACK words.
			; ;
			;
			; cmp di, 2*MINSTACK ; requested stack big enough ?
jnb	short AskedStackOK ; BORLANDC\LIB\STARTUP\C0.ASM
			; jae AskedStackOK

AskedStackNotOK:	; BORLANDC\LIB\STARTUP\C0.ASM
mov	di, MINSTACK_mul2 ; mov	di, 2*MINSTACK ; no -->	use minimal value
mov	__stklen, di	; BORLANDC\LIB\STARTUP\C0.ASM
			; mov __stklen,	di ; override requested	stack size

AskedStackOK:		; CODE XREF: STARTX+65j
add	di, edata@	; BORLANDC\LIB\STARTUP\C0.ASM
			; AskedStackOK	  label	  near
			; IFDEF	_DSSTACK_
			;   add	di, offset DGROUP:edata@
			;   jb	InitFailed		 ; DATA	segment	can NOT	be > 64	Kbytes
			; ENDIF
jb	short InitFailed ; Jump	if Below (CF=1)

loc_10074:		; BORLANDC\LIB\STARTUP\C0.ASM
add	di, __heaplen	; IF LDATA EQ false
			;   add	di, __heaplen
			;   jb	InitFailed    ;	DATA segment can NOT be	> 64 Kbytes
			; ENDIF
jb	short InitFailed ; Jump	if Below (CF=1)

loc_1007A:
mov	cl, 4
shr	di, cl		; BORLANDC\LIB\STARTUP\C0.ASM
			; shr di, cl ; $$$ Do not destroy CL $$$
inc	di		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; DI = DS size in paragraphs
cmp	bp, di		; Compare Two Operands
jb	short InitFailed ; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   jb InitFailed ; Not	enough memory

LDATA_EQ_false:		; BORLANDC\LIB\STARTUP\C0.ASM
cmp	__stklen, 0	; IF LDATA EQ false
			;   ...
			;   cmp	__stklen, 0
			;   je	ExpandDS    ; Expand DS	up to 64 Kb
jz	short ExpandDS	; Jump if Zero (ZF=1)

loc_1008A:		; DATA XREF: __exec+C7r
cmp	__heaplen, 0	; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   ...
			;   cmp	__heaplen, 0
			;   jne	ExcessOfMemory ; Much more available than needed
			;
jnz	short ExcessOfMemory ; Jump if Not Zero	(ZF=0)

ExpandDS:		; CODE XREF: STARTX+88j
			; DATA XREF: __exec+75r
mov	di, 1000h	; BORLANDC\LIB\STARTUP\C0.ASM
			; IF LDATA EQ false
			;   ...
			; ExpandDS	  label	  near
			;   mov	di, 1000h
			;   cmp	bp, di
			;   ja	ExcessOfMemory ; Enough	to run the program
cmp	bp, di		; Compare Two Operands
ja	short ExcessOfMemory ; BORLANDC\LIB\STARTUP\C0.ASM
			; ja ExcessOfMemory ; Enough to	run the	program

loc_10098:
mov	di, bp
jmp	short ExcessOfMemory ; BORLANDC\LIB\STARTUP\C0.ASM
			; jmp short ExcessOfMemory ; Enough to run the program

InitFailed:		; CODE XREF: STARTX+39j
			; STARTX+72j
			; STARTX+78j
			; STARTX+81j
jmp	_abort		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; All	initialization errors arrive here
			; InitFailed label near
			;   jmp	near ptr _abort
			;

ExcessOfMemory:		; CODE XREF: STARTX+8Fj
			; STARTX+96j
			; STARTX+9Aj
mov	bx, di		; BORLANDC\LIB\STARTUP\C0.ASM
			; ; Return to DOS the amount of	memory in excess
			; ; Set	far heap base and pointer
			;
add	bx, dx		; Add
mov	word ptr _heapbase@+2, bx ; mov	word ptr _heapbase@ + 2, bx
mov	word ptr _brklvl@+2, bx	; mov word ptr _brklvl@	+ 2, bx
mov	ax, _psp@
sub	bx, ax		; sub bx, ax ; BX = Number of paragraphs to keep
mov	es, ax		; mov es, ax ; ES = Program Segment Prefix address
mov	ah, 4Ah
push	di		; ; preserve DI
int	21h		; ; this call clobbers SI,DI,BP	!!!!!!
			;
			; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
pop	di		; ; restore  DI
shl	di, cl		; ; $$$	CX is still equal to 4 $$$
cli			; ; req'd for pre-1983 88/86s
mov	ss, dx		; ; Set	the program stack
assume ss:dseg
mov	sp, di
sti			; Set Interrupt	Flag
xor	ax, ax		; IFNDEF __HUGE__
			;
			; ; Reset uninitialized	data area
mov	es, cs:DGROUP@	; mov es, cs:DGROUP@@
mov	di, offset bdata@ ; mov	di, offset DGROUP:bdata@
mov	cx, edata@	; mov cx, offset DGROUP:edata@
sub	cx, di		; Integer Subtraction
cld			; Clear	Direction Flag
rep stosb		; ENDIF
			;
			; ; END: Reset uninitialized data area
			;
			;
			;
			;
cmp	__nfile, size FILE ; ;	 If default number of file handles have	changed	then tell DOS
			; cmp	  __nfile, 20
jbe	short @@NoChange ; jbe	   @@NoChange
cmp	_version@, 3	; cmp _osmajor@, 3 ; Check for >= DOS 3.3
jb	short @@NoChange ; jb	   @@NoChange

loc_100E0:		; ja	  @@DoChange
ja	short @@DoChange_1of5

loc_100E2:		; cmp	  _osminor@, 1Eh
cmp	_osminor@, 30
jb	short @@NoChange ; jb	   @@NoChange

; __linkproc__ DoChange_1of5
@@DoChange_1of5:	; CODE XREF: STARTX:loc_100E0j
mov	ax, 5801h	; mov	  ax, 5801h	 ; Set last fit	allocation
mov	bx, 2
int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function	code: set allocation strategy
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_2of5:	; mov	  ah, 67h	 ; Expand handle table
mov	ah, 67h
mov	bx, __nfile
int	21h		; DOS -	3.3+ - SET HANDLE COUNT
			; BX = desired number of handles (max 255)
jb	short @@BadInit	; jc	  @@BadInit

; __linkproc__ DoChange_3of5
@@DoChange_3of5:	; ; Allocate 16	bytes to find new
mov	ah, 48h		; ;   top of memory address
mov	bx, 1
int	21h		; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_4of5:	; ; Adjust address to point after block
inc	ax
mov	word ptr _heaptop@+2, ax
dec	ax		; ; Change back	and release block
mov	es, ax
assume es:nothing
mov	ah, 49h
int	21h		; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
jb	short @@BadInit	; jc	  @@BadInit

@@DoChange_5of5:	; ; Set	first fit allocation
mov	ax, 5801h
mov	bx, 0
int	21h		; ; Set	first fit allocation
			;
			; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function	code: set allocation strategy
jnb	short @@NoChange ; jnc	   @@NoChange

@@BadInit:		; CODE XREF: STARTX+F1j
			; STARTX+FBj
			; STARTX+104j
			; STARTX+111j
jmp	_abort		; @@BadInit:	  jmp near ptr _abort

@@NoChange:		; CODE XREF: STARTX+D7j
			; STARTX+DEj
			; STARTX+E7j
			; STARTX+11Bj
mov	ah, 0		; @@NoChange:
			;
			; ;	  Prepare main arguments
int	1Ah		; ; get	current	BIOS time in ticks
			;
			; CLOCK	- GET TIME OF DAY
			; Return: CX:DX	= clock	count
			; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
			; midnight
			; Otherwise, AL	> 0

loc_10124:		; ; save it for	clock()	fn
mov	_StartTime@, dx
mov	_StartTime@+2, cx
or	al, al		; ; was	midnight flag set?
			;
			; If (AL == 0) Then Set	(ZF = 1)
jz	short @@NotMidnight ; jz      @@NotMidnight

Set_BIOS_Midnight_flag:
@@SetMidnight:		; ; set	BIOS midnight flag
mov	ax, 40h		; ;  at	40:70
mov	es, ax
assume es:nothing
mov	bx, 70h
mov	byte ptr es:[bx], 1 ; 0040:0070	= 1?

@@NotMidnight:		; CODE XREF: STARTX+12Ej
xor	bp, bp		; ; set	BP to 0	for overlay mgr

loc_1013E:
mov	es, cs:DGROUP@
assume es:nothing
mov	si, offset InitStart ; ;si = start of table
mov	di, offset InitEnd ; ;di = end of table
call	StartExit	; call	  StartExit
			;
			; ; ExitCode = main(argc,argv,envp);
push	envp		; word_31D98 = word_36F98?
push	argv		; argv
push	argc		; argc

CallMain:		; Call Procedure
call	_main
push	ax		; main() Return	Status

alignment:		; Alignment
nop

startup_epilogue:
push	cs
call	near ptr _exit	; 'startup' epilogue

__cleanup:		; CODE XREF: __exit_2of2+26p
mov	es, cs:DGROUP@
push	si
push	di
mov	si, offset InitEnd
mov	di, offset bdata@
call	idk_CleanUp	; Call Procedure
pop	di
pop	si
retf			; Return Far from Procedure
STARTX endp



; BORLANDC\LIB\STARTUP\C0.ASM
; ;---------------------------------------------------------------------------
; ;	  _cleanup()	  call all #pragma exit	cleanup	routines.
; ;	  _checknull()	  check	for null pointer zapping copyright message
; ;	  _terminate(int) exit program with error code
; ;
; ;	  These	functions are called by	exit(),	_exit(), _cexit(),
; ;	  and _c_exit().
; ;---------------------------------------------------------------------------
;
; ;	  Check	for null pointers before exit
;
; __checknull	  PROC	  DIST
;		  PUBLIC  __checknull
;
; IF	  LDATA	EQ false
;   IFNDEF  __TINY__
;		  push	  si
;		  push	  di
;		  mov	  es, cs:DGROUP@@
;		  xor	  ax, ax
;		  mov	  si, ax
;		  mov	  cx, lgth_CopyRight
; ComputeChecksum label	  near
;		  add	  al, es:[si]
;		  adc	  ah, 0
;		  inc	  si
;		  loop	  ComputeChecksum
;		  sub	  ax, CheckSum
;		  jz	  @@SumOk
;		  mov	  cx, lgth_NullCheck
;		  mov	  dx, offset DGROUP: NullCheck
;		  call	  ErrorDisplay
; @@SumOK:	  pop	  di
;		  pop	  si
;   ENDIF
; ENDIF
;		  ret
; __checknull	  ENDP
;
; Attributes: library function

__checknull proc far	; CODE XREF: __exit_2of2+34p
push	si
push	di
mov	es, cs:DGROUP@
xor	ax, ax		; Logical Exclusive OR
mov	si, ax
mov	cx, lgth_CopyRight ; lgth_CopyRight

ComputeChecksum:	; CODE XREF: __checknull+15j
add	al, es:[si]	; Add
adc	ah, 0		; Add with Carry
inc	si		; Increment by 1
loop	ComputeChecksum	; Loop while CX	!= 0
sub	ax, CheckSum	; Integer Subtraction
jz	short @@SumOk	; Jump if Zero (ZF=1)
mov	cx, lgth_NullCheck
mov	dx, offset NullCheck ; "Null pointer assignment\r\n"
call	ErrorDisplay	; Call Procedure

@@SumOk:		; CODE XREF: __checknull+1Aj
pop	di
pop	si
retf			; Return Far from Procedure
__checknull endp



; BORLANDC\LIB\STARTUP\C0.ASM
;
; ;	  Exit to DOS
;
; __terminate	  PROC	  DIST
;		  PUBLIC  __terminate
;		  mov	  bp,sp
;		  mov	  ah,4Ch
;		  mov	  al,[bp+cPtrSize]
;		  int	  21h			  ; Exit to DOS
; __terminate	  ENDP
;
; Attributes: library function noreturn	bp-based frame

__terminate proc near	; CODE XREF: __exit_2of2+4Ep

cPtrSize= byte ptr  4

mov	bp, sp
mov	ah, 4Ch
mov	al, [bp+cPtrSize]
int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
__terminate endp	; AL = exit code

mov	cx, 0Eh
mov	dx, 48h
jmp	MsgExit3	; Jump


; BORLANDC\LIB\STARTUP\C0.ASM
; ;
; ; Save several vectors and install default divide by zero handler.
; ;

SaveVectors proc near	; CODE XREF: STARTX+25p
push	ds

loc_101B1:
mov	ax, 3500h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	word ptr _Int0Vector@, bx
mov	word ptr _Int0Vector@+2, es
mov	ax, 3504h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	word ptr _Int4Vector@, bx
mov	word ptr _Int4Vector@+2, es
mov	ax, 3505h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector

loc_101D0:
mov	word ptr _Int5Vector@, bx
mov	word ptr _Int5Vector@+2, es
mov	ax, 3506h
int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
mov	word ptr _Int6Vector@, bx
mov	word ptr _Int6Vector@+2, es

loc_101E5:		; BORLANDC\LIB\STARTUP\C0.ASM
mov	ax, 2500h	; ;
			; ; Install default divide by zero handler.
			; ;
mov	dx, cs
mov	ds, dx
assume ds:seg000
mov	dx, 1A7h
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
assume ds:dseg
retn			; Return Near from Procedure
SaveVectors endp



; BORLANDC\LIB\STARTUP\C0.ASM
; ;--------------------------------------------------------------------------
; ;	  _restorezero() puts back all the vectors that	SaveVectors took.
; ;
; ;NOTE	: TSRs must BE AWARE that signal() functions which take	these
; ;	  vectors will be deactivated if the keep() function is	executed.
; ;	  If a TSR wants to use	the signal functions when it is	active it
; ;	  will have to save/restore these vectors itself when activated	and
; ;	  deactivated.
; ;--------------------------------------------------------------------------
; __restorezero	  PROC	  DIST
;		  PUBLIC  __restorezero
; IFDEF	  __HUGE__
;		  push	  ds
;		  mov	  ds, cs: DGROUP@@
; ENDIF
;		  push	  ds
;		  mov	  ax, 2500h
;		  lds	  dx, _Int0Vector@
;		  int	  21h
;		  pop	  ds
;
;		  push	  ds
;		  mov	  ax, 2504h
;		  lds	  dx, _Int4Vector@
;		  int	  21h
;		  pop	  ds
;
;		  push	  ds
;		  mov	  ax, 2505h
;		  lds	  dx, _Int5Vector@
;		  int	  21h
;		  pop	  ds
;
; IFNDEF   __HUGE__
;		  push	  ds
; ENDIF
;		  mov	  ax, 2506h
;		  lds	  dx, _Int6Vector@
;		  int	  21h
;		  pop	  ds
;
;		  ret
;		  ENDP
;
; Attributes: library function

__restorezero proc far	; CODE XREF: __exit_2of2+2Fp
push	ds
mov	ax, 2500h
lds	dx, _Int0Vector@ ; Load	Full Pointer to	DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds

loc_101FF:
mov	ax, 2504h
lds	dx, _Int4Vector@ ; Load	Full Pointer to	DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds
mov	ax, 2505h
lds	dx, _Int5Vector@ ; Load	Full Pointer to	DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
push	ds
mov	ax, 2506h
lds	dx, _Int6Vector@ ; Load	Full Pointer to	DS:xx
int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
pop	ds
retf			; Return Far from Procedure
__restorezero endp



; J:\STU\BORLANDC\LIB\STARTUP\C0.ASM
; ;------------------------------------------------------------------
; ;  Loop through a startup/exit (SE) table,
; ;  calling functions in order	of priority.
; ;  ES:SI is assumed to point to the beginning	of the SE table
; ;  ES:DI is assumed to point to the end of the SE table
; ;  First 64 priorities are reserved by Borland
; ;------------------------------------------------------------------
; PNEAR		  EQU	  0
; PFAR		  EQU	  1
; NOTUSED	  EQU	  0ffh
;
; SE		  STRUC
; calltype	  db	  ?			  ; 0=near,1=far,ff=not	used
; priority	  db	  ?			  ; 0=highest,ff=lowest
; addrlow	  dw	  ?
; addrhigh	  dw	  ?
; SE		  ENDS
;
; StartExit	  proc near
; @@Start:
;

StartExit proc near	; CODE XREF: STARTX+149p
			; StartExit+3Aj
			; StartExit+41j
mov	ax, 100h	; IDK, Why this	is different?
			; @@StartLow:
			;   mov	ah,0ffh	; start	with lowest priority
mov	dx, di		; ; set	sentinel to end	of table
mov	bx, si		; ; bx = start of table

@@TopOfTable_1of:	; CODE XREF: StartExit+22j
cmp	bx, di		; ; and	the end	of the table?
jz	short @@EndOfTable_1of2	; je @@EndOfTable ; yes, exit the loop

@@TopOfTable_2of:	; cmp es:[bx.calltype],NOTUSED ; check the call	type
cmp	byte ptr es:[bx], 0FFh
jz	short @@Next	; je	  @@Next
mov	cl, es:[bx+1]
xor	ch, ch		; Logical Exclusive OR
cmp	cx, ax		; Compare Two Operands
jnb	short @@Next	; Jump if Not Below (CF=0)
mov	ax, cx
mov	dx, bx

@@Next:			; CODE XREF: StartExit+Fj
			; StartExit+19j
add	bx, 6		; add bx, SIZE SE ; bx = next item in table
jmp	short @@TopOfTable_1of ; jmp	 @@TopOfTable

@@EndOfTable_1of2:	; CODE XREF: StartExit+9j
cmp	dx, di		; ; did	we exhaust the table?

loc_10246:		; je @@Done : yes, quit
jz	short @@Done

@@EndOfTable_2of2:	; ; BX = highest priority item
mov	bx, dx
cmp	byte ptr es:[bx], e_PNEAR ; ; is it near or far?
mov	byte ptr es:[bx], 0FFh ; ; wipe	the call type
push	es		; ; save es
jz	short @@NearCall ; je	   @@NearCall

@@FarCall:		; call DWORD PTR es:[bx.addrlow]
call	dword ptr es:[bx+2]
pop	es		; ; restore es
jmp	short StartExit	; jmp	  short	@@Start

@@NearCall:		; CODE XREF: StartExit+33j
call	word ptr es:[bx+2] ; call WORD PTR es:[bx.addrlow]
pop	es		; ; restore es
jmp	short StartExit	; Jump

@@Done:			; CODE XREF: StartExit:loc_10246j
retn			; Return Near from Procedure
StartExit endp




idk_CleanUp proc near	; CODE XREF: STARTX+170p
			; idk_CleanUp+37j
			; idk_CleanUp+3Ej
mov	ah, 0
mov	dx, di
mov	bx, si

loc_1026A:		; CODE XREF: idk_CleanUp+1Fj
cmp	bx, di		; Compare Two Operands
jz	short loc_10285	; Jump if Zero (ZF=1)
cmp	byte ptr es:[bx], 255 ;	Compare	Two Operands
jz	short loc_10280	; Jump if Zero (ZF=1)
cmp	es:[bx+1], ah	; Compare Two Operands
jb	short loc_10280	; Jump if Below	(CF=1)
mov	ah, es:[bx+1]
mov	dx, bx

loc_10280:		; CODE XREF: idk_CleanUp+Ej
			; idk_CleanUp+14j
add	bx, 6		; Add
jmp	short loc_1026A	; Jump

loc_10285:		; CODE XREF: idk_CleanUp+8j
cmp	dx, di		; Compare Two Operands
jz	short locret_102A4 ; Jump if Zero (ZF=1)
mov	bx, dx
cmp	byte ptr es:[bx], 0 ; Compare Two Operands
mov	byte ptr es:[bx], 255
push	es
jz	short loc_1029D	; Jump if Zero (ZF=1)
call	dword ptr es:[bx+2] ; Indirect Call Far	Procedure
pop	es
jmp	short idk_CleanUp ; Jump

loc_1029D:		; CODE XREF: idk_CleanUp+30j
call	word ptr es:[bx+2] ; Indirect Call Near	Procedure
pop	es
jmp	short idk_CleanUp ; Jump

locret_102A4:		; CODE XREF: idk_CleanUp+23j
retn			; Return Near from Procedure
idk_CleanUp endp



; BORLANDC\LIB\STARTUP\C0.ASM
;
; ErrorDisplay	  PROC	  NEAR
;		  mov	  ah, 040h
;		  mov	  bx, 2
;		  int	  021h
;		  ret
; ErrorDisplay	  ENDP
;

ErrorDisplay proc near	; CODE XREF: __checknull+22p
			; STARTX+2B8p
mov	ah, 40h
mov	bx, 2		; File Handle 2	is StdErr
int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			;   BX = file handle
			;   CX = number	of bytes to write
			;   DS:DX -> buffer, data to write
			; Return:
			;   CF clear if	successful
			;   AX = number	of bytes actually written
			;   CF set on error
			;   AX = error code
retn			; Return Near from Procedure
ErrorDisplay endp

; START	OF FUNCTION CHUNK FOR STARTX

; void abort(void)
_abort:			; CODE XREF: STARTX:InitFailedj
			; STARTX:@@BadInitj
			; seg000:1C90j
			; unknown_libname_2+39j
			; __OvrPrepare:loc_314B3J
mov	cx, lgth_abortMSG ;
			; ErrorDisplay	  PROC	  NEAR
			;		  mov	  ah, 040h
			;		  mov	  bx, 2
			;		  int	  021h
			;		  ret
			; ErrorDisplay	  ENDP
			;
			; _abort	  PROC	  DIST
			;		  PUBLIC  _abort
			;		  mov	  cx, lgth_abortMSG
			;		  mov	  dx, offset DGROUP: abortMSG
			; MsgExit3	  label	  near
			;		  mov	  ds, cs: DGROUP@@
			;		  call	  ErrorDisplay
			; CallExit3	  label	  near
			;		  mov	  ax, 3
			;		  push	  ax
			;		  call	  __exit	   ; _exit(3);
			;		  ENDP
			;
mov	dx, offset abortMSG ; "Abnormal	program	termination\r\n"

MsgExit3:		; CODE XREF: seg000:01ADj
mov	ds, cs:DGROUP@	; DS = DGROUP;
			; => DS:DX -> buffer, data to write
call	ErrorDisplay	; Call Procedure
mov	ax, 3

CallExit3:		; Exit Status
push	ax
nop			; No Operation
push	cs
call	near ptr __exit__1of2 ;	Call Procedure
; END OF FUNCTION CHUNK	FOR STARTX
DGROUP@	dw 0		; DATA XREF: STARTX:loc_10003w
			; STARTX+C2r
			; STARTX:loc_1013Er
			; STARTX:__cleanupr
			; __checknull+2r
			; STARTX:MsgExit3r
			; __exec+200r
__MMODEL db 2, 80h


; Attributes: library function bp-based	frame

; int __cdecl abs(int x)
_abs proc far		; CODE XREF: sub_1D5DE+3AP
			; sub_1D5DE:loc_1D626P
			; sub_1D906:loc_1D918P
			; sub_1D906:loc_1D926P
			; sub_1D906+3EP
			; sub_1D906+4CP
			; sub_4D5B0:loc_4D740P

x= word	ptr  6

push	bp
mov	bp, sp
mov	ax, [bp+x]
or	ax, ax		; Logical Inclusive OR
jge	short loc_102D4	; Jump if Greater or Equal (SF=OF)
neg	ax		; Two's Complement Negation

loc_102D4:		; CODE XREF: _abs+8j
pop	bp
retf			; Return Far from Procedure
_abs endp



; .\BORLANDC\CRTL\CLIB\ATEXIT.C
;
; #include <stdlib.h>
;
; #define MAX_ATEXIT	  32
;
; int		  _atexitcnt = 0;	  /* count of atexit functions */
; atexit_t	  _atexittbl[MAX_ATEXIT]; /* array of atexit function pointers */
;
; int atexit(atexit_t func)
; {
;	  if (_atexitcnt == MAX_ATEXIT)
;		  return(1);
;	  _atexittbl[_atexitcnt++] = func;
;	  return(0);
; }
;
; Attributes: library function bp-based	frame

; int __cdecl atexit(void (*func)(void))
_atexit	proc far

func= dword ptr	 6

push	bp
mov	bp, sp
cmp	_atexitcnt, 32	; #define MAX_ATEXIT	  32
jnz	short AddAtExitFunction	; Jump if Not Zero (ZF=0)

ExceededMaxAtExitFunctions:
mov	ax, 1
jmp	short loc_10301	; Jump

AddAtExitFunction:	; CODE XREF: _atexit+8j
mov	bx, _atexitcnt
mov	cl, 2
shl	bx, cl		; Shift	Logical	Left
mov	ax, word ptr [bp+func+2]
mov	dx, word ptr [bp+func]
mov	(_atexittbl+2)[bx], ax
mov	_atexittbl[bx],	dx
inc	_atexitcnt	; Increment by 1

loc_102FF:		; Logical Exclusive OR
xor	ax, ax

loc_10301:		; CODE XREF: _atexit+Dj
pop	bp

locret_10302:		; Return Far from Procedure
retf
_atexit	endp

; [000000A9 BYTES: COLLAPSED FUNCTION __DOSCMD.	PRESS KEYPAD "+" TO EXPAND]
; [000000FD BYTES: COLLAPSED FUNCTION __DOSENV.	PRESS KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION __dos_getfileattr. PRESS KEYPAD "+" TO EXPAND]
; [0000001B BYTES: COLLAPSED FUNCTION __dos_setfileattr. PRESS KEYPAD "+" TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __dos_findfirst. PRESS KEYPAD "+"	TO EXPAND]
; [0000002D BYTES: COLLAPSED FUNCTION __dos_findnext. PRESS KEYPAD "+" TO EXPAND]


;   mov	    si,	[bp+drive]
;   mov	    ah,	19h	  ; DOS	- GET DEFAULT DISK NUMBER
;   int	    21h
;   mov	    ah,	0
;   inc	    ax
;   mov	    [si], ax
; Attributes: library function bp-based	frame

; void __cdecl _dos_getdrive(unsigned int *drive)
__dos_getdrive proc far	; CODE XREF: sub_10B5F+1Ep

drive= word ptr	 6

push	bp
mov	bp, sp
push	si
mov	si, [bp+drive]
mov	ah, 19h
int	21h		; DOS -	GET DEFAULT DISK NUMBER
mov	ah, 0
inc	ax		; Increment by 1
mov	[si], ax
pop	si
pop	bp
retf			; Return Far from Procedure
__dos_getdrive endp

; [00000017 BYTES: COLLAPSED FUNCTION __dos_setdrive. PRESS KEYPAD "+" TO EXPAND]
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_1. PRESS KEYPAD "+" TO EXPAND]


; .\BORLANDC\CRTL\CLIB\EXIT.C
;
; /*------------------------------------------------------------------------
;  * filename -	exit.c
;  *
;  * function(s)
;  *	  ___exit - handle the four flavors of exit
;  *	  exit	  - terminate program
;  *	  _exit	  - quick termination
;  *	  _cexit  - perform exit cleanup without termination
;  *	  _c_exit - perform quick exit cleanup without termination
;  *-----------------------------------------------------------------------*/
;
; /*[]------------------------------------------------------------[]*/
; /*|								   |*/
; /*|	  C/C++	Run Time Library - Version 4.0			   |*/
; /*|								   |*/
; /*|								   |*/
; /*|	  Copyright (c)	1987, 1991 by Borland International	   |*/
; /*|	  All Rights Reserved.					   |*/
; /*|								   |*/
; /*[]------------------------------------------------------------[]*/
;
; #include <stdlib.h>
;
; extern  int		  _atexitcnt;	 /* count of atexit function pointers */
; extern  atexit_t	  _atexittbl[];	 /* array of atexit function pointers */
;
; void _terminate( int );		  /* terminate program */
; void _cleanup( void );		  /* call #pragma exit routines	*/
; void _checknull( void	);		  /* check for null pointer usage */
; void _restorezero( void );		  /* restore interrupt vectors */
;
; static  void	  dummy(void)
; {
; }
;
; void	  (*_exitbuf)(void)   =	dummy;
; void	  (*_exitfopen)(void) =	dummy;
; void	  (*_exitopen)(void)  =	dummy;
;
; /*---------------------------------------------------------------------------*
;
; Name		  ___exit - perform cleanup and	optionally terminate the program
;
; Usage		  void ___exit(int quick, int dontexit,	int errcode);
;
; Prototype in	  local
;
; Description	  ___exit is an	internal routine used by the various flavors
;		  of exit.  If the "quick" flag	is false, buffered output
;		  (waiting to be output) is written to files, any registered
;		  "exit	functions"  (posted with atexit) are called, and
;		  #pragma exit functions are called.
;
;		  In all cases,	interrupt vectors taken	by the RTL are
;		  restored, and	in small and medium models, stray NULL pointers
;		  are checked for by seeing if the copyright message
;		  got zapped.
;
;		  Finally, if the "dontexit" flag is false, all	files
;		  are closed, and the program is terminated with the
;		  error	code "errcode".
;
; Return value	  If dontexit is false,	___exit	never returns; otherwise
;		  it returns no	value.
;
; *----------------------------------------------------------------------------*/
; static void pascal near ___exit(int quick, int dontexit, int errcode)
; {
;     if (!quick)
;     {
;	  /* Execute "atexit" functions
;	   */
;	  while	(_atexitcnt)
;	      (*_atexittbl[--_atexitcnt])();
;
;	  /* Run #pragma exit routines
;	   */
;	  _cleanup();
;
;	  /* Flush files.
;	   */
;	  (*_exitbuf)();
;     }
;
;
;     /* Restore interrupt vectors.
;      */
;     _restorezero();
;
;     /* Check for stray NULL pointers zapping the copyright message.
;      */
;     _checknull();
;
;     if (!dontexit)
;     {
;	  if (!quick)
;	  {
;	      (*_exitfopen)();	  /* close stream files	*/
;	      (*_exitopen)();	  /* close handle files	*/
;	  }
;	  _terminate(errcode);	  /* terminate program */
;     }
; }
;
; Attributes: library function bp-based	frame

; int __stdcall	_exit_2of2(int quick, int dontexit, int	errcode)
__exit_2of2 proc near	; CODE XREF: _exit+Ap
			; __exit__1of2+Dp
			; __cexit+Ap
			; __c_exit+8p

quick= word ptr	 4
dontexit= word ptr  6
errcode= word ptr  8

push	bp
mov	bp, sp
push	si
mov	si, [bp+errcode]
or	si, si		; if (!quick)
jnz	short loc_10599	; /* Execute "atexit" functions	*/

NotQuick:		; Jump
jmp	short loc_10589

Loop_Next_AtExitTbl:	; CODE XREF: __exit_2of2+22j
dec	_atexitcnt	; while	(_atexitcnt)
			;
			;     (*_atexittbl[--_atexitcnt])();
			;
mov	bx, _atexitcnt	; ...
mov	cl, 2		; e.g.,
			; _atexittabl =	[ptr1, ptr2, ptr3]
			;
			; _atexitcnt = 2
			;
			; _atexitcnt = 1
			;
			; _atexitcnt = 0
			;
shl	bx, cl		; ...
			;
call	dword ptr _atexittbl[bx] ; Indirect Call Far Procedure

loc_10589:		; CODE XREF: __exit_2of2:NotQuickj
cmp	_atexitcnt, 0	; while	(_atexitcnt)
jnz	short Loop_Next_AtExitTbl ; Jump if Not	Zero (ZF=0)
nop			;     /* Run #pragma exit routines */
			;     _cleanup();
			;     /* Flush files. */
			;     (*_exitbuf)();
push	cs
call	__cleanup	; Call Procedure
call	ptr_exitbuf	; Indirect Call	Far Procedure

loc_10599:		; CODE XREF: __exit_2of2+9j
nop			; /* Restore interrupt vectors.	*/
			; _restorezero();
			;
			; /* Check for stray NULL pointers zapping the copyright message. */
			; _checknull();
push	cs
call	near ptr __restorezero ; Call Procedure
nop			; No Operation
push	cs
call	near ptr __checknull ; Call Procedure
cmp	[bp+dontexit], 0 ; if (!dontexit)
jnz	short DO_NOT_TERMINATE ; Jump if Not Zero (ZF=0)
or	si, si		; if (!quick)
jnz	short NotDontExitIsQuick ; Jump	if Not Zero (ZF=0)

NotDontExitNotQuick:	; (*_exitfopen)();  /* close stream files */
call	ptr_exitfopen	; (*_exitopen)();   /* close handle files */
call	ptr_exitopen	; Indirect Call	Far Procedure

NotDontExitIsQuick:	; CODE XREF: __exit_2of2+3Fj
push	[bp+quick]
nop			; No Operation
push	cs
call	__terminate	; Call Procedure
db  59h	; Y

DO_NOT_TERMINATE:	; CODE XREF: __exit_2of2+3Bj
pop	si
pop	bp
retn	6		; Return Near from Procedure
__exit_2of2 endp



; BORLANDC\LIB\STARTUP\C0.ASM
;
; _exit
;
; Function
;	   Terminates program.
;
; Syntax#
;	   #include <stdlib.h>
;	  void _exit(int status);
;
; Remarks
;	   _exit terminates execution without closing any files, flushing any output, or calling any exit functions.
;	   The calling process uses status as the exit status of the process.
;	   Typically a value of	a is used to indicate a	normal exit, and a nonzero value indicates some	error.
;
; Return value
;		None.
; Attributes: library function noreturn	bp-based frame

; void __cdecl exit(int	status)
_exit proc far		; CODE XREF: STARTX+160p

quick= word ptr	 6

push	bp
mov	bp, sp
xor	ax, ax		; Logical Exclusive OR
push	ax		; errcode
push	ax		; dontexit
push	[bp+quick]	; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
pop	bp
retf			; Return Far from Procedure
_exit endp



; BORLANDC\LIB\STARTUP\C0.ASM
;
; This is just BCpp30 __exit with defaults
; (dontexit=1, quick=0)
; Attributes: library function noreturn	bp-based frame

; void __cdecl _exit__1of2(int status)
__exit__1of2 proc far	; CODE XREF: STARTX+2C1p
			; CHUNK_OverlayHalt:loc_13205p

quick= word ptr	 6

push	bp
mov	bp, sp
mov	ax, 1
push	ax		; errcode
xor	ax, ax		; Logical Exclusive OR
push	ax		; dontexit

loc_105DC:		; quick
push	[bp+quick]
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
pop	bp
retf			; Return Far from Procedure
__exit__1of2 endp



; Attributes: library function

; void _cexit(void)
__cexit	proc far	; CODE XREF: __exec+207p
xor	ax, ax		; Logical Exclusive OR
push	ax		; errcode
mov	ax, 1
push	ax		; dontexit
xor	ax, ax		; Logical Exclusive OR
push	ax		; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
retf			; Return Far from Procedure
__cexit	endp



; Attributes: library function

; void _c_exit(void)
__c_exit proc far
mov	ax, 1
push	ax		; errcode
push	ax		; dontexit
xor	ax, ax		; Logical Exclusive OR
push	ax		; quick
call	__exit_2of2	;   arg_0 = 1
			;   arg_2 = 0
			;   arg_4 = 3
retf			; Return Far from Procedure
__c_exit endp

; [00000017 BYTES: COLLAPSED FUNCTION LXMUL@. PRESS KEYPAD "+" TO EXPAND]
; [0000001C BYTES: COLLAPSED FUNCTION SCOPY@. PRESS KEYPAD "+" TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LDIV@. PRESS KEYPAD "+"	TO EXPAND]
; [00000004 BYTES: COLLAPSED FUNCTION LDIV@. PRESS KEYPAD "+" TO EXPAND]
; [00000008 BYTES: COLLAPSED FUNCTION N_LUDIV@.	PRESS KEYPAD "+" TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LMOD@. PRESS KEYPAD "+"	TO EXPAND]
; [0000009C BYTES: COLLAPSED FUNCTION F_LMOD@. PRESS KEYPAD "+"	TO EXPAND]
; [00000003 BYTES: COLLAPSED FUNCTION N_LXLSH@.	PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

LXLSH@ proc far		; CODE XREF: ST_AllocateSpace+10P
			; ST_FarMalloc+DP
			; malloc_s14954+DP
			; LBX_EmsMapMem+B2P
			; LBX_EmsMapMem+C2P
			; LBX_s16F45+49P
			; idk_PreEmmPgCnt+4FP
			; EMS_s17408+4BP
			; idk_VidLib_s1FBBF:loc_1FDCFP
			; idk_VidLib_s1FBBF:loc_1FDEFP
			; idk_VidLib_s1FBBF+26DP
			; idk_VidLib_s1FBBF:loc_1FE54P
			; idk_VidLib_s1FBBF:loc_1FE8DP
			; idk_VidLib_s1FBBF:loc_1FEB4P
			; idk_VidLib_s1FBBF+327P
			; idk_VidLib_s1FBBF+5D3P
			; idk_VidLib_s1FBBF:loc_201BAP
			; idk_VidLib_s1FBBF:loc_201F4P
			; idk_VidLib_s1FBBF+66CP
			; idk_VidLib_s1FBBF:loc_2025FP
			; idk_VidLib_s1FBBF+6D7P
			; idk_VidLib_s1FBBF+6EEP
			; idk_VidLib_s1FBBF+716P
			; idk_VidLib_s1FBBF:loc_2034AP
			; idk_VidLib_s1FBBF:loc_203A0P
			; idk_VidLib_s1FBBF:loc_203EFP
			; idk_VidLib_s1FBBF+87AP
			; sub_21C86+43P
			; sub_467A7+6D9P
cmp	cl, 10h		; Compare Two Operands
jnb	short loc_106F7	; Jump if Not Below (CF=0)
mov	bx, ax
shl	ax, cl		; Shift	Logical	Left
shl	dx, cl		; Shift	Logical	Left
neg	cl		; Two's Complement Negation
add	cl, 10h		; Add
shr	bx, cl		; Shift	Logical	Right
or	dx, bx		; Logical Inclusive OR
retf			; Return Far from Procedure

loc_106F7:		; CODE XREF: LXLSH@+3j
sub	cl, 10h		; Integer Subtraction
xchg	ax, dx		; Exchange Register/Memory with	Register
xor	ax, ax		; Logical Exclusive OR
shl	dx, cl		; Shift	Logical	Left
retf			; Return Far from Procedure
LXLSH@ endp

; [00000003 BYTES: COLLAPSED FUNCTION N_LXURSH@. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION LXURSH@. PRESS KEYPAD "+"	TO EXPAND]
; [00000060 BYTES: COLLAPSED FUNCTION N_PADD@. PRESS KEYPAD "+"	TO EXPAND]


; BORLANDC\CRTL\CLIB\IOERROR.CAS
; /*-----------------------------------------------------------------------*
;
; Name		  __IOerror - set error	variables
;
; Usage		  #include <_io.h>
;		  int  pascal  __IOerror (int dosErr);
;
; Prototype in	  _io.h
;
; Description	  dosErr  is  a	 MSDOS	error  number,	or,  if	negative, the
;		  negative of a	System V error number.
;
;		  __IOerror  sets the  error  number  into  _doserrno. If not
;		  negative then	 translate it into  System V equivalent.  Put
;		  (translated) value into _errno.
;
; Return value	  __IOerror returns -1,	the usual RTL error return.
;
; *------------------------------------------------------------------------*/
; int pascal near __IOerror(int	dosErr)
; {
;	  int	  val =	dosErr;
;
;	  if (val < 0)
;		  goto ser_maybeSVerr;
;
;	  if (val <= e_dosFinalError)
;		  goto ser_dosError;
;
; /*
;   Being defensive, we	must assume that the error routine can be passed
;   a bad argument.  In	such circumstances, complaining	about the
;   parameter seems the	most reasonable	thing to do.
; */
; ser_errorFault:
;	  val =	e_parameter;
;
; ser_dosError:
;	  _doserrno = val;
;
;	  val =	_dosErrorToSV[val];
;	  goto ser_end;
;
; /*
;   This function may be called	with a negated System V	error code when
;   no appropriate MSDOS error code exists.  In	such cases the doserrno
;   is set to non-zero,	but using a number which has no	known cause.
; */
;
; ser_maybeSVerr:
;	  val =	-val;
;	  if (val > _sys_nerr)
;		  goto ser_errorFault;
;
;	  _doserrno = -1;
;
; ser_end:
;	  errno	= val;
;	  return -1;
; }
; Attributes: library function bp-based	frame

__IOERROR proc near	; CODE XREF: __DOSERROR+8p
			; _lseek+23p
			; __read:loc_10B1Bp
			; _unlink+11p
			; __exec+228p
			; _ioctl+22p
			; _setblock+16p
			; __chmod+16p
			; _close+10p
			; __close+19p
			; _eof:loc_11E86p
			; DOS_CreateFileWithHandle+12p
			; _open+41p
			; _open:loc_12718p
			; __open+46p
			; ___read+15p
			; ___write:loc_1305Ap
			; __write:loc_13184p

argErrorCode= word ptr	4

push	bp
mov	bp, sp
push	si
mov	si, [bp+argErrorCode]
or	si, si		; Logical Inclusive OR
jl	short ser_maybeSVerr_1of2 ; Jump if Less (SF!=OF)
cmp	si, e_dosFinalError ; Compare Two Operands
jle	short ser_dosError ; Jump if Less or Equal (ZF=1 | SF!=OF)

ser_errorFault:		; CODE XREF: __IOERROR+25j
mov	si, e_parameter

ser_dosError:		; CODE XREF: __IOERROR+Ej
mov	_doserrno, si
mov	al, _dosErrorToSV[si] ;	val = _dosErrorToSV[val];
cbw			; AL ->	AX (with sign)
mov	si, ax
jmp	short ser_end	; Jump

ser_maybeSVerr_1of2:	; CODE XREF: __IOERROR+9j
neg	si		; Two's Complement Negation
cmp	si, sys_nerr	; Compare Two Operands
jg	short ser_errorFault ; Jump if Greater (ZF=0 & SF=OF)

ser_maybeSVerr_2of2:
mov	_doserrno, -1

ser_end:		; CODE XREF: __IOERROR+1Ej
mov	errno, si
mov	ax, -1
pop	si
pop	bp
retn	2		; Return Near from Procedure
__IOERROR endp

; [00000012 BYTES: COLLAPSED FUNCTION __DOSERROR. PRESS	KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isalnum.	PRESS KEYPAD "+" TO EXPAND]
; [00000013 BYTES: COLLAPSED FUNCTION _isascii.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isalpha.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _iscntrl.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isdigit.	PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION _isgraph.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _islower.	PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION _isprint.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _ispunct.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isspace.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isupper.	PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _isxdigit. PRESS KEYPAD "+" TO EXPAND]
; [00000021 BYTES: COLLAPSED FUNCTION _getc. PRESS KEYPAD "+" TO EXPAND]
; [0000001F BYTES: COLLAPSED FUNCTION _getchar.	PRESS KEYPAD "+" TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _putc. PRESS KEYPAD "+" TO EXPAND]
; [0000002A BYTES: COLLAPSED FUNCTION _putchar.	PRESS KEYPAD "+" TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _feof. PRESS KEYPAD "+" TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _ferror. PRESS KEYPAD "+"	TO EXPAND]


; Attributes: library function bp-based	frame

; int __cdecl isatty(int handle)
_isatty	proc far	; CODE XREF: __setupio+3Bp
			; __setupio+73p
			; __OPENFP+55p

handle=	word ptr  6

push	bp
mov	bp, sp
mov	ax, 4400h
mov	bx, [bp+handle]
int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
xchg	ax, dx		; Exchange Register/Memory with	Register
and	ax, 80h		; Logical AND
pop	bp
retf			; Return Far from Procedure
_isatty	endp

; [0000007D BYTES: COLLAPSED FUNCTION __LONGTOA. PRESS KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION __UTOA. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

; __int32 __cdecl lseek(int handle, __int32 offset, int	fromwhere)
_lseek proc far		; CODE XREF: _fseek+4Dp
			; _ftell+1Bp
			; _ftell+5Ap
			; _ftell+80p
			; _fputc+DBp
			; __FPUTN+8Ep
			; __FPUTN+11Bp
			; ___read+B3p
			; ___write+46p

handle=	word ptr  6
offset=	word ptr  8
arg_4= word ptr	 0Ah
fromwhere= byte	ptr  0Ch

push	bp
mov	bp, sp
mov	bx, [bp+handle]
shl	bx, 1		; Shift	Logical	Left
and	word ptr [bx+51CCh], 0FDFFh ; Logical AND
mov	ah, 42h	; 'B'
mov	al, [bp+fromwhere]
mov	bx, [bp+handle]
mov	cx, [bp+arg_4]
mov	dx, [bp+offset]
int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method:
			; 0-from beginnig,1-from current,2-from	end
jb	short loc_10A32	; Jump if Below	(CF=1)
jmp	short loc_10A37	; Jump

loc_10A32:		; CODE XREF: _lseek+1Ej
push	ax
call	__IOERROR	; Call Procedure
cwd			; AX ->	DX:AX (with sign)

loc_10A37:		; CODE XREF: _lseek+20j
pop	bp
retf			; Return Far from Procedure
_lseek endp

; [0000003F BYTES: COLLAPSED FUNCTION __MKNAME.	PRESS KEYPAD "+" TO EXPAND]
; [00000043 BYTES: COLLAPSED FUNCTION __TMPNAM.	PRESS KEYPAD "+" TO EXPAND]
; [00000017 BYTES: COLLAPSED FUNCTION N_LXMUL@.	PRESS KEYPAD "+" TO EXPAND]
; [00000021 BYTES: COLLAPSED FUNCTION N_PCMP@. PRESS KEYPAD "+"	TO EXPAND]
; [0000002D BYTES: COLLAPSED FUNCTION __read. PRESS KEYPAD "+" TO EXPAND]
; [00000026 BYTES: COLLAPSED FUNCTION fncCopyToUpperCase. PRESS	KEYPAD "+" TO EXPAND]


; DOS -	2+ - GET CURRENT DIRECTORY
;   DL = drive (0=default, 1=A,	etc.)
;   DS:SI points to 64-byte buffer area
; -
;   mov	    dl,	[bp+arg_2]
;   mov	    si,	[bp+arg_0]
; Attributes: library function bp-based	frame

DOS_GetCurrDir proc far	; CODE XREF: sub_10B5F+4Ep

arg_0= word ptr	 6
arg_2= byte ptr	 8

push	bp
mov	bp, sp
push	si
mov	ah, 47h
mov	dl, [bp+arg_2]
mov	si, [bp+arg_0]
int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default, 1=A, etc.)
			; DS:SI	points to 64-byte buffer area
jb	short loc_10B5A	; Jump if Below	(CF=1)
xor	ax, ax		; Logical Exclusive OR
jmp	short $+2	; Jump

loc_10B5A:		; CODE XREF: DOS_GetCurrDir+Ej
pop	si
pop	bp
retf	4		; Return Far from Procedure
DOS_GetCurrDir endp



;   arg_0 =
;   arg_2 =
;   src	  =
;   arg_8 =
;   path  =
; -
;   push    di
;   mov	    ax,	0A9F1h
;   push    ax		    ; int
;   mov	    ax,	0A9AEh
;   push    ax		    ; int
;   mov	    ax,	0A9A4h
;   push    ax		    ; int
;   mov	    ax,	0A99Eh	    ; int
;   push    ax
;   push    word ptr [bp+path+2] ; path
; Attributes: library function bp-based	frame

; int __fastcall sub_10B5F(int,	int, int, int, int, int, int, int, char	*path)
sub_10B5F proc near	; CODE XREF: sub_10C20+91p
			; sub_10C20+BDp
			; sub_10C20+E2p

attrib=	word ptr -2Eh
drive= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
src= dword ptr	8
arg_8= word ptr	 0Ch
path= dword ptr	 0Eh

push	bp
mov	bp, sp
sub	sp, 2Eh		; dst
push	si
push	di		; dst
mov	dx, [bp+arg_8]
mov	di, word ptr [bp+src+2]
mov	si, word ptr [bp+path]
mov	bx, dx
cmp	byte ptr [bx], 0 ; If ([BX] == 0) Then Set (ZF = 1)
jnz	short Arg8_ZERO	; Jump if Not Zero (ZF=0)
lea	ax, [bp+drive]	; Load Effective Address
push	ax		; drive
nop			; No Operation
push	cs
call	near ptr __dos_getdrive	;   mov	    si,	[bp+drive]
			;   mov	    ah,	19h	  ; DOS	- GET DEFAULT DISK NUMBER
			;   int	    21h
			;   mov	    ah,	0
			;   inc	    ax
			;   mov	    [si], ax
pop	cx
jmp	short loc_10B8E	; Jump

Arg8_ZERO:		; CODE XREF: sub_10B5F+16j
mov	bx, dx
mov	al, [bx]
cbw			; AL ->	AX (with sign)
and	ax, 11111b	; Logical AND
mov	[bp+drive], ax

loc_10B8E:		; CODE XREF: sub_10B5F+22j
mov	al, byte ptr [bp+drive]
add	al, 64		; Convert Drive	Number to Drive	Letter
mov	[si], al
inc	si		; Increment by 1
mov	byte ptr [si], ':'
inc	si		; Increment by 1
cmp	byte ptr [di], '\' ; Compare Two Operands
jz	short loc_10BCC	; Jump if Zero (ZF=1)
cmp	byte ptr [di], '/' ; Compare Two Operands
jz	short loc_10BCC	; Jump if Zero (ZF=1)
mov	byte ptr [si], 5Ch ; '\'
inc	si		; Increment by 1
push	[bp+drive]
push	si
push	cs
call	near ptr DOS_GetCurrDir	; DOS -	2+ - GET CURRENT DIRECTORY
			;   DL = drive (0=default, 1=A,	etc.)
			;   DS:SI points to 64-byte buffer area
			; -
			;   mov	    dl,	[bp+arg_2]
			;   mov	    si,	[bp+arg_0]
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jz	short loc_10BB9	; Jump if Zero (ZF=1)
mov	ax, 3
jmp	short loc_10C18	; Jump

loc_10BB9:		; CODE XREF: sub_10B5F+53j
push	si		; s
nop			; No Operation
push	cs
call	near ptr _strlen ; Call	Procedure
pop	cx
mov	dx, ax
or	dx, dx		; Logical Inclusive OR
jz	short loc_10BCC	; Jump if Zero (ZF=1)
add	si, dx		; Add
mov	byte ptr [si], 5Ch ; '\'
inc	si		; Increment by 1

loc_10BCC:		; CODE XREF: sub_10B5F+3Ej
			; sub_10B5F+43j
			; sub_10B5F+65j
push	si		; dst
push	di		; src
call	fncCopyToUpperCase ; Call Procedure
mov	si, ax
cmp	byte ptr [si-1], 5Ch ; '\' ; Compare Two Operands
jz	short loc_10BE3	; Jump if Zero (ZF=1)
cmp	byte ptr [si-1], 2Fh ; '/' ; Compare Two Operands
jz	short loc_10BE3	; Jump if Zero (ZF=1)
mov	byte ptr [si], 5Ch ; '\'
inc	si		; Increment by 1

loc_10BE3:		; CODE XREF: sub_10B5F+78j
			; sub_10B5F+7Ej
push	si		; dst
push	word ptr [bp+src] ; src
call	fncCopyToUpperCase ; Call Procedure
mov	si, ax
cmp	[bp+arg_2], 0	; Compare Two Operands
jz	short loc_10BF9	; Jump if Zero (ZF=1)
push	ax		; dst
push	[bp+arg_2]	; src
call	fncCopyToUpperCase ; Call Procedure

loc_10BF9:		; CODE XREF: sub_10B5F+91j
lea	ax, [bp+attrib]	; Load Effective Address
push	ax		; attrib
test	[bp+arg_0], 2	; Logical Compare
jz	short loc_10C09	; Jump if Zero (ZF=1)
mov	ax, 27h	; '''
jmp	short loc_10C0C	; Jump

loc_10C09:		; CODE XREF: sub_10B5F+A3j
mov	ax, 37h	; '7'

loc_10C0C:		; CODE XREF: sub_10B5F+A8j
push	ax
push	word ptr [bp+path] ; path
nop			; No Operation
push	cs
call	near ptr __dos_findfirst ; Call	Procedure
add	sp, 6		; Add

loc_10C18:		; CODE XREF: sub_10B5F+58j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	0Ch		; Return Near from Procedure
sub_10B5F endp ; sp-analysis failed

; [0000015E BYTES: COLLAPSED FUNCTION sub_10C20. PRESS KEYPAD "+" TO EXPAND]
; [00000014 BYTES: COLLAPSED FUNCTION __SEARCHPATH. PRESS KEYPAD "+" TO	EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __searchenv. PRESS KEYPAD	"+" TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION __searchstr. PRESS KEYPAD	"+" TO EXPAND]


; Attributes: library function

__setupio proc near
mov	dx, 5
cmp	dx, __nfile	; Compare Two Operands
jnb	short loc_10E2C	; Jump if Not Below (CF=0)

loc_10E01:		; CODE XREF: __setupio+32j
mov	bx, dx
shl	bx, 1		; Shift	Logical	Left

loc_10E05:
mov	word ptr [bx+51CCh], 0
mov	bx, dx
mov	cl, 4
shl	bx, cl		; Shift	Logical	Left
mov	byte ptr [bx+508Eh], 0FFh
mov	ax, dx
shl	ax, cl		; Shift	Logical	Left
add	ax, 508Ah	; Add
mov	bx, dx
shl	bx, cl		; Shift	Logical	Left
mov	[bx+5098h], ax
inc	dx		; Increment by 1
cmp	dx, __nfile	; Compare Two Operands
jb	short loc_10E01	; Jump if Below	(CF=1)

loc_10E2C:		; CODE XREF: __setupio+7j
mov	al, byte_36D9E
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_10E41	; Jump if Not Zero (ZF=0)
and	word_36D9C, 0FDFFh ; Logical AND

loc_10E41:		; CODE XREF: __setupio+41j
mov	ax, 200h
push	ax
test	word_36D9C, 200h ; Logical Compare
jz	short loc_10E52	; Jump if Zero (ZF=1)
mov	ax, 1
jmp	short loc_10E54	; Jump

loc_10E52:		; CODE XREF: __setupio+53j
xor	ax, ax		; Logical Exclusive OR

loc_10E54:		; CODE XREF: __setupio+58j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 508Ah
push	ax		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
mov	al, byte_36DAE
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short loc_10E79	; Jump if Not Zero (ZF=0)
and	word_36DAC, 0FDFFh ; Logical AND

loc_10E79:		; CODE XREF: __setupio+79j
mov	ax, 200h
push	ax
test	word_36DAC, 200h ; Logical Compare
jz	short loc_10E8A	; Jump if Zero (ZF=1)
mov	ax, 2
jmp	short loc_10E8C	; Jump

loc_10E8A:		; CODE XREF: __setupio+8Bj
xor	ax, ax		; Logical Exclusive OR

loc_10E8C:		; CODE XREF: __setupio+90j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
mov	ax, 509Ah
push	ax		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
retn			; Return Near from Procedure
__setupio endp ; sp-analysis failed



; Attributes: bp-based frame

idk_ctype_s10E9D proc far
			; CODE XREF: idk_Env_BLASTER_s3095D+B2P

arg_0= word ptr	 6

push	bp
mov	bp, sp
mov	dx, [bp+arg_0]
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_10EAD	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
jmp	short loc_10EC7	; Jump

loc_10EAD:		; CODE XREF: idk_ctype_s10E9D+9j
mov	al, dl
mov	ah, 0
mov	bx, ax
test	(__ctype+1)[bx], 8 ; .\BORLAND\CTRL\CLIB\CTYPE.C
			; Usage
			; char _ctype[257];
			; Description
			; _ctype is an array of	257 characters used by the character
			; classification and character conversion macros
			; (such	as isalpha and toascii).
jz	short loc_10EC3	; Jump if Zero (ZF=1)
mov	al, dl
mov	ah, 0
add	ax, 0FFE0h	; Add
jmp	short loc_10EC7	; Jump

loc_10EC3:		; CODE XREF: idk_ctype_s10E9D+1Bj
mov	al, dl
mov	ah, 0

loc_10EC7:		; CODE XREF: idk_ctype_s10E9D+Ej
			; idk_ctype_s10E9D+24j
pop	bp
retf			; Return Far from Procedure
idk_ctype_s10E9D endp

; [00000016 BYTES: COLLAPSED FUNCTION _unlink. PRESS KEYPAD "+"	TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _stpcpy. PRESS KEYPAD "+"	TO EXPAND]
; [00000022 BYTES: COLLAPSED FUNCTION ___brk. PRESS KEYPAD "+" TO EXPAND]


; BORLANDC\CRTL\CLIB\BRK.CAS
; /*--------------------------------------------------------------------------*
;
; Name		  __sbrk - changes data-segment	space allocation on the
;			 near heap
;
; Usage		  void *__sbrk(long incr);
;
; Prototype in	  alloc.h
;
; Description	  sbrk adds incr bytes to the break value and changes the
;		  allocated space accordingly. incr can	be negative, in
;		  which	case the amount	of allocated space is decreased.
;
; Return value	  success : the	old break value
;		  failure : -1 and errno set to	ENOMEM (Not enough core)
;
; *---------------------------------------------------------------------------*/
; void * near __sbrk(long incr)
; {
; asm	  mov	  ax, W0(incr)
; asm	  mov	  dx, W1(incr)
; asm	  add	  ax, word ptr __brklvl
; asm	  adc	  dx, 0
; asm	  mov	  cx, ax
; asm	  or	  dx, dx
; asm	  jnz	  sbrkErr
;
; asm	  add	  cx, MARGIN
; asm	  jc	  sbrkErr
; asm	  cmp	  cx, sp
; asm	  jnb	  sbrkErr
;
; asm	  xchg	  word ptr __brklvl, ax
;	  return (void *)_AX;
; sbrkErr:
;	  errno	= ENOMEM;
;	  return((void *)-1);
; }
;
; Attributes: library function bp-based	frame

; void *__cdecl	__sbrk(__int32 incr)
___sbrk	proc near	; CODE XREF: _sbrk+9p
			; LibMalloc_s11A85+5p
			; LibMalloc_s11A85+13p
			; LibMalloc_s11A85+1Ep
			; LibMalloc_s11AC5+5p

incr= dword ptr	 4

push	bp
mov	bp, sp
mov	ax, word ptr [bp+incr]
mov	dx, word ptr [bp+incr+2]
add	ax, __brklvl	; Add
adc	dx, 0		; Add with Carry
mov	cx, ax
or	dx, dx		; Logical Inclusive OR
jnz	short loc_10F50	; Jump if Not Zero (ZF=0)
add	cx, 200h	; Add
jb	short loc_10F50	; Jump if Below	(CF=1)
cmp	cx, sp		; Compare Two Operands
jnb	short loc_10F50	; Jump if Not Below (CF=0)
xchg	ax, __brklvl	; Exchange Register/Memory with	Register
jmp	short loc_10F59	; Jump

loc_10F50:		; CODE XREF: ___sbrk+14j
			; ___sbrk+1Aj
			; ___sbrk+1Ej
mov	errno, 8
mov	ax, 0FFFFh

loc_10F59:		; CODE XREF: ___sbrk+24j
pop	bp
retn			; Return Near from Procedure
___sbrk	endp

; [0000000C BYTES: COLLAPSED FUNCTION _brk. PRESS KEYPAD "+" TO	EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _sbrk. PRESS KEYPAD "+" TO EXPAND]


; returns the amount of	available heap
; tiny,small,medium sized memory modal:	unsigned int
; compact,large,huge sized memory model: unsigned long
; Attributes: library function

; unsigned __int32 coreleft(void)
_coreleft proc far	; CODE XREF: ST_ExitWithMemDiag+15P
mov	ax, sp
sub	ax, __brklvl	; Integer Subtraction
sub	ax, 220h	; Integer Subtraction
jnb	short loc_10F84	; Jump if Not Below (CF=0)
xor	ax, ax		; Logical Exclusive OR

loc_10F84:		; CODE XREF: _coreleft+9j
and	al, 11110000b	; Logical AND
retf			; Return Far from Procedure
_coreleft endp

LoaderDatas BCpp30_LdDesc <0>
			; DATA XREF: __exec+F7o
			; __exec+1CBo
db  33h	; 3
db 0FFh
db  8Ch	; Œ
db 0C8h	; È
db  8Eh	; Ž
db 0D8h	; Ø
db  8Eh	; Ž
db 0C0h	; À
db 0FAh	; ú
db  8Eh	; Ž
db 0D0h	; Ð
db  8Dh	; 
db 0A5h	; ¥
db  8Fh	; 
db    0
db 0FBh	; û
db  51h	; Q
db  52h	; R
db 0B8h	; ¸
db    3
db  4Bh	; K
db  8Dh	; 
db  9Dh	; 
db 0FBh	; û
db    0
db  8Dh	; 
db  95h	; •
db  91h	; ‘
db    0
db 0CDh	; Í
db  21h	; !
db  5Ah	; Z
db  59h	; Y
db  72h	; r
db  2Dh	; -
db  33h	; 3
db 0FFh
db 0FAh	; ú
db  8Eh	; Ž
db  95h	; •
db 0F1h	; ñ
db    0
db  8Bh	; ‹
db 0A5h	; ¥
db 0F3h	; ó
db    0
db 0FBh	; û
db  8Bh	; ‹
db 0ECh	; ì
db  33h	; 3
db 0C0h	; À
db  50h	; P
db  8Bh	; ‹
db  85h	; …
db  8Fh	; 
db    0
db  8Eh	; Ž
db 0D8h	; Ø
db  8Eh	; Ž
db 0C0h	; À
db  26h	; &
db  89h	; ‰
db  16h
db    2
db    0
db  26h	; &
db  89h	; ‰
db  0Eh
db  2Ch	; ,
db    0
db  2Eh	; .
db  8Bh	; ‹
db  85h	; …
db 0E1h	; á
db    0
db  2Eh	; .
db 0FFh
db  2Eh	; .
db 0F7h	; ÷
db    0
db 0B4h	; ´
db  40h	; @
db 0BBh	; »
db    2
db    0
db 0B9h	; ¹
db  0Fh
db    0
db  33h	; 3
db 0D2h	; Ò
db 0CDh	; Í
db  21h	; !
db 0B8h	; ¸
db    2
db  4Ch	; L
db 0CDh	; Í
db  21h	; !
LoaderVector dd	0FFh	; DATA XREF: __exec+21Er
			; __exec+1C1w
			; .\BORLANDC\CRTL\CLIB\EXEC.ASM:
			; LoaderVector	  dd	  _Loader - LoaderDatas
OldEnvSave dw 0		; DATA XREF: __exec+Ew
			; __exec:ReUseEnvr
			; __exec:CopyEnv_2of2r
byte_110ED db 1		; DATA XREF: __exec:SetEnvSize_2of2w
			; __exec+1D8r
			; __exec:loc_112FAr
; [0000022F BYTES: COLLAPSED FUNCTION __exec. PRESS KEYPAD "+" TO EXPAND]
; [0000001A BYTES: COLLAPSED FUNCTION _execl. PRESS KEYPAD "+" TO EXPAND]
LibMalloc____first dw 0	; DATA XREF: LibMalloc_s11343r
			; LibMalloc_s11343+1Dr
			; LibMalloc_s11343:loc_1137Cr
			; LibMalloc_s11343:loc_11381w
			; sub_113A6+11r
			; LibMalloc_s114A0+48w
			; _farmalloc+2Cr
___last	dw 0		; DATA XREF: LibMalloc_s11343+14w
			; LibMalloc_s11343+27w
			; LibMalloc_s11343+45w
			; _farfree+11r
			; LibMalloc_s114A0+4Dw
			; LibMalloc_s11504:loc_11527r
			; LibMalloc_s11504+28w
			; idk_FarFreeOrBrkr
LibMalloc____rover dw 0	; DATA XREF: LibMalloc_s11343+4Cw
			; LibMalloc_s11417+19w
			; LibMalloc_s11417:loc_11438w
			; sub_11440r
			; sub_11440:loc_11469w
			; _farmalloc+35r
LibMalloc_w1133D dw 0	; DATA XREF: LibMalloc_s11343+32r
			; LibMalloc_s11343:loc_11396r
			; _farfree+5w
			; _farfree:loc_11497r
			; LibMalloc_s114A0+1r
			; LibMalloc_s114A0+1Cr
			; LibMalloc_s114A0+35r
			; LibMalloc_s11504+Br
			; _farmalloc+Fw
			; _farmalloc:loc_115F5r
			; LibMalloc_FarReAlloc_s115FE:loc_11669r
			; _farrealloc+Ew
			; _farrealloc:loc_1174Fr
LibMalloc_FarReAlloc_w1133F dw 0
			; DATA XREF: LibMalloc_FarReAlloc_s115FE+1r
			; _farrealloc+13w
; unsigned __int32 nbytes
nbytes dw 0		; DATA XREF: LibMalloc_FarReAlloc_s115FE+7r
			; _farrealloc+18w


; Attributes: library function

LibMalloc_s11343 proc near ; CODE XREF:	_farfree+18p
cmp	dx, cs:LibMalloc____first ; Compare Two	Operands
jz	short loc_11381	; Jump if Zero (ZF=1)
mov	ds, dx
mov	ds, LibMalloc_w31D12
cmp	LibMalloc_w31D12, 0 ; Compare Two Operands
jz	short loc_1135E	; Jump if Zero (ZF=1)
mov	cs:___last, ds
jmp	short loc_11396	; Jump

loc_1135E:		; CODE XREF: LibMalloc_s11343+12j
mov	ax, ds
cmp	ax, cs:LibMalloc____first ; Compare Two	Operands
jz	short loc_1137C	; Jump if Zero (ZF=1)
mov	ax, LibMalloc_w31D18
mov	cs:___last, ax
push	ds
xor	ax, ax		; Logical Exclusive OR
push	ax
call	LibMalloc_s11417 ; Call	Procedure
mov	ds, cs:LibMalloc_w1133D
jmp	short loc_1139F	; Jump

loc_1137C:		; CODE XREF: LibMalloc_s11343+22j
mov	dx, cs:LibMalloc____first

loc_11381:		; CODE XREF: LibMalloc_s11343+5j
mov	cs:LibMalloc____first, 0
mov	cs:___last, 0
mov	cs:LibMalloc____rover, 0

loc_11396:		; CODE XREF: LibMalloc_s11343+19j
mov	ds, cs:LibMalloc_w1133D
push	dx
xor	ax, ax		; Logical Exclusive OR
push	ax		; addr

loc_1139F:		; CODE XREF: LibMalloc_s11343+37j
call	__brk		; Call Procedure
add	sp, 4		; Add
retn			; Return Near from Procedure
LibMalloc_s11343 endp

; [00000071 BYTES: COLLAPSED FUNCTION sub_113A6. PRESS KEYPAD "+" TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION LibMalloc_s11417.	PRESS KEYPAD "+" TO EXPAND]
; [00000037 BYTES: COLLAPSED FUNCTION sub_11440. PRESS KEYPAD "+" TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _farfree.	PRESS KEYPAD "+" TO EXPAND]
; [00000064 BYTES: COLLAPSED FUNCTION LibMalloc_s114A0.	PRESS KEYPAD "+" TO EXPAND]
; [0000005A BYTES: COLLAPSED FUNCTION LibMalloc_s11504.	PRESS KEYPAD "+" TO EXPAND]
; [00000023 BYTES: COLLAPSED FUNCTION LibMalloc_s1155E.	PRESS KEYPAD "+" TO EXPAND]


; ;-----------------------------------------------------------------------------
; ; C callable function	to allocates a given number of bytes from the far heap
; ;-----------------------------------------------------------------------------
; ; Args:		  Number of bytes requested (long, stack)
; ; Returns:		  Address of the first byte of user space available
; ;			  from the heap	if successful (dx:ax)
; ;			  NULL if failure (ds:ax)
; ;-----------------------------------------------------------------------------
;
;
; void far *__cdecl farmalloc(unsigned __int32 nbytes);
; Return:
; DX:AX
; -address of allocate space on	far heap
; -NULL	if failure (DX = AX = 0)
;
; Attributes: library function bp-based	frame

; void far *__cdecl farmalloc(unsigned __int32 nbytes)
_farmalloc proc	far	; CODE XREF: LibMalloc_FarReAlloc_s115FE+Ep
			; _farrealloc+5Dp
			; ST_AllocateSpace+1DP
			; ST_FarMalloc+1AP
			; malloc_s14954+1AP
			; __OvrPrepare+32P

nbytes=	dword ptr  6

push	bp
mov	bp, sp
mov	dx, word ptr [bp+nbytes+2]
mov	ax, word ptr [bp+nbytes]
mov	cx, ax
or	cx, dx		; Logical Inclusive OR
push	si
push	di
mov	cs:LibMalloc_w1133D, ds
jz	short loc_115F5	; Jump if Zero (ZF=1)
add	ax, 19		; Add
adc	dx, 0		; Add with Carry
jb	short loc_115E0	; Jump if Below	(CF=1)
test	dx, 1111111111110000b ;	Logical	Compare
jnz	short loc_115E0	; Jump if Not Zero (ZF=0)
mov	cl, 4
shr	ax, cl		; / 16
shl	dx, cl		; * 16
or	ah, dl		; Logical Inclusive OR
mov	dx, cs:LibMalloc____first
or	dx, dx		; Logical Inclusive OR
jz	short loc_115D6	; Jump if Zero (ZF=1)
mov	dx, cs:LibMalloc____rover
or	dx, dx		; Logical Inclusive OR
jz	short loc_115D1	; Jump if Zero (ZF=1)
mov	bx, dx

loc_115C1:		; CODE XREF: _farmalloc+4Ej
mov	ds, dx
cmp	LibMalloc_w31D10, ax ; Compare Two Operands
jnb	short loc_115E5	; Jump if Not Below (CF=0)
mov	dx, LibMalloc_w31D16
cmp	dx, bx		; Compare Two Operands
jnz	short loc_115C1	; Jump if Not Zero (ZF=0)

loc_115D1:		; CODE XREF: _farmalloc+3Cj
call	LibMalloc_s11504 ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115D6:		; CODE XREF: _farmalloc+33j
call	LibMalloc_s114A0 ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115DB:		; CODE XREF: _farmalloc:loc_115E5j
call	LibMalloc_s1155E ; Call	Procedure
jmp	short loc_115F5	; Jump

loc_115E0:		; CODE XREF: _farmalloc+1Cj
			; _farmalloc+22j
xor	ax, ax		; Logical Exclusive OR
cwd			; AX ->	DX:AX (with sign)
jmp	short loc_115F5	; Jump

loc_115E5:		; CODE XREF: _farmalloc+46j
ja	short loc_115DB	; Jump if Above	(CF=0 &	ZF=0)
call	LibMalloc_s11417 ; Call	Procedure
mov	bx, LibMalloc_w31D18
mov	LibMalloc_w31D12, bx
mov	ax, offset LibMalloc_w31D14

loc_115F5:		; CODE XREF: _farmalloc+14j
			; _farmalloc+53j
			; _farmalloc+58j
			; _farmalloc+5Dj
			; _farmalloc+62j
mov	ds, cs:LibMalloc_w1133D
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
_farmalloc endp

; [0000007C BYTES: COLLAPSED FUNCTION LibMalloc_FarReAlloc_s115FE. PRESS KEYPAD	"+" TO EXPAND]
; [00000064 BYTES: COLLAPSED FUNCTION idk_FarFreeOrBrk.	PRESS KEYPAD "+" TO EXPAND]
; [0000007A BYTES: COLLAPSED FUNCTION _farrealloc. PRESS KEYPAD	"+" TO EXPAND]


; Attributes: library function bp-based	frame

; int __stdcall	idk_InBrkSbrk(void *addr)
idk_InBrkSbrk proc near	; CODE XREF: __brk+2Fp
			; __sbrk+7Ap

addr= dword ptr	 4

push	bp
mov	bp, sp
push	si
mov	si, word ptr [bp+addr+2]
inc	si		; Increment by 1
sub	si, _psp@	; Integer Subtraction
add	si, 63		; Add
mov	cl, 6
shr	si, cl		; SI = SI * 64
cmp	si, SegX_w36F82	; Compare Two Operands
jnz	short loc_11783	; Jump if Not Zero (ZF=0)

loc_11771:		; CODE XREF: idk_InBrkSbrk+5Fj
mov	ax, word ptr [bp+addr+2]
mov	dx, word ptr [bp+addr]
mov	word ptr _brklvl@+2, ax
mov	word ptr _brklvl@, dx
mov	ax, 1
jmp	short loc_117C9	; Jump

loc_11783:		; CODE XREF: idk_InBrkSbrk+17j
mov	cl, 6
shl	si, cl		; Shift	Logical	Left
mov	dx, word ptr _heaptop@+2
mov	ax, si
add	ax, _psp@	; Add
cmp	ax, dx		; Compare Two Operands
jbe	short loc_1179B	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	si, dx
sub	si, _psp@	; Integer Subtraction

loc_1179B:		; CODE XREF: idk_InBrkSbrk+3Bj
push	si		; newsize
push	_psp@		; segx
nop			; No Operation
push	cs
call	near ptr _setblock ; Call Procedure
pop	cx
pop	cx
mov	dx, ax
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_117B9	; Jump if Not Zero (ZF=0)
mov	ax, si
mov	cl, 6
shr	ax, cl		; Shift	Logical	Right
mov	SegX_w36F82, ax
jmp	short loc_11771	; Jump

loc_117B9:		; CODE XREF: idk_InBrkSbrk+54j
mov	ax, _psp@
add	ax, dx		; Add
mov	word ptr _heaptop@+2, ax
mov	word ptr _heaptop@, 0
xor	ax, ax		; Logical Exclusive OR

loc_117C9:		; CODE XREF: idk_InBrkSbrk+29j
pop	si
pop	bp
retn	4		; Return Near from Procedure
idk_InBrkSbrk endp ; sp-analysis failed



; BORLANDC\CRTL\CLIB\BRK.CAS
; /*---------------------------------------------------------------------------
;  * filename -	brk.cas
;  *
;  * function(s)
;  *	    brk	   - memory model dependent hook to _brk or __brk
;  *	    sbrk   - memory model dependent hook to _sbrk or __sbrk
;  *	    __brk  - changes data-segment space	allocation on the near heap
;  *	    __sbrk - changes data-segment space	allocation on the near heap
;  *--------------------------------------------------------------------------*/
; /*--------------------------------------------------------------------------*
;    In	the large data models brk and sbrk are hooks to	_brk and
;    _sbrk respectively.  _brk and _sbrk work with the far heap.
;    _brk and _sbrk are	found in fbrk.c
; *---------------------------------------------------------------------------*/
;
; Attributes: library function bp-based	frame

; int __cdecl _brk(void	*addr)
__brk proc near		; CODE XREF: LibMalloc_s11343:loc_1139Fp
			; idk_FarFreeOrBrk+59p

addr= dword ptr	 4

push	bp
mov	bp, sp
mov	cx, word ptr _heapbase@+2
mov	bx, word ptr _heapbase@
mov	dx, word ptr [bp+addr+2]
mov	ax, word ptr [bp+addr]
call	N_PCMP@		; Call Procedure
jb	short loc_11804	; Jump if Below	(CF=1)
mov	cx, word ptr _heaptop@+2
mov	bx, word ptr _heaptop@
mov	dx, word ptr [bp+addr+2]
mov	ax, word ptr [bp+addr]
call	N_PCMP@		; Call Procedure
ja	short loc_11804	; Jump if Above	(CF=0 &	ZF=0)
push	word ptr [bp+addr+2]
push	word ptr [bp+addr] ; addr
call	idk_InBrkSbrk	; Call Procedure
or	ax, ax		; Logical Inclusive OR
jnz	short loc_11809	; Jump if Not Zero (ZF=0)

loc_11804:		; CODE XREF: __brk+14j
			; __brk+27j
mov	ax, -1
jmp	short loc_1180B	; Jump

loc_11809:		; CODE XREF: __brk+34j
xor	ax, ax		; Logical Exclusive OR

loc_1180B:		; CODE XREF: __brk+39j
pop	bp
retn			; Return Near from Procedure
__brk endp

; [0000008B BYTES: COLLAPSED FUNCTION __sbrk. PRESS KEYPAD "+" TO EXPAND]
; [00000027 BYTES: COLLAPSED FUNCTION _ioctl. PRESS KEYPAD "+" TO EXPAND]
; [00000097 BYTES: COLLAPSED FUNCTION __LoadProg. PRESS	KEYPAD "+" TO EXPAND]
; [0000001D BYTES: COLLAPSED FUNCTION _free. PRESS KEYPAD "+" TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION sub_11973. PRESS KEYPAD "+" TO EXPAND]
; [00000039 BYTES: COLLAPSED FUNCTION sub_119AD. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

LibMalloc_s119E6 proc near
			; CODE XREF: sub_11973+1Cp
			; _malloc+53p
mov	di, [bx+6]
cmp	bx, di		; Compare Two Operands
jz	short loc_119FB	; Jump if Zero (ZF=1)
mov	LibMalloc_w36F88, di
mov	si, [bx+4]
mov	[di+4],	si
mov	[si+6],	di
retn			; Return Near from Procedure

loc_119FB:		; CODE XREF: LibMalloc_s119E6+5j
mov	LibMalloc_w36F88, 0
retn			; Return Near from Procedure
LibMalloc_s119E6 endp

; [00000023 BYTES: COLLAPSED FUNCTION sub_11A02. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function

; void *__cdecl	malloc(size_t size)
_malloc	proc far	; CODE XREF: __DOSCMD+53p
			; __DOSENV+5Ap
			; sub_11B07+7p
			; _realloc+42p
			; unknown_libname_2+9p
			; unknown_libname_2+29p
			; _setvbuf+A5p

size= word ptr	8

push	si
push	di
mov	si, sp
mov	ax, [si+8]
or	ax, ax		; Logical Inclusive OR
jz	short loc_11A82	; Jump if Zero (ZF=1)
add	ax, 5		; Add
jb	short loc_11A6B	; Jump if Below	(CF=1)
and	ax, 1111111111111110b ;	Logical	AND
cmp	ax, 8		; Compare Two Operands
jnb	short loc_11A40	; Jump if Not Below (CF=0)
mov	ax, 8

loc_11A40:		; CODE XREF: _malloc+16j
cmp	LibMalloc_w36F84, 0 ; Compare Two Operands
jz	short loc_11A66	; Jump if Zero (ZF=1)
mov	bx, LibMalloc_w36F88
or	bx, bx		; Logical Inclusive OR
jz	short loc_11A5C	; Jump if Zero (ZF=1)
mov	dx, bx

loc_11A51:		; CODE XREF: _malloc+35j
cmp	[bx], ax	; Compare Two Operands
jnb	short loc_11A6F	; Jump if Not Below (CF=0)
mov	bx, [bx+6]
cmp	bx, dx		; Compare Two Operands
jnz	short loc_11A51	; Jump if Not Zero (ZF=0)

loc_11A5C:		; CODE XREF: _malloc+28j
call	LibMalloc_s11AC5 ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A61:		; CODE XREF: _malloc+51j
call	LibMalloc_s11AEE ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A66:		; CODE XREF: _malloc+20j
call	LibMalloc_s11A85 ; Call	Procedure
jmp	short loc_11A82	; Jump

loc_11A6B:		; CODE XREF: _malloc+Ej
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_11A82	; Jump

loc_11A6F:		; CODE XREF: _malloc+2Ej
mov	si, ax
add	si, 8		; Add
cmp	[bx], si	; Compare Two Operands
jnb	short loc_11A61	; Jump if Not Below (CF=0)
call	LibMalloc_s119E6 ; Call	Procedure
inc	word ptr [bx]	; Increment by 1
mov	ax, bx
add	ax, 4		; Add

loc_11A82:		; CODE XREF: _malloc+9j
			; _malloc+3Aj
			; _malloc+3Fj
			; _malloc+44j
			; _malloc+48j
pop	di
pop	si
retf			; Return Far from Procedure
_malloc	endp



; Attributes: library function

LibMalloc_s11A85 proc near
			; CODE XREF: _malloc:loc_11A66p
push	ax
xor	ax, ax		; Logical Exclusive OR
push	ax
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
and	ax, 1		; Logical AND
jz	short loc_11A9D	; Jump if Zero (ZF=1)
xor	dx, dx		; Logical Exclusive OR
push	dx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx

loc_11A9D:		; CODE XREF: LibMalloc_s11A85+Dj
pop	ax
push	ax
xor	bx, bx		; Logical Exclusive OR
push	bx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_11AC1	; Jump if Zero (ZF=1)
mov	bx, ax
mov	LibMalloc_w36F84, bx
mov	word_36F86, bx
pop	ax
inc	ax		; Increment by 1
mov	[bx], ax
add	bx, 4		; Add
mov	ax, bx
retn			; Return Near from Procedure

loc_11AC1:		; CODE XREF: LibMalloc_s11A85+26j
pop	bx
xor	ax, ax		; Logical Exclusive OR
retn			; Return Near from Procedure
LibMalloc_s11A85 endp



; Attributes: library function

LibMalloc_s11AC5 proc near
			; CODE XREF: _malloc:loc_11A5Cp
push	ax
xor	bx, bx		; Logical Exclusive OR
push	bx
push	ax		; incr
call	___sbrk		; Call Procedure
pop	bx
pop	bx
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_11AEA	; Jump if Zero (ZF=1)
mov	bx, ax
mov	ax, word_36F86
mov	[bx+2],	ax
mov	word_36F86, bx
pop	ax
inc	ax		; Increment by 1
mov	[bx], ax
add	bx, 4		; Add
mov	ax, bx
retn			; Return Near from Procedure

loc_11AEA:		; CODE XREF: LibMalloc_s11AC5+Dj
pop	ax
xor	ax, ax		; Logical Exclusive OR
retn			; Return Near from Procedure
LibMalloc_s11AC5 endp



; Attributes: library function

LibMalloc_s11AEE proc near
			; CODE XREF: _malloc:loc_11A61p
sub	[bx], ax	; Integer Subtraction
mov	si, bx
add	si, [bx]	; Add
mov	di, si
add	di, ax		; Add
inc	ax		; Increment by 1
mov	[si], ax
mov	[si+2],	bx
mov	[di+2],	si
add	si, 4		; Add
mov	ax, si
retn			; Return Near from Procedure
LibMalloc_s11AEE endp

; [00000035 BYTES: COLLAPSED FUNCTION sub_11B07. PRESS KEYPAD "+" TO EXPAND]
; [00000042 BYTES: COLLAPSED FUNCTION sub_11B3C. PRESS KEYPAD "+" TO EXPAND]
; [00000053 BYTES: COLLAPSED FUNCTION _realloc.	PRESS KEYPAD "+" TO EXPAND]
byte_11BD1 db 2	dup(0)	; DATA XREF: seg000:1BDFw
			; seg000:1C96r
			; seg000:1CC5r

unknown_libname_1:	; TCC/TCC++/BCC++ 16 bit DOS
pop	word_36F8E
pop	word_36F90
pop	word_36F92
mov	word ptr cs:byte_11BD1,	ds
mov	word_36F94, si
mov	word_36F96, di
cld			; Clear	Direction Flag
mov	es, _psp@
assume es:nothing
mov	si, 80h	; '€'
xor	ah, ah		; Logical Exclusive OR
lods	byte ptr es:[si] ; Load	String
inc	ax		; Increment by 1
mov	bp, es
xchg	dx, si		; Exchange Register/Memory with	Register
xchg	ax, bx		; Exchange Register/Memory with	Register
mov	si, _envLng@
inc	si		; Increment by 1
inc	si		; Increment by 1
mov	cx, 1
cmp	_version@, 3	; Compare Two Operands

loc_11C0C:		; Jump if Below	(CF=1)
jb	short loc_11C1F
mov	es, _envseg@
mov	di, si
mov	cl, 7Fh	; ''
xor	al, al		; Logical Exclusive OR
repne scasb		; Compare String
jcxz	short loc_11C8E	; Jump if CX is	0
xor	cl, 7Fh		; Logical Exclusive OR

loc_11C1F:		; CODE XREF: seg000:loc_11C0Cj
push	ax
mov	ax, cx
add	ax, bx		; Add
inc	ax		; Increment by 1
and	ax, 0FFFEh	; Logical AND
mov	di, sp
sub	di, ax		; Integer Subtraction
jb	short loc_11C8E	; Jump if Below	(CF=1)
mov	sp, di
push	es
pop	ds
push	ss
pop	es
assume es:dseg
push	cx
dec	cx		; Decrement by 1
rep movsb		; Move Byte(s) from String to String
xor	al, al		; Logical Exclusive OR
stosb			; Store	String
mov	ds, bp
xchg	si, dx		; Exchange Register/Memory with	Register
xchg	bx, cx		; Exchange Register/Memory with	Register
mov	ax, bx
mov	dx, ax
inc	bx		; Increment by 1

loc_11C46:		; CODE XREF: seg000:1C60j
			; seg000:1C64j
call	sub_11C66	; Call Procedure
ja	short loc_11C56	; Jump if Above	(CF=0 &	ZF=0)

loc_11C4B:		; CODE XREF: seg000:1C54j
jb	short loc_11C93	; Jump if Below	(CF=1)
cmp	al, 0Dh		; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
call	sub_11C66	; Call Procedure
ja	short loc_11C4B	; Jump if Above	(CF=0 &	ZF=0)

loc_11C56:		; CODE XREF: seg000:1C49j
cmp	al, 20h	; ' '   ; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
cmp	al, 0Dh		; Compare Two Operands
jz	short loc_11C62	; Jump if Zero (ZF=1)
cmp	al, 9		; Compare Two Operands
jnz	short loc_11C46	; Jump if Not Zero (ZF=0)

loc_11C62:		; CODE XREF: seg000:1C4Fj
			; seg000:1C58j
			; seg000:1C5Cj
xor	al, al		; Logical Exclusive OR
jmp	short loc_11C46	; Jump



sub_11C66 proc near	; CODE XREF: seg000:loc_11C46p
			; seg000:1C51p
or	ax, ax		; Logical Inclusive OR
jz	short loc_11C71	; Jump if Zero (ZF=1)
inc	dx		; Increment by 1
stosb			; Store	String
or	al, al		; Logical Inclusive OR
jnz	short loc_11C71	; Jump if Not Zero (ZF=0)
inc	bx		; Increment by 1

loc_11C71:		; CODE XREF: sub_11C66+2j
			; sub_11C66+8j
xchg	ah, al		; Exchange Register/Memory with	Register
xor	al, al		; Logical Exclusive OR
stc			; Set Carry Flag
jcxz	short locret_11C8D ; Jump if CX	is 0
lodsb			; Load String
dec	cx		; Decrement by 1
sub	al, 22h	; '"'   ; Integer Subtraction
jz	short locret_11C8D ; Jump if Zero (ZF=1)
add	al, 22h	; '"'   ; Add
cmp	al, 5Ch	; '\'   ; Compare Two Operands
jnz	short loc_11C8B	; Jump if Not Zero (ZF=0)
cmp	byte ptr [si], 22h ; '"' ; Compare Two Operands
jnz	short loc_11C8B	; Jump if Not Zero (ZF=0)
lodsb			; Load String
dec	cx		; Decrement by 1

loc_11C8B:		; CODE XREF: sub_11C66+1Cj
			; sub_11C66+21j
or	si, si		; Logical Inclusive OR

locret_11C8D:		; CODE XREF: sub_11C66+10j
			; sub_11C66+16j
retn			; Return Near from Procedure
sub_11C66 endp


loc_11C8E:		; CODE XREF: seg000:1C1Aj
			; seg000:1C2Cj
			; seg000:1CA8j
nop			; No Operation
nop			; No Operation
jmp	_abort		; Jump

loc_11C93:		; CODE XREF: seg000:loc_11C4Bj
pop	cx
add	cx, dx		; Add
mov	ds, word ptr cs:byte_11BD1
mov	word_36F8A, bx
inc	bx		; Increment by 1
add	bx, bx		; Add
mov	si, sp
mov	bp, sp
sub	bp, bx		; Integer Subtraction
jb	short loc_11C8E	; Jump if Below	(CF=1)
mov	sp, bp
mov	word_36F8C, bp

loc_11CB0:		; CODE XREF: seg000:1CBEj
jcxz	short loc_11CC0	; Jump if CX is	0
mov	[bp+0],	si
add	bp, 2		; Add

loc_11CB8:		; CODE XREF: seg000:1CBCj
lods	byte ptr ss:[si] ; Load	String
or	al, al		; Logical Inclusive OR
loopne	loc_11CB8	; Loop while rCX != 0 and ZF=0
jz	short loc_11CB0	; Jump if Zero (ZF=1)

loc_11CC0:		; CODE XREF: seg000:loc_11CB0j
xor	ax, ax		; Logical Exclusive OR
mov	[bp+0],	ax
mov	ds, word ptr cs:byte_11BD1
mov	si, word_36F94
mov	di, word_36F96
push	word_36F92
push	word_36F90
mov	ax, word_36F8A
mov	argc, ax
mov	ax, word_36F8C
mov	argv, ax
jmp	word_36F8E	; Indirect Near	Jump


; Attributes: library function bp-based	frame

; int __cdecl setblock(unsigned	int segx, unsigned int newsize)
_setblock proc far	; CODE XREF: idk_InBrkSbrk+4Ap

segx= word ptr	6
newsize= word ptr  8

push	bp
mov	bp, sp
mov	ah, 4Ah
mov	bx, [bp+newsize]
mov	es, [bp+segx]
assume es:nothing
int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
jb	short loc_11CFE	; Jump if Below	(CF=1)
mov	ax, 0FFFFh
jmp	short loc_11D04	; Jump

loc_11CFE:		; CODE XREF: _setblock+Dj
push	bx
push	ax
call	__IOERROR	; Call Procedure
pop	ax

loc_11D04:		; CODE XREF: _setblock+12j
pop	bp
retf			; Return Far from Procedure
_setblock endp



; TCC/TCC++/BCC++ 16 bit DOS
; Attributes: library function

unknown_libname_2 proc far
push	si
push	di
mov	cx, _envLng@
push	cx		; size
nop			; No Operation
push	cs
call	near ptr _malloc ; void	*__cdecl malloc(size_t size);
			; NOTE:	It appears to no use the "size"	variable.
pop	cx
mov	di, ax
or	ax, ax		; Logical Inclusive OR
jz	short loc_11D3D	; Jump if Zero (ZF=1)
push	ds
push	ds
pop	es
assume es:dseg
mov	ds, _envseg@
xor	si, si		; Logical Exclusive OR
cld			; Clear	Direction Flag
rep movsb		; Move Byte(s) from String to String
pop	ds
mov	di, ax
push	es
push	_envSize@	; size
nop			; No Operation
push	cs
call	near ptr _malloc ; void	*__cdecl malloc(size_t size);
			; NOTE:	It appears to not use the "size" variable.
pop	bx
mov	bx, ax
pop	es
assume es:nothing
mov	word_36F98, ax
or	ax, ax		; Logical Inclusive OR
jnz	short loc_11D42	; Jump if Not Zero (ZF=0)

loc_11D3D:		; CODE XREF: unknown_libname_2+11j
nop			; No Operation
nop			; No Operation
jmp	_abort		; Jump

loc_11D42:		; CODE XREF: unknown_libname_2+35j
xor	ax, ax		; Logical Exclusive OR
mov	cx, 0FFFFh
cmp	byte ptr [di], 0 ; Compare Two Operands
jz	short loc_11D58	; Jump if Zero (ZF=1)

loc_11D4C:		; CODE XREF: unknown_libname_2+50j
mov	[bx], di
add	bx, 2		; Add
repne scasb		; Compare String
cmp	es:[di], al	; Compare Two Operands
jnz	short loc_11D4C	; Jump if Not Zero (ZF=0)

loc_11D58:		; CODE XREF: unknown_libname_2+44j
mov	[bx], ax
pop	di
pop	si
mov	ax, word_36F98
mov	envp, ax
retn			; Return Near from Procedure
unknown_libname_2 endp ; sp-analysis failed

; [0000001B BYTES: COLLAPSED FUNCTION __chmod. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _close. PRESS KEYPAD "+" TO EXPAND]
; [0000001E BYTES: COLLAPSED FUNCTION __close. PRESS KEYPAD "+"	TO EXPAND]
; [00000052 BYTES: COLLAPSED FUNCTION _fcloseall. PRESS	KEYPAD "+" TO EXPAND]
; [00000077 BYTES: COLLAPSED FUNCTION _eof. PRESS KEYPAD "+" TO	EXPAND]
; [00000081 BYTES: COLLAPSED FUNCTION _fclose. PRESS KEYPAD "+"	TO EXPAND]
; [00000081 BYTES: COLLAPSED FUNCTION _fflush. PRESS KEYPAD "+"	TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION _flushall. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

hrmCheckAccessMode proc	near
			; CODE XREF: __OPENFP+15p

var_2= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
arg4mode= word ptr  8

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
mov	si, [bp+arg4mode]
mov	[bp+var_2], 0
mov	bx, si
inc	si		; Increment by 1
mov	cl, [bx]
mov	al, cl
cmp	al, 'r'         ; Compare Two Operands
jnz	short loc_11FEC	; Jump if Not Zero (ZF=0)
mov	dx, 1
mov	di, 1
jmp	short loc_1200C	; Jump

loc_11FEC:		; CODE XREF: hrmCheckAccessMode+19j
cmp	cl, 'w'         ; Compare Two Operands
jnz	short loc_11FF6	; Jump if Not Zero (ZF=0)
mov	dx, 302h
jmp	short loc_11FFE	; Jump

loc_11FF6:		; CODE XREF: hrmCheckAccessMode+26j
cmp	cl, 'a'         ; Compare Two Operands
jnz	short loc_12008	; Jump if Not Zero (ZF=0)
mov	dx, 902h

loc_11FFE:		; CODE XREF: hrmCheckAccessMode+2Bj
mov	[bp+var_2], 80h	; '€'
mov	di, 2
jmp	short loc_1200C	; Jump

loc_12008:		; CODE XREF: hrmCheckAccessMode+30j
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_1207B	; Jump

loc_1200C:		; CODE XREF: hrmCheckAccessMode+21j
			; hrmCheckAccessMode+3Dj
mov	cl, [si]
inc	si		; Increment by 1
cmp	cl, '+'         ; Compare Two Operands
jz	short loc_12023	; Jump if Zero (ZF=1)
cmp	byte ptr [si], '+' ; Compare Two Operands
jnz	short loc_12038	; Jump if Not Zero (ZF=0)
cmp	cl, 't'         ; Compare Two Operands
jz	short loc_12023	; Jump if Zero (ZF=1)
cmp	cl, 'b'         ; Compare Two Operands
jnz	short loc_12038	; Jump if Not Zero (ZF=0)

loc_12023:		; CODE XREF: hrmCheckAccessMode+49j
			; hrmCheckAccessMode+53j
cmp	cl, '+'         ; Compare Two Operands
jnz	short loc_1202A	; Jump if Not Zero (ZF=0)
mov	cl, [si]

loc_1202A:		; CODE XREF: hrmCheckAccessMode+5Dj
db 83h,0E2h,0FCh ; <BAD>and	dx, 0FFFCh ; Logical AND
or	dx, 4		; Logical Inclusive OR
mov	[bp+var_2], 180h
mov	di, 3

loc_12038:		; CODE XREF: hrmCheckAccessMode+4Ej
			; hrmCheckAccessMode+58j
cmp	cl, 't'         ; Compare Two Operands
jnz	short loc_12043	; Jump if Not Zero (ZF=0)
or	dx, 4000h	; Logical Inclusive OR
jmp	short loc_12060	; Jump

loc_12043:		; CODE XREF: hrmCheckAccessMode+72j
cmp	cl, 'b'         ; Compare Two Operands
jnz	short loc_1204E	; Jump if Not Zero (ZF=0)
or	dx, 8000h	; Logical Inclusive OR
jmp	short loc_1205D	; Jump

loc_1204E:		; CODE XREF: hrmCheckAccessMode+7Dj
mov	ax, word_36F04
and	ax, 0C000h	; Logical AND
or	dx, ax		; Logical Inclusive OR
mov	ax, dx
test	ax, 8000h	; Logical Compare
jz	short loc_12060	; Jump if Zero (ZF=1)

loc_1205D:		; CODE XREF: hrmCheckAccessMode+83j
or	di, 40h		; Logical Inclusive OR

loc_12060:		; CODE XREF: hrmCheckAccessMode+78j
			; hrmCheckAccessMode+92j
mov	word ptr ptr_exitfopen+2, seg seg000
mov	word ptr ptr_exitfopen,	offset __xfclose
mov	bx, [bp+arg_2]
mov	[bx], dx
mov	bx, [bp+arg_0]
mov	ax, [bp+var_2]

loc_12077:
mov	[bx], ax
mov	ax, di

loc_1207B:		; CODE XREF: hrmCheckAccessMode+41j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	6		; Return Near from Procedure
hrmCheckAccessMode endp



; int arg_0,int	arg_2,char *argPathName
; Attributes: library function bp-based	frame

; int __fastcall _OPENFP(int, int, char	*argPathName)
__OPENFP proc near	; CODE XREF: _fopen+1Ap

varAccessMode= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 4
arg_2= word ptr	 6
argPathName= dword ptr	8

push	bp
mov	bp, sp
sub	sp, 4		; argSize
push	si		; argType
mov	si, word ptr [bp+argPathName+2]
push	[bp+arg_2]
lea	ax, [bp+var_2]	; Load Effective Address
push	ax
lea	ax, [bp+varAccessMode] ; Load Effective	Address
push	ax
call	hrmCheckAccessMode ; Call Procedure
mov	[si+2],	ax
or	ax, ax		; Logical Inclusive OR
jz	short loc_120C4	; Jump if Zero (ZF=1)
cmp	byte ptr [si+4], 0 ; Compare Two Operands
jge	short loc_120D1	; Jump if Greater or Equal (SF=OF)
push	[bp+varAccessMode] ; argAccessMode
mov	ax, [bp+var_2]
or	ax, [bp+arg_0]	; Logical Inclusive OR
push	ax
push	word ptr [bp+argPathName] ; argPathName
nop			; No Operation
push	cs
call	near ptr _open	; argPathName,argAccessMode
add	sp, 6		; Add
mov	[si+4],	al
or	al, al		; Logical Inclusive OR
jge	short loc_120D1	; Jump if Greater or Equal (SF=OF)

loc_120C4:		; CODE XREF: __OPENFP+1Dj
mov	byte ptr [si+4], 255
mov	word ptr [si+2], 0

loc_120CD:		; CODE XREF: __OPENFP+8Cj
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12118	; Jump

loc_120D1:		; CODE XREF: __OPENFP+23j
			; __OPENFP+3Fj
mov	al, [si+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _isatty ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_120E5	; Jump if Zero (ZF=1)
or	word ptr [si+2], 512 ; Logical Inclusive OR

loc_120E5:		; CODE XREF: __OPENFP+5Bj
mov	ax, 512
push	ax
test	word ptr [si+2], 512 ; Logical Compare
jz	short loc_120F5	; Jump if Zero (ZF=1)
mov	ax, 1
jmp	short loc_120F7	; Jump

loc_120F5:		; CODE XREF: __OPENFP+6Bj
xor	ax, ax		; Logical Exclusive OR

loc_120F7:		; CODE XREF: __OPENFP+70j
push	ax		; argBuffer
xor	ax, ax		; Logical Exclusive OR
push	ax
push	si		; argStream
nop			; No Operation
push	cs
call	near ptr _setvbuf ; argStream,argBuffer,arg_6,argType,argSize
add	sp, 8		; Add
or	ax, ax		; Logical Inclusive OR
jz	short loc_12111	; Jump if Zero (ZF=1)
push	si		; argFileStream
nop			; No Operation
push	cs
call	near ptr _fclose ; FILE	*argFileStream
pop	cx
jmp	short loc_120CD	; Jump

loc_12111:		; CODE XREF: __OPENFP+83j
mov	word ptr [si+0Ch], 0 ;
			; i.e. SI + 3 Bytes ...	array ref?
mov	ax, si

loc_12118:		; CODE XREF: __OPENFP+4Cj
pop	si
mov	sp, bp
pop	bp
retn	8		; Return Near from Procedure
__OPENFP endp ;	sp-analysis failed



; Attributes: library function

__GETFP	proc near	; CODE XREF: _fopen+3p
push	si
mov	si, offset word_36D9A

loc_12123:		; CODE XREF: __GETFP+1Bj
cmp	byte ptr [si+4], 0 ; Compare Two Operands
jl	short loc_1213C	; Jump if Less (SF!=OF)
mov	ax, __nfile
mov	cl, 4
shl	ax, cl		; AX = AX / 16?
add	ax, offset word_36D9A ;	Add
mov	dx, si
add	si, 16		; Add
cmp	ax, dx		; Compare Two Operands
ja	short loc_12123	; Jump if Above	(CF=0 &	ZF=0)

loc_1213C:		; CODE XREF: __GETFP+8j
cmp	byte ptr [si+4], 0 ; Compare Two Operands
jl	short loc_12146	; Jump if Less (SF!=OF)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12148	; Jump

loc_12146:		; CODE XREF: __GETFP+21j
mov	ax, si

loc_12148:		; CODE XREF: __GETFP+25j
pop	si
retn			; Return Near from Procedure
__GETFP	endp



; argPathFileName,argMode
; Attributes: library function bp-based	frame

; FILE *__cdecl	fopen(const char *argPathFileName, const char *argMode)
_fopen proc far		; CODE XREF: _main+33P
			; _main+245P
			; ST_ReadConfigMom+2DP
			; sub_14489:loc_144DAP
			; ST_ScreenDump+DBP
			; OVR_SaveGame_MagicSet+3C8P
			; sub_3CFC0+E2P
			; sub_3CFC0+2C0P
			; ST_MagicSet_ReadCreateWrite+3BP
			; ST_MagicSet_ReadCreateWrite+60P
			; ST_MagicSet_ReadCreateWrite+FCP
			; sub_3E1DE:loc_3E32EP
			; sub_3E1DE+33DP

argPathFileName= dword ptr  6
argMode= dword ptr  0Ah

push	bp
mov	bp, sp
call	__GETFP		; Call Procedure
mov	dx, ax		; int
or	ax, ax		; Logical Inclusive OR
jnz	short loc_1215A	; Jump if Not Zero (ZF=0)
xor	ax, ax		; Logical Exclusive OR
jmp	short loc_12167	; Jump

loc_1215A:		; CODE XREF: _fopen+Aj
push	dx		; int
push	word ptr [bp+argPathFileName] ;	int
push	word ptr [bp+argPathFileName+2]
xor	ax, ax		; int
push	ax		; path
call	__OPENFP	; int arg_0,int	arg_2,char *argPathName

loc_12167:		; CODE XREF: _fopen+Ej
pop	bp
retf			; Return Far from Procedure
_fopen endp ; sp-analysis failed



; Attributes: library function bp-based	frame

; int __fastcall _FGETN_jwb(int, int, int, FILE	*stream, void *buf)
__FGETN_jwb proc near	; CODE XREF: _fread+34p

stream=	dword ptr  4
buf= dword ptr	8

push	bp
mov	bp, sp
push	si
push	di		; len
jmp	loc_1222E	; Jump

loc_12171:		; CODE XREF: __FGETN_jwb+CBj
inc	word ptr [bp+stream+2] ; Increment by 1
mov	bx, word ptr [bp+stream]
mov	ax, [bx+6]
cmp	ax, word ptr [bp+stream+2] ; Compare Two Operands
jbe	short loc_12184	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	ax, word ptr [bp+stream+2]
jmp	short loc_1218A	; Jump

loc_12184:		; CODE XREF: __FGETN_jwb+14j
mov	bx, word ptr [bp+stream]
mov	ax, [bx+6]

loc_1218A:		; CODE XREF: __FGETN_jwb+19j
mov	di, ax
mov	bx, word ptr [bp+stream]
test	word ptr [bx+2], 40h ; Logical Compare
jz	short loc_121F9	; Jump if Zero (ZF=1)
cmp	word ptr [bx+6], 0 ; Compare Two Operands
jz	short loc_121F9	; Jump if Zero (ZF=1)
mov	ax, [bx+6]
cmp	ax, word ptr [bp+stream+2] ; Compare Two Operands
jnb	short loc_121F9	; Jump if Not Below (CF=0)
cmp	word ptr [bx], 0 ; Compare Two Operands
jnz	short loc_121F9	; Jump if Not Zero (ZF=0)
dec	word ptr [bp+stream+2] ; Decrement by 1
xor	di, di		; Logical Exclusive OR
jmp	short loc_121BC	; Jump

loc_121B0:		; CODE XREF: __FGETN_jwb+5Cj
mov	bx, word ptr [bp+stream]
add	di, [bx+6]	; Add
mov	ax, [bx+6]
sub	word ptr [bp+stream+2],	ax ; Integer Subtraction

loc_121BC:		; CODE XREF: __FGETN_jwb+45j
mov	bx, word ptr [bp+stream]
mov	ax, [bx+6]
cmp	ax, word ptr [bp+stream+2] ; Compare Two Operands
jbe	short loc_121B0	; Jump if Below	or Equal (CF=1 | ZF=1)
push	di
push	word ptr [bp+buf] ; buf
mov	al, [bx+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __read	; Call Procedure
add	sp, 6		; Add
mov	dx, ax
add	word ptr [bp+buf], dx ;	Add
cmp	dx, di		; Compare Two Operands
jz	short loc_1222E	; Jump if Zero (ZF=1)
mov	ax, di
sub	ax, dx		; Integer Subtraction
add	word ptr [bp+stream+2],	ax ; Add

loc_121E8:		; CODE XREF: __FGETN_jwb+C3j
mov	bx, word ptr [bp+stream]
or	word ptr [bx+2], 20h ; Logical Inclusive OR
jmp	short loc_12237	; Jump

loc_121F1:		; CODE XREF: __FGETN_jwb+BEj
mov	bx, word ptr [bp+buf]
mov	[bx], dl
inc	word ptr [bp+buf] ; Increment by 1

loc_121F9:		; CODE XREF: __FGETN_jwb+2Bj
			; __FGETN_jwb+31j
			; __FGETN_jwb+39j
			; __FGETN_jwb+3Ej
dec	word ptr [bp+stream+2] ; Decrement by 1
mov	ax, word ptr [bp+stream+2]
or	ax, ax		; Logical Inclusive OR
jz	short loc_12229	; Jump if Zero (ZF=1)
dec	di		; Decrement by 1
jz	short loc_12229	; Jump if Zero (ZF=1)
mov	bx, word ptr [bp+stream]
dec	word ptr [bx]	; Decrement by 1
jl	short loc_12219	; Jump if Less (SF!=OF)
mov	si, [bx+0Ah]
inc	word ptr [bx+0Ah] ; Increment by 1
mov	al, [si]
mov	ah, 0
jmp	short loc_12222	; Jump

loc_12219:		; CODE XREF: __FGETN_jwb+A2j
push	word ptr [bp+stream] ; stream
nop			; No Operation
push	cs
call	near ptr __fgetc ; Call	Procedure
pop	cx

loc_12222:		; CODE XREF: __FGETN_jwb+AEj
mov	dx, ax
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_121F1	; Jump if Not Zero (ZF=0)

loc_12229:		; CODE XREF: __FGETN_jwb+98j
			; __FGETN_jwb+9Bj
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jz	short loc_121E8	; Jump if Zero (ZF=1)

loc_1222E:		; CODE XREF: __FGETN_jwb+5j
			; __FGETN_jwb+76j
cmp	word ptr [bp+stream+2],	0 ; Compare Two	Operands
jz	short loc_12237	; Jump if Zero (ZF=1)
jmp	loc_12171	; Jump

loc_12237:		; CODE XREF: __FGETN_jwb+86j
			; __FGETN_jwb+C9j
mov	ax, word ptr [bp+stream+2]
pop	di
pop	si
pop	bp
retn	6		; Return Near from Procedure
__FGETN_jwb endp ; sp-analysis failed

; [0000004B BYTES: COLLAPSED FUNCTION _fread. PRESS KEYPAD "+" TO EXPAND]


; Attributes: library function bp-based	frame

sub_1228B proc near	; CODE XREF: _fseek+26p
			; _ftell+A5p
			; _ftell+B2p

arg_0= word ptr	 4

push	bp
mov	bp, sp
push	si
push	di
mov	si, [bp+arg_0]
cmp	word ptr [si], 0 ; Compare Two Operands
jge	short loc_122A2	; Jump if Greater or Equal (SF=OF)
mov	dx, [si+6]
add	dx, [si]	; Add
inc	dx		; Increment by 1
mov	di, dx
jmp	short loc_122AD	; Jump

loc_122A2:		; CODE XREF: sub_1228B+Bj
mov	ax, [si]
cwd			; AX ->	DX:AX (with sign)
xor	ax, dx		; Logical Exclusive OR
sub	ax, dx		; Integer Subtraction
mov	dx, ax
mov	di, ax

loc_122AD:		; CODE XREF: sub_1228B+15j
test	word ptr [si+2], 1000000b ; Logical Compare
jnz	short loc_122E0	; Jump if Not Zero (ZF=0)
mov	cx, [si+0Ah]
cmp	word ptr [si], 0 ; Compare Two Operands
jge	short loc_122D9	; Jump if Greater or Equal (SF=OF)
jmp	short loc_122C7	; Jump

loc_122BE:		; CODE XREF: sub_1228B+41j
dec	cx		; Decrement by 1
mov	bx, cx
cmp	byte ptr [bx], 0Ah ; Compare Two Operands
jnz	short loc_122C7	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1

loc_122C7:		; CODE XREF: sub_1228B+31j
			; sub_1228B+39j
mov	ax, dx
dec	dx		; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_122BE	; Jump if Not Zero (ZF=0)
jmp	short loc_122E0	; Jump

loc_122D0:		; CODE XREF: sub_1228B+53j
mov	bx, cx
inc	cx		; Increment by 1
cmp	byte ptr [bx], 0Ah ; Compare Two Operands
jnz	short loc_122D9	; Jump if Not Zero (ZF=0)
inc	di		; Increment by 1

loc_122D9:		; CODE XREF: sub_1228B+2Fj
			; sub_1228B+4Bj
mov	ax, dx
dec	dx		; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_122D0	; Jump if Not Zero (ZF=0)

loc_122E0:		; CODE XREF: sub_1228B+27j
			; sub_1228B+43j
mov	ax, di
pop	di
pop	si
pop	bp
retn	2		; Return Near from Procedure
sub_1228B endp



; Attributes: library function bp-based	frame

; int __cdecl fseek(FILE *stream, __int32 offset, int whence)
_fseek proc far		; CODE XREF: _setvbuf+5Cp

stream=	dword ptr  6
fromwhere= word	ptr  0Ch
whence=	word ptr  0Eh

push	bp
mov	bp, sp
push	si
push	di
mov	si, word ptr [bp+stream]
mov	di, [bp+fromwhere]
push	si		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short loc_12303	; Jump if Zero (ZF=1)
mov	ax, 0FFFFh
jmp	short loc_1234C	; Jump

loc_12303:		; CODE XREF: _fseek+14j
cmp	di, 1		; Compare Two Operands
jnz	short loc_12318	; Jump if Not Zero (ZF=0)
cmp	word ptr [si], 0 ; Compare Two Operands
jle	short loc_12318	; Jump if Less or Equal	(ZF=1 |	SF!=OF)
push	si
call	sub_1228B	; Call Procedure
cwd			; AX ->	DX:AX (with sign)
sub	word ptr [bp+stream+2],	ax ; Integer Subtraction
sbb	[bp+0Ah], dx	; Integer Subtraction with Borrow

loc_12318:		; CODE XREF: _fseek+1Ej
			; _fseek+23j
and	word ptr [si+2], 0FE5Fh	; Logical AND
mov	word ptr [si], 0
mov	ax, [si+8]
mov	[si+0Ah], ax
push	di		; fromwhere
push	word ptr [bp+0Ah]
push	word ptr [bp+stream+2] ; offset
mov	al, [si+4]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add
db 83h,0FAh,0FFh ; <BAD>cmp	dx, 0FFFFh ; Compare Two Operands
jnz	short loc_1234A	; Jump if Not Zero (ZF=0)
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_1234A	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
jmp	short loc_1234C	; Jump

loc_1234A:		; CODE XREF: _fseek+56j
			; _fseek+5Bj
xor	ax, ax		; Logical Exclusive OR

loc_1234C:		; CODE XREF: _fseek+19j
			; _fseek+60j
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
_fseek endp ; sp-analysis failed

; [000000C7 BYTES: COLLAPSED FUNCTION _ftell. PRESS KEYPAD "+" TO EXPAND]


; argPtrBuffer,argSize,argNumber,argPtrFile
; Attributes: library function bp-based	frame

; size_t __cdecl fwrite(const void *argPtrWriteBuffer, size_t argSize, size_t argNumber, FILE *argPtrFileStream)
_fwrite	proc far	; CODE XREF: _main+25EP
			; ST_ScreenDump+FBP
			; ST_ScreenDump+115P
			; ST_ScreenDump+12FP
			; ST_ScreenDump+149P
			; ST_ScreenDump+163P
			; ST_ScreenDump+17DP
			; ST_ScreenDump+197P
			; ST_ScreenDump+1B1P
			; ST_ScreenDump+1CFP
			; ST_ScreenDump+1F4P
			; ST_ScreenDump+20EP
			; ST_ScreenDump+228P
			; ST_ScreenDump+247P
			; ST_ScreenDump+25CP
			; ST_ScreenDump+27BP
			; ST_ScreenDump+295P
			; ST_ScreenDump+2AFP
			; ST_ScreenDump+2C9P
			; ST_ScreenDump+2F0P
			; ST_ScreenDump+315P
			; ST_ScreenDump+32FP
			; ST_ScreenDump+356P
			; ST_ScreenDump+37CP
			; ST_ScreenDump+396P
			; ST_ScreenDump+3BAP
			; ST_ScreenDump+3CFP
			; ST_ScreenDump+3E4P
			; OVR_SaveGame_MagicSet+3E1P
			; sub_3CFC0+2D9P
			; ST_MagicSet_ReadCreateWrite+51P
			; ST_MagicSet_ReadCreateWrite+112P
			; sub_3E1DE+353P

var_4= word ptr	-4
var_2= word ptr	-2
argPtrWriteBuffer= dword ptr  6
argSize= word ptr  0Ah
argNumber= word	ptr  0Ch
argPtrFileStream= dword	ptr  0Eh

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	si
push	di
mov	si, word ptr [bp+argPtrWriteBuffer+2]
mov	di, [bp+argSize]
or	si, si		; If (SI == 0) Then Set	(ZF = 1)
jnz	short SOURCE_NOT_NULL ;	Jump if	Not Zero (ZF=0)
mov	ax, di
jmp	short loc_1245D	; Jump

SOURCE_NOT_NULL:	; CODE XREF: _fwrite+10j
mov	bx, si
xor	cx, cx		; CX = 0
mov	ax, di
xor	dx, dx		; DX = 0
call	N_LXMUL@	; Call Procedure
mov	[bp+var_2], dx
mov	[bp+var_4], ax
cmp	dx, 1		; Compare Two Operands
ja	short FAILURE	; Jump if Above	(CF=0 &	ZF=0)
jb	short loc_12449	; Jump if Below	(CF=1)
or	ax, ax		; argNumber
jnb	short FAILURE	; Jump if Not Below (CF=0)

loc_12449:		; CODE XREF: _fwrite+2Cj
push	word ptr [bp+argPtrWriteBuffer]	; stream
push	[bp+var_4]	; int
push	[bp+argNumber]	; int
call	__FPUTN		; Call Procedure
xor	dx, dx		; Logical Exclusive OR
div	si		; Unsigned Divide
jmp	short loc_1245D	; Jump

FAILURE:		; CODE XREF: _fwrite+2Aj
			; _fwrite+30j
xor	ax, ax		; Logical Exclusive OR

loc_1245D:		; CODE XREF: _fwrite+14j
			; _fwrite+42j
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
_fwrite	endp ; sp-analysis failed

; [00000029 BYTES: COLLAPSED FUNCTION sub_12463. PRESS KEYPAD "+" TO EXPAND]
; [00000059 BYTES: COLLAPSED FUNCTION sub_1248C. PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION __fgetc. PRESS KEYPAD "+"	TO EXPAND]

__Nfgetc:
pop	ax
push	cs
push	ax
; [000000AF BYTES: COLLAPSED FUNCTION _fgetc. PRESS KEYPAD "+" TO EXPAND]
; [0000000A BYTES: COLLAPSED FUNCTION _fgetchar. PRESS KEYPAD "+" TO EXPAND]
; [0000005F BYTES: COLLAPSED FUNCTION _getenv. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION _itoa. PRESS KEYPAD "+" TO EXPAND]
; [0000001A BYTES: COLLAPSED FUNCTION _ultoa. PRESS KEYPAD "+" TO EXPAND]


; char *LtoA(long value, char ^string, int radix)
;   converts value to a	null-terminated	string and stores the result in	string
; Parameters:
;   value   long integer to be converted
;   string  pointer to character array
;   radix   the	base to	be used	in converting
; Return:
;   LtoA returns a pointer to string.
;
; Attributes: library function bp-based	frame

; char *__cdecl	ltoa(__int32 value, char *string, int radix)
_ltoa proc far		; CODE XREF: ST_ExitWithMemDiag+4AP
			; sub_1967E+14P
			; sub_19794+14P
			; sub_19804+14P
			; sub_198E4+14P
			; sub_19F09+22P

value= word ptr	 6
arg_2= word ptr	 8
string=	word ptr  0Ah
arg_6= word ptr	 0Ch
radix= word ptr	 0Eh

push	bp
mov	bp, sp
mov	ax, [bp+arg_6]
push	[bp+arg_2]
push	[bp+value]
push	[bp+string]
push	ax
cmp	ax, 0Ah		; Compare Two Operands
jnz	short loc_1266E	; Jump if Not Zero (ZF=0)
mov	ax, 1
jmp	short loc_12670	; Jump

loc_1266E:		; CODE XREF: _ltoa+13j
xor	ax, ax		; Logical Exclusive OR

loc_12670:		; CODE XREF: _ltoa+18j
push	ax
mov	al, 61h	; 'a'
push	ax
call	__LONGTOA	; arg0:
			;   push    dx
			; arg2:
			;   push    ax
			; arg4:
			;   push    [bp+string]
			; arg6:
			;   push    cx
			; arg8
			;   mov	    al,	1
			;   push    ax
			; argA
			;   mov	    al,	61h ; 'a'
			;   push    ax
pop	bp
retf			; Return Far from Procedure
_ltoa endp

; [0000001F BYTES: COLLAPSED FUNCTION _memcpy. PRESS KEYPAD "+"	TO EXPAND]


; argAttributes,argFileName
; Attributes: library function bp-based	frame

; int __stdcall	DOS_CreateFileWithHandle(int argAttributes, int	argFileName)
DOS_CreateFileWithHandle proc near
			; CODE XREF: _open+85p
			; _open+A0p

argAttributes= word ptr	 4
argFileName= word ptr  6

push	bp
mov	bp, sp
mov	cx, [bp+argAttributes]
mov	ah, 3Ch
mov	dx, [bp+argFileName]
int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
jb	short FAILURE	; Jump if Below	(CF=1)
jmp	short loc_126AD	; Jump

FAILURE:		; CODE XREF: DOS_CreateFileWithHandle+Dj
push	ax
call	__IOERROR	; Call Procedure

loc_126AD:		; CODE XREF: DOS_CreateFileWithHandle+Fj
pop	bp
retn	4		; Return Near from Procedure
DOS_CreateFileWithHandle endp

; [00000012 BYTES: COLLAPSED FUNCTION DOS_WriteToFileWithHandle. PRESS KEYPAD "+" TO EXPAND]
; [00000158 BYTES: COLLAPSED FUNCTION _open. PRESS KEYPAD "+" TO EXPAND]
; [0000004D BYTES: COLLAPSED FUNCTION __open. PRESS KEYPAD "+" TO EXPAND]
; [00000019 BYTES: COLLAPSED FUNCTION __fputc. PRESS KEYPAD "+"	TO EXPAND]
; [00000136 BYTES: COLLAPSED FUNCTION _fputc. PRESS KEYPAD "+" TO EXPAND]
; [00000012 BYTES: COLLAPSED FUNCTION _fputchar. PRESS KEYPAD "+" TO EXPAND]


;   push    word ptr [bp+argPointer]
;   push    [bp+var_4]
;   push    [bp+argNumber]
; Attributes: library function bp-based	frame

; int __fastcall _FPUTN(int argNumber, int argSize, FILE *argStream)
__FPUTN	proc near	; CODE XREF: _fwrite+3Bp

varOriginalSize= word ptr -2
argNumber= word	ptr  4
argSize= word ptr  6
argStream= word	ptr  8
dest= dword ptr	 0Ah

push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si		; n
push	di		; len
mov	di, [bp+argNumber]
mov	ax, [bp+argSize]
mov	[bp+varOriginalSize], ax
test	word ptr [di+2], 8 ; Logical Compare
jz	short loc_12A0B	; Jump if Zero (ZF=1)
jmp	short loc_129FE	; Jump

LOOP_xSIZE:		; CODE XREF: __FPUTN+3Dj
push	di		; stream
mov	bx, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [bx]
cbw			; AL ->	AX (with sign)
push	ax		; c
push	cs
call	near ptr _fputc	; Call Procedure
pop	cx
pop	cx
cmp	ax, 0FFFFh	; Compare Two Operands
jnz	short loc_129FE	; Jump if Not Zero (ZF=0)

FAILURE:		; CODE XREF: __FPUTN+6Bj
			; __FPUTN:loc_12A78j
			; __FPUTN+D6j
			; __FPUTN+139j
			; __FPUTN+173j
			; __FPUTN+19Aj
xor	ax, ax		; Logical Exclusive OR
jmp	RETURN		; Jump

loc_129FE:		; CODE XREF: __FPUTN+18j
			; __FPUTN+2Ej
mov	ax, [bp+argSize]
dec	[bp+argSize]	; Decrement by 1
or	ax, ax		; If (AX == 0) Then Set	(ZF = 1)
jnz	short LOOP_xSIZE ; Jump	if Not Zero (ZF=0)
jmp	SUCCESS		; Jump

loc_12A0B:		; CODE XREF: __FPUTN+16j
test	[di+FILE.flags], 1000000b ; Logical Compare
jnz	short loc_12A15	; Jump if Not Zero (ZF=0)
jmp	loc_12B07	; Jump

loc_12A15:		; CODE XREF: __FPUTN+47j
cmp	[di+argSize], 0	; If (argSize == 0) Then Set (ZF = 1)
jnz	short loc_12A1E	; Jump if Not Zero (ZF=0)
jmp	loc_12AC3	; Jump

loc_12A1E:		; CODE XREF: __FPUTN+50j
mov	ax, [di+argSize]
cmp	ax, [bp+argSize] ; Compare Two Operands
jnb	short loc_12A7E	; Jump if Not Below (CF=0)
cmp	word ptr [di], 0 ; Compare Two Operands
jz	short loc_12A36	; Jump if Zero (ZF=1)
push	di		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jnz	short FAILURE	; Jump if Not Zero (ZF=0)

loc_12A36:		; CODE XREF: __FPUTN+60j
mov	al, [di+4]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
test	word ptr [bx+51CCh], 800h ; Logical Compare
jz	short loc_12A5D	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax		; fromwhere
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx		; offset
mov	al, byte ptr [di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add

loc_12A5D:		; CODE XREF: __FPUTN+7Bj
push	[bp+argSize]
push	[bp+argStream]	; buf
mov	al, byte ptr [di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __write ; Call	Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jnz	short loc_12A78	; Jump if Not Zero (ZF=0)
jmp	SUCCESS		; Jump

loc_12A78:		; CODE XREF: __FPUTN+AAj
jmp	FAILURE		; Jump
jmp	SUCCESS		; Jump

loc_12A7E:		; CODE XREF: __FPUTN+5Bj
mov	ax, [di]
add	ax, [bp+argSize] ; Add
jl	short MEM_COPY	; Jump if Less (SF!=OF)
cmp	word ptr [di], 0 ; Compare Two Operands
jnz	short loc_12A94	; Jump if Not Zero (ZF=0)
mov	ax, 0FFFFh
sub	ax, [di+argSize] ; Integer Subtraction
mov	[di], ax
jmp	short MEM_COPY	; Jump

loc_12A94:		; CODE XREF: __FPUTN+BFj
push	di		; stream
nop			; No Operation
push	cs
call	near ptr _fflush ; Call	Procedure
pop	cx
or	ax, ax		; Logical Inclusive OR
jz	short MEM_COPY	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump

MEM_COPY:		; CODE XREF: __FPUTN+BAj
			; __FPUTN+C9j
			; __FPUTN+D4j
push	[bp+argSize]	; src
push	[bp+argStream]
push	word ptr [di+dest] ; dest
nop			; No Operation
push	cs
call	near ptr _memcpy ; Call	Procedure
add	sp, 6		; Add
mov	ax, [di]
add	ax, [bp+argSize] ; Add
mov	[di], ax

loc_12ABA:
mov	ax, [bp+argSize]
add	word ptr [di+dest], ax ; Add
jmp	SUCCESS		; Jump

loc_12AC3:		; CODE XREF: __FPUTN+52j
mov	al, [di+4]
cbw			; AL ->	AX (with sign)
shl	ax, 1		; Shift	Logical	Left
mov	bx, ax
test	word ptr [bx+51CCh], 800h ; Logical Compare
jz	short loc_12AEA	; Jump if Zero (ZF=1)
mov	ax, 2
push	ax		; fromwhere
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax
push	dx		; offset
mov	al, byte ptr [di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr _lseek	; Call Procedure
add	sp, 8		; Add

loc_12AEA:		; CODE XREF: __FPUTN+108j
push	[bp+argSize]
push	[bp+argStream]	; buf
mov	al, byte ptr [di+argNumber]
cbw			; AL ->	AX (with sign)
push	ax		; handle
nop			; No Operation
push	cs
call	near ptr __write ; Call	Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jz	short SUCCESS	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump
jmp	short SUCCESS	; Jump

loc_12B07:		; CODE XREF: __FPUTN+49j
cmp	[di+argSize], 0	; Compare Two Operands
jz	short loc_12B4B	; Jump if Zero (ZF=1)
jmp	short loc_12B3F	; Jump

loc_12B0F:		; CODE XREF: __FPUTN+17Ej
inc	word ptr [di]	; Increment by 1
jge	short loc_12B27	; Jump if Greater or Equal (SF=OF)
mov	bx, word ptr [di+dest]
inc	word ptr [di+dest] ; Increment by 1
mov	si, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [si]
mov	[bx], al
mov	ah, 0
jmp	short loc_12B37	; Jump

loc_12B27:		; CODE XREF: __FPUTN+148j
push	di		; stream
mov	bx, [bp+argStream]
inc	[bp+argStream]	; Increment by 1
mov	al, [bx]
push	ax		; c
push	cs
call	near ptr __fputc ; Call	Procedure
pop	cx
pop	cx

loc_12B37:		; CODE XREF: __FPUTN+15Cj
cmp	ax, 0FFFFh	; If (AX == 65535) Then	Set (ZF	= 1)
jnz	short loc_12B3F	; Jump if Not Zero (ZF=0)
jmp	FAILURE		; Jump

loc_12B3F:		; CODE XREF: __FPUTN+144j
			; __FPUTN+171j
mov	ax, [bp+argSize]
dec	[bp+argSize]	; Decrement by 1
or	ax, ax		; Logical Inclusive OR
jnz	short loc_12B0F	; Jump if Not Zero (ZF=0)
jmp	short SUCCESS	; Jump

loc_12B4B:		; CODE XREF: __FPUTN+142j
push	[bp+argSize]	; int
push	[bp+argStream]	; int
mov	al, byte ptr [di+argNumber]
cbw			; int
push	ax		; int
nop			; No Operation
push	cs
call	near ptr ___write ; Call Procedure
add	sp, 6		; Add
cmp	ax, [bp+argSize] ; Compare Two Operands
jz	short SUCCESS	; Jump if Zero (ZF=1)
jmp	FAILURE		; Jump

SUCCESS:		; CODE XREF: __FPUTN+3Fj
			; __FPUTN+ACj
			; __FPUTN+B2j
			; __FPUTN+F7j
			; __FPUTN+137j
			; __FPUTN+13Cj
			; __FPUTN+180j
			; __FPUTN+198j
mov	ax, [bp+varOriginalSize] ; If (!FAILURE) Then Assume Bytes Written As Requested
			;   mov	    [bp+var_2],	ax

RETURN:			; CODE XREF: __FPUTN+32j
pop	di
pop	si
mov	sp, bp
pop	bp
retn	6		; Return Near from Procedure
__FPUTN	endp ; sp-analysis failed

; [000000CE BYTES: COLLAPSED FUNCTION ___read. PRESS KEYPAD "+"	TO EXPAND]


; argStream,argBuffer,arg_6,argType,argSize
; Attributes: library function bp-based	frame

; int __cdecl setvbuf(FILE *argStream, char *argBuffer,	int argType, size_t argSize)
_setvbuf proc far	; CODE XREF: __setupio+66p
			; __setupio+9Ep
			; __OPENFP+7Bp

argStream= dword ptr  6
argBuffer= word	ptr  0Ah
arg_6= word ptr	 0Ch
argType= word ptr  0Eh
argSize= word ptr  10h

push	bp
mov	bp, sp
push	si
push	di		; whence
mov	si, word ptr [bp+argStream]
mov	di, [bp+arg_6]
cmp	[si+0Eh], si	; Compare Two Operands
jnz	short loc_12C5B	; Jump if Not Zero (ZF=0)
cmp	[bp+argBuffer],	2 ; Compare Two	Operands
jg	short loc_12C5B	; Jump if Greater (ZF=0	& SF=OF)
cmp	di, 7FFFh	; Compare Two Operands
jbe	short loc_12C61	; Jump if Below	or Equal (CF=1 | ZF=1)

loc_12C5B:		; CODE XREF: _setvbuf+Ej
			; _setvbuf+14j
			; _setvbuf+B0j
			; _setvbuf+B9j
mov	ax, 0FFFFh
jmp	loc_12D13	; Jump

loc_12C61:		; CODE XREF: _setvbuf+1Aj
cmp	word_36F9E, 0	; Compare Two Operands
jnz	short loc_12C76	; Jump if Not Zero (ZF=0)
cmp	si, offset word_36DAA ;	Compare	Two Operands
jnz	short loc_12C76	; Jump if Not Zero (ZF=0)
mov	word_36F9E, 1
jmp	short loc_12C89	; Jump

loc_12C76:		; CODE XREF: _setvbuf+27j
			; _setvbuf+2Dj
cmp	word_36F9C, 0	; Compare Two Operands
jnz	short loc_12C89	; Jump if Not Zero (ZF=0)
cmp	si, offset word_36D9A ;	Compare	Two Operands
jnz	short loc_12C89	; Jump if Not Zero (ZF=0)
mov	word_36F9C, 1

loc_12C89:		; CODE XREF: _setvbuf+35j
			; _setvbuf+3Cj
			; _setvbuf+42j
cmp	word ptr [si], 0 ; Compare Two Operands
jz	short loc_12CA1	; Jump if Zero (ZF=1)
mov	ax, 1
push	ax
xor	ax, ax		; Logical Exclusive OR
xor	dx, dx		; Logical Exclusive OR
push	ax		; offset
push	dx
push	si		; stream
nop			; No Operation
push	cs
call	near ptr _fseek	; Call Procedure
add	sp, 8		; Add

loc_12CA1:		; CODE XREF: _setvbuf+4Dj
test	word ptr [si+2], 4 ; Logical Compare
jz	short loc_12CB1	; Jump if Zero (ZF=1)
push	word ptr [si+8]	; block
nop			; No Operation
push	cs
call	near ptr _free	; Call Procedure
pop	cx

loc_12CB1:		; CODE XREF: _setvbuf+67j
db 83h,64h,2,0F3h ; <BAD>and	 word ptr [si+2], 0FFF3h ; Logical AND
mov	word ptr [si+6], 0
mov	ax, si
add	ax, 5		; Add
mov	[si+8],	ax
mov	[si+0Ah], ax
cmp	[bp+argBuffer],	2 ; Compare Two	Operands
jz	short loc_12D11	; Jump if Zero (ZF=1)
or	di, di		; Logical Inclusive OR
jbe	short loc_12D11	; Jump if Below	or Equal (CF=1 | ZF=1)
mov	word ptr ptr_exitbuf+2,	seg seg000
mov	word ptr ptr_exitbuf, 31B1h
cmp	word ptr [bp+argStream+2], 0 ; Compare Two Operands
jnz	short loc_12CFB	; Jump if Not Zero (ZF=0)
push	di		; size
nop			; No Operation
push	cs
call	near ptr _malloc ; Call	Procedure
pop	cx
mov	word ptr [bp+argStream+2], ax
or	ax, ax		; Logical Inclusive OR
jnz	short loc_12CF2	; Jump if Not Zero (ZF=0)
jmp	loc_12C5B	; Jump

loc_12CF2:		; CODE XREF: _setvbuf+AEj
or	word ptr [si+2], 4 ; Logical Inclusive OR
jmp	short loc_12CFB	; Jump
jmp	loc_12C5B	; Jump

loc_12CFB:		; CODE XREF: _setvbuf+A0j
			; _setvbuf+B7j
mov	ax, word ptr [bp+argStream+2]
mov	[si+0Ah], ax
mov	[si+8],	ax
mov	[si+6],	di
cmp	[bp+argBuffer],	1 ; Compare Two	Operands
jnz	short loc_12D11	; Jump if Not Zero (ZF=0)
or	word ptr [si+2], 1000b ; Logical Inclusive OR

loc_12D11:		; CODE XREF: _setvbuf+8Aj
			; _setvbuf+8Ej
			; _setvbuf+CCj
xor	ax, ax		; Logical Exclusive OR

loc_12D13:		; CODE XREF: _setvbuf+1Fj
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
_setvbuf endp ;	sp-analysis failed

; [0000003F BYTES: COLLAPSED FUNCTION sub_12D17. PRESS KEYPAD "+" TO EXPAND]
; [00000047 BYTES: COLLAPSED FUNCTION sub_12D56. PRESS KEYPAD "+" TO EXPAND]
word_12D9D dw	   0,	2Fh,   3Ah,   5Ch
			; DATA XREF: sub_12D56+1Do
			; value	table for switch statement
dw offset loc_12D8F	; jump table for switch	statement
dw offset loc_12D8F
dw offset loc_12D89
dw offset loc_12D8F
; [0000015C BYTES: COLLAPSED FUNCTION __fnsplit. PRESS KEYPAD "+" TO EXPAND]
word_12F09 dw	   0,	2Ah,   2Eh,   2Fh
			; DATA XREF: __fnsplit+82o
dw    3Ah,   3Fh,   5Ch	; value	table for switch statement
off_12F17 dw offset loc_12E7B ;	jump table for switch statement
dw offset loc_12ED5
dw offset loc_12E45
dw offset loc_12E9C
dw offset loc_12E74
dw offset loc_12ED5
dw offset loc_12E9C
; [0000001B BYTES: COLLAPSED FUNCTION __splitpath. PRESS KEYPAD	"+" TO EXPAND]
; [00000039 BYTES: COLLAPSED FUNCTION _strcat. PRESS KEYPAD "+"	TO EXPAND]


; argDest,argSrc
; Attributes: library function bp-based	frame

; char *__cdecl	strcpy(char *argDest, const char *argSrc)
_strcpy	proc far	; CODE XREF: __searchenv+29p
			; __searchstr+29p
			; sub_12D17+34p
			; _main+1E1P
			; _main+236P
			; sub_137EA+DCP
			; ST_ExitWithMemDiag+25P
			; ST_execl_WizardsExe+6BP
			; EXIT_AllocationError+BP
			; MemBlocksErrorExit+1CP
			; MemBlocksErrorExit+7CP
			; MemBlocksErrorExit+CEP
			; MemBlocksErrorExit+10FP
			; MemBlocksErrorExit:loc_14DB1P
			; LBX_Load_Entry+B7P
			; LBX_Load_Entry+C3P
			; LBX_Load_Entry+10AP
			; LBX_Load_s15453+AAP
			; LBX_Load_s15453+B6P
			; LBX_Load_s15453+FEP
			; LBX_Load_HelpNewTerrCity+A7P
			; LBX_Load_HelpNewTerrCity+B3P
			; LBX_Load_HelpNewTerrCity+FAP
			; LBX_Load_Entry_4bytes+98P
			; LBX_Load_Entry_4bytes+A4P
			; LBX_Load_Entry_4bytes+EBP
			; ST_Set_LbxDirectoryPath+AP
			; LBX_Load_ErrorHandler+10P
			; LBX_Load_ErrorHandler+8BP
			; LBX_Load_ErrorHandler+117P
			; idk_Setup_EMM+8FP
			; idk_Setup_EMM:loc_16552P
			; LBX_LoadFileMemory+18P
			; LBX_LoadFileMemory+9CP
			; LBX_AllocMem+18P
			; LBX_AllocMem+26P
			; LBX_s16A80:loc_16A98P
			; LBX_s16A80+26P
			; sub_17671+FP
			; sub_17671+33P
			; sub_17671+99P
			; EMM_Allocate+61P
			; EMM_Allocate+BAP
			; EMM_Allocate+116P
			; EMM_Allocate+1C7P
			; sub_17BB8+FP
			; fncBldMsgInsuffEMS:loc_17D49P
			; LBX_Load_FontsStyleData+DP
			; sub_1A576+24P
			; ST_ScreenDump+2DP
			; ST_ScreenDump+47P
			; ST_ScreenDump+92P
			; LBX_Intro_MemAndReadAndMem+AP
			; sub_24DAE+2F5P
			; sub_24DAE+353P
			; sub_24DAE+38EP
			; sub_24DAE+3F4P
			; sub_24DAE:loc_25209P
			; sub_24DAE+8B9P
			; sub_24DAE+8F9P
			; sub_24DAE:loc_25711P
			; sub_24DAE+9B6P
			; sub_24DAE+CFCP
			; sub_24DAE+D3BP
			; sub_24DAE+DA6P
			; sub_26026:loc_2630BP
			; sub_26026+31FP
			; sub_26026+395P
			; rschKBD_s2669B:loc_269A1P
			; rschKBD_s2669B+447P
			; sub_28141+D1P
			; sub_28141+124P
			; sub_28141+3EAP
			; sub_28583+97P
			; sub_28583:loc_288F7P
			; sub_28963:loc_289A0P
			; sub_292B9+10P
			; ST_LoadSoundDrivers+597P
			; ST_SoundErrorHandler+20P
			; ST_SoundErrorHandler+2FP
			; ST_SoundErrorHandler+5DP
			; ST_SoundErrorHandler+8CP
			; OVR_SaveGame_MagicSet+27P
			; ST_LoadSaveGamByNbr+25P
			; ST_MagicSet_ReadCreateWrite+E7P
			; ST_DefaultMagicSet+D5P
			; sub_3DBA6+1D6P
			; sub_3EDD1+507P
			; sub_3F3C6+19DP
			; idk_Load_NEWGAME_LBX+86P
			; idk_Load_NEWGAME_LBX+DFP
			; idk_Load_NEWGAME_LBX+EEP
			; sub_4043A+63P
			; sub_4067D+417P
			; sub_4067D+42FP
			; LBX_NewGame_s41A5F+6ECP
			; sub_4276F+E6P
			; sub_4276F+224P
			; sub_4276F+4ADP
			; sub_4276F+738P
			; sub_430A4+298P
			; sub_5301E+B6P
			; sub_565F2+10P
			; sub_565F2:loc_5668FP
			; sub_565F2+176P
			; sub_565F2+1ABP
			; sub_565F2+249P

argDest= word ptr  6
argSrc=	byte ptr  8

push	bp
mov	bp, sp
push	si
push	di
push	ds
pop	es
cld			; Clear	Direction Flag
mov	di, word ptr [bp+argSrc]
mov	si, di
xor	al, al		; AL = 0
mov	cx, 65535
repne scasb		; Compare String
not	cx		; Count	of Bytes Scanned
mov	di, [bp+argDest]
rep movsb		; Move Byte(s) from String to String
mov	ax, [bp+argDest]
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
_strcpy	endp



; Case-Insensitive String Comparison (i.e. strcasecmp)
; int stricmp (	const char * str1, const char *	str2 );
;   str1  C string to be compared.
;   str2  C string to be compared.
; Return Value
;   <0	  the first character that does	not match has a	lower value in ptr1 than in ptr2
;   =0	  the contents of both strings are equal
;   >0	  the first character that does	not match has a	greater	value in ptr1 than in ptr2
; Attributes: library function bp-based	frame

; int __cdecl stricmp(const char *str1,	const char *str2)
_stricmp proc far	; CODE XREF: LBX_Load_Entry+85P
			; LBX_Load_s15453+78P
			; LBX_Load_HelpNewTerrCity+75P
			; LBX_Load_Entry_4bytes+66P
			; DOS_OpenFileModeCheck+CP
			; DOS_OpenFileModeCheck+1CP
			; DOS_OpenFileModeCheck+39P
			; DOS_OpenFileModeCheck+49P
			; idk_Setup_EMM:loc_16475P
			; LBX_LoadFileMemory+50P
			; LBX_AllocMem+5EP
			; LBX_s16A80:loc_16ADEP
			; Emm_PgCnt_s175B1+19P
			; EMM_Allocate+2EP
			; LBX_Cityname_s4B973+7BP

str1= dword ptr	 6
str2= dword ptr	 0Ah

push	bp
mov	bp, sp
push	si
push	di
mov	ax, ds
mov	es, ax
cld			; Clear	Direction Flag
mov	si, word ptr [bp+str1]
mov	di, word ptr [bp+str1+2]
xor	ax, ax		; AX = 0
mov	bx, ax		; BX = 0

loc_12FAF:		; CH = "a" CL =	"z"
mov	cx, 'az'

LOOP_TO_EOS:		; CODE XREF: _stricmp+1Fj
			; _stricmp+38j
lodsb			; Load String
mov	bl, [di]
or	al, al		; If (AL == 0) Then Set	(ZF = 1)
jz	short GOT_EOS_OR_DIFF ;	Jump if	Zero (ZF=1)
scasb			; Compare String
jz	short LOOP_TO_EOS ; Jump if Zero (ZF=1)

STR1:			; Is AL	>= "a"?
cmp	al, ch
jb	short STR2	; Jump if Below	(CF=1)
cmp	al, cl		; Is AH	<= "z"?
ja	short STR2	; Jump if Above	(CF=0 &	ZF=0)
sub	al, 32		; Convert to UpperCase

STR2:			; CODE XREF: _stricmp+23j
			; _stricmp+27j
cmp	bl, ch		; Compare Two Operands
jb	short COMPARE_BYTE ; Jump if Below (CF=1)
cmp	bl, cl		; Compare Two Operands
ja	short COMPARE_BYTE ; Jump if Above (CF=0 & ZF=0)
sub	bl, 32		; Convert to UpperCase

COMPARE_BYTE:		; CODE XREF: _stricmp+2Dj
			; _stricmp+31j
cmp	al, bl		; If (AL == BL)	Then Set (ZF = 1)
jz	short LOOP_TO_EOS ; Jump if Zero (ZF=1)

GOT_EOS_OR_DIFF:	; CODE XREF: _stricmp+1Cj
sub	ax, bx		; AX = AX - BX (<,=,>)
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
_stricmp endp

; [0000001A BYTES: COLLAPSED FUNCTION _strlen. PRESS KEYPAD "+"	TO EXPAND]
; [0000002C BYTES: COLLAPSED FUNCTION _strncpy.	PRESS KEYPAD "+" TO EXPAND]
; [00000020 BYTES: COLLAPSED FUNCTION _strupr. PRESS KEYPAD "+"	TO EXPAND]
; [0000010E BYTES: COLLAPSED FUNCTION ___write.	PRESS KEYPAD "+" TO EXPAND]
; [0000003A BYTES: COLLAPSED FUNCTION __write. PRESS KEYPAD "+"	TO EXPAND]
; [00000028 BYTES: COLLAPSED FUNCTION __xfclose. PRESS KEYPAD "+" TO EXPAND]
; [00000023 BYTES: COLLAPSED FUNCTION __xfflush. PRESS KEYPAD "+" TO EXPAND]
byte_131D4 db 52h, 75h,	6Eh, 74h, 69h, 6Dh, 65h, 20h
db 6Fh,	76h, 65h, 72h, 6Ch, 61h, 79h, 20h
db 65h,	2 dup(72h), 6Fh, 72h, 0Dh, 0Ah
; START	OF FUNCTION CHUNK FOR CHUNK_OverlayHalt

__OverlayHalt:		; CODE XREF: seg037:04FFJ
			; CHUNK_OverlayHalt:loc_3118CJ
mov	cx, 23
mov	dx, 31D4h
push	cs
pop	ds
assume ds:seg000

loc_131F3:
mov	ah, 40h

loc_131F5:		; File Handle 2	is StdErr
mov	bx, 2

loc_131F8:		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
int	21h		; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

loc_131FA:
mov	ax, 4
push	ax		; status

loc_131FE:
mov	ax, seg	dseg
mov	ds, ax
assume ds:dseg
nop			; No Operation
push	cs

loc_13205:		; Call Procedure
call	near ptr __exit__1of2
; END OF FUNCTION CHUNK	FOR CHUNK_OverlayHalt



nullsub_2 proc far	; CODE XREF: sub_30E8D:loc_30F3DP
			; seg037:054EP
			; __CHECKOVERLAY+49P
			; DATA XREF: seg038:off_314D6o
retf			; Return Far from Procedure
nullsub_2 endp

seg000 ends
