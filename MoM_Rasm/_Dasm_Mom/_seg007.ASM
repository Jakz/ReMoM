;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

include	uni.inc	; see unicode subdir of	ida for	info on	unicode

.386
.model large

include	MAGIC_rprd2.inc



; Segment type:	Pure code
seg007 segment byte public 'CODE' use16
assume cs:seg007
;org 0Ah
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing


; Attributes: bp-based frame

sub_1466A proc far

arg_0= word ptr	 6

push	bp

loc_1466B:
mov	bp, sp

loc_1466D:
push	si

loc_1466E:
push	di

loc_1466F:
push	es

loc_14670:
push	ds

loc_14671:
mov	bx, [bp+arg_0]

loc_14674:		; Increment by 1
inc	bx

loc_14675:
mov	ah, 48h

loc_14677:		; DOS -	2+ - ALLOCATE MEMORY
int	21h		; BX = number of 16-byte paragraphs desired

loc_14679:		; Jump if Below	(CF=1)
jb	short loc_14699

loc_1467B:
mov	es, ax

loc_1467D:
mov	di, 0

loc_14680:
mov	ax, 12FAh

loc_14683:		; Store	String
stosw

loc_14684:
mov	ax, 4ECFh
stosw			; Store	String

loc_14688:
mov	ax, [bp+arg_0]

loc_1468B:		; Increment by 1
inc	ax

loc_1468C:		; Store	String
stosw

loc_1468D:
mov	ax, 1

loc_14690:		; Store	String
stosw

loc_14691:
mov	ax, es

loc_14693:
pop	ds
pop	es
pop	di
pop	si

loc_14697:
pop	bp

locret_14698:		; Return Far from Procedure
retf

loc_14699:		; CODE XREF: sub_1466A:loc_14679j
mov	ax, 0

loc_1469C:
pop	ds

loc_1469D:
pop	es

loc_1469E:
pop	di

loc_1469F:
pop	si

loc_146A0:
pop	bp

locret_146A1:		; Return Far from Procedure
retf
sub_1466A endp



; Attributes: bp-based frame

sub_146A2 proc far

arg_0= word ptr	 6

; FUNCTION CHUNK AT 0058 SIZE 00000009 BYTES

push	bp

loc_146A3:
mov	bp, sp
push	si

loc_146A6:
push	di

loc_146A7:
push	es

loc_146A8:
push	ds

loc_146A9:
mov	bx, [bp+arg_0]

loc_146AC:
mov	ah, 48h

loc_146AE:		; DOS -	2+ - ALLOCATE MEMORY
int	21h		; BX = number of 16-byte paragraphs desired

loc_146B0:		; Jump if Below	(CF=1)
jb	short loc_146B8

loc_146B2:
pop	ds
pop	es
pop	di
pop	si
pop	bp

locret_146B7:		; Return Far from Procedure
retf
sub_146A2 endp

; START	OF FUNCTION CHUNK FOR sub_146A2

loc_146B8:		; CODE XREF: sub_146A2:loc_146B0j
mov	ax, 0
pop	ds

loc_146BC:
pop	es
pop	di
pop	si

loc_146BF:
pop	bp

locret_146C0:		; Return Far from Procedure
retf
; END OF FUNCTION CHUNK	FOR sub_146A2

loc_146C1:
push	bp
mov	bp, sp

loc_146C4:
push	si

loc_146C5:
push	di

loc_146C6:
push	es

loc_146C7:
mov	bx, [bp+6]

loc_146CA:		; Decrement by 1
dec	bx

loc_146CB:
mov	es, bx

loc_146CD:
mov	bx, 0

loc_146D0:
mov	word ptr es:[bx], 0
mov	ah, 49h
int	21h		; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
pop	es

loc_146DA:
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure


; 12FA or 4ECF
;
; Attributes: bp-based frame

; int __cdecl __far ST_Chk_12FA_4ECF(int argPtrBuffer)
ST_Chk_12FA_4ECF proc far ; CODE XREF: sub_149FA+2AP
			; sub_14AF8+14P
			; LBX_Load_Entry+2A1P
			; LBX_Load_Entry+310P
			; LBX_Load_s15453+353P
			; LBX_Load_s15453+3C2P
			; LBX_EmsMapMem+17CP
			; LBX_EmsMapMem+1C3P
			; LBX_s16F45+B7P
			; LBX_s16F45+120P
			; idk_PreEmmPgCnt+19CP
			; idk_PreEmmPgCnt+1E4P

argPtrBuffer= word ptr	6

push	bp
mov	bp, sp
push	ds
push	si
mov	ax, [bp+argPtrBuffer] ;
			; Blarg! IDGI.
			; Sometimes this is a 'push word ptr',
			;  others 'push SI',
			;  and a few 'if ... push 0 or push 1'
			;
mov	ds, ax
mov	si, 4		; ?offset at 4?
lodsw			; AX = DS:SI
cmp	ax, 12FAh	; ? FLC	files have a MagSig of AF12 ?
jnz	short Is_12FA_4ECF ; Jump if Not Zero (ZF=0)

loc_146F1:		; AX = DS:SI
lodsw
cmp	ax, 4ECFh	;
			; ?
			; coincidence
			; 20175	/ 4858 = 4
			; ?
			;
jnz	short Is_12FA_4ECF ; Jump if Not Zero (ZF=0)

Not_12FA_4ECF:
mov	ax, 0FFFFh
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure

Is_12FA_4ECF:		; CODE XREF: ST_Chk_12FA_4ECF+11j
			; ST_Chk_12FA_4ECF+17j
mov	ax, 0
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
ST_Chk_12FA_4ECF endp



; Attributes: bp-based frame

idk_LODSB_Arg2_Arg1 proc far
			; CODE XREF: sub_19454:loc_19467P
			; sub_19454:loc_1947FP
			; sub_19454:loc_19491P
			; sub_19454+4FP
			; sub_19454+61P
			; sub_19958+16P
			; sub_19958+1C3P
			; sub_19D2A:loc_19D35P
			; sub_19D51+BP
			; sub_19F94+7DP
			; sub_19F94:loc_1A068P
			; sub_1A0DC:loc_1A0F2P
			; sub_1A0DC:loc_1A272P
			; sub_1A542+EP
			; sub_1A5F1+16P
			; sub_1A5F1+1E4P
			; sub_1B341+26P
			; sub_1B341+38P
			; sub_1B654+36P
			; sub_1B654+48P
			; sub_1B654+5AP
			; sub_1B984+12P
			; sub_1BC1A+18P
			; sub_1BC1A:loc_1BC52P
			; sub_1BF79+34P
			; sub_1BF79+46P
			; sub_1BF79+56P
			; sub_1BF79+63P
			; sub_1BFF7+56P
			; sub_1BFF7+68P
			; sub_1BFF7:loc_1C06FP
			; sub_1BFF7+85P
			; sub_1F8FD+76P
			; idk_VidLib_s1FBBF+12P
			; sub_21C86:loc_21C96P
			; sub_21C86+27P
			; sub_21C86+38P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
push	si
mov	si, [bp+arg_2]
mov	ax, [bp+arg_0]
mov	ds, ax
lodsb			; Load String
xor	ah, ah		; Logical Exclusive OR
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
idk_LODSB_Arg2_Arg1 endp



; Attributes: bp-based frame

; int __cdecl __far ST_Read_2B_From_Buffer_At_Offset(char *argOffset, char *argPtrSrcBuf)
ST_Read_2B_From_Buffer_At_Offset proc far
			; CODE XREF: idk_LoadSw10_StoreSw14+FP
			; idk_LoadSw14_StoreSw10+FP
			; sub_149FA+1DP
			; sub_14AC3+15P
			; sub_14AF8+51P
			; sub_14AF8+62P
			; fncSub2ndW1stW+FP
			; fncSub2ndW1stW+1CP
			; LBX_Load_Entry+19EP
			; LBX_Load_Entry+1BFP
			; LBX_Load_Entry+2C0P
			; LBX_Load_Entry+2D4P
			; LBX_Load_Entry+35AP
			; LBX_Load_Entry+370P
			; LBX_Load_s15453+196P
			; LBX_Load_s15453+1B7P
			; LBX_Load_s15453+372P
			; LBX_Load_s15453+386P
			; LBX_Load_s15453+40CP
			; LBX_Load_s15453+422P
			; LBX_Load_HelpNewTerrCity+17BP
			; LBX_Load_HelpNewTerrCity+19CP
			; LBX_Load_Entry_4bytes+17FP
			; LBX_Load_Entry_4bytes+1A0P
			; LBX_EmsMapMem+18EP
			; LBX_EmsMapMem+1E4P
			; LBX_EmsMapMem+1F6P
			; LBX_s16F45+D8P
			; LBX_s16F45+163P
			; LBX_s16F45+175P
			; idk_PreEmmPgCnt+1AEP
			; idk_PreEmmPgCnt+205P
			; idk_PreEmmPgCnt+218P
			; sub_19316:loc_19321P
			; ILSe_display_text+107P
			; sub_19D78+25P
			; sub_1A296+25P
			; sub_1A542+1EP
			; sub_1A7FF+102P
			; seg019:0AD3P
			; seg019:0AE4P
			; sub_1BBF9+EP
			; sub_1EE71:loc_1EE7FP
			; sub_1EE71:loc_1EE8CP
			; sub_1EF3C+EP
			; sub_1EF3C:loc_1EF5BP
			; sub_1F13F+EP
			; sub_1F13F+1FP
			; sub_1F290+EP
			; sub_1F290+1FP
			; sub_1F47D+EP
			; sub_1F47D:loc_1F49CP
			; sub_1F51B+EP
			; sub_1F51B+1FP
			; sub_1F5BF+EP
			; sub_1F5BF+1FP
			; sub_1FA6E+1AP
			; sub_1FA6E:loc_1FA97P
			; sub_1FAEB+AP
			; seg028:0C9AP
			; sub_1FB15:loc_1FB1EP
			; sub_1FB29:loc_1FB33P
			; seg028:0CDDP
			; seg028:0CECP
			; sub_20C7A+11P
			; sub_20C7A:loc_20C9CP
			; sub_20C7A:loc_20CACP
			; sub_21014+FP
			; sub_21014+1BP
			; idk_VidLib_s2104D+27P
			; idk_VidLib_s2104D:loc_21085P
			; sub_2117A+EP
			; sub_2117A+1FP
			; sub_2117A+46P
			; sub_2117A+65P
			; sub_2117A:loc_21298P
			; sub_2117A+138P
			; sub_212E2+EP
			; sub_212E2+1FP
			; sub_212E2+46P
			; sub_212E2:loc_21347P
			; sub_212E2+11EP
			; sub_212E2:loc_2141AP
			; sub_2144A+EP
			; sub_2144A+1FP
			; sub_214B0+11P
			; sub_214B0:loc_214D2P
			; sub_215D8+EP
			; sub_215D8:loc_215F7P
			; sub_21829:loc_2183DP
			; sub_21829:loc_2184EP
			; LBX_Load_IntroLbx_s21977+10P
			; LBX_Load_IntroLbx_s21977+26P
			; LBX_Load_IntroLbx_s21977+39P
			; LBX_Load_IntroLbx_s21977+5CP
			; sub_21C58+BP
			; sub_21C86+4FP
			; sub_21D2E+EP
			; sub_21D2E+1FP
			; sub_21E08+EP
			; sub_21E08+1FP
			; sub_21EEA+EP
			; sub_21EEA:loc_21F09P
			; sub_21F59+EP
			; sub_21F59+1FP
			; sub_220AA+14P
			; sub_220AA:loc_220CFP
			; ST_LoadSound+2DP
			; ST_LoadSound+55P
			; ST_LoadSound+1E0P
			; ST_LoadSound+275P
			; ST_LoadSound+29DP
			; ST_LoadSound+2E5P
			; sub_50203+11P
			; sub_50203+22P

argOffset= dword ptr  6
argPtrSrcBuf= dword ptr	 0Ah

push	bp
mov	bp, sp
push	ds
push	si		;
			;
			;
			;
mov	si, word ptr [bp+argOffset+2] ;	FIXME(JWB): ? this should be argPtrSrcBuf
mov	ax, word ptr [bp+argOffset]
mov	ds, ax
lodsw			; Load word at address DS:SI into AX
			;
			; AX = DS:[SI];	SI = SI	+/- 2;
			;
			; NOTE:
			; The segment register can be overriden
			;  with	a segment prefix,
			;  as LODS ES:DATA4
			;
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
ST_Read_2B_From_Buffer_At_Offset endp



;
; Return:
;   Word 1: AX
;   Word 2: DX
; Attributes: bp-based frame

ST_Read_4B_From_Buffer_At_Offset proc far
			; CODE XREF: LBX_Load_Entry+1F0P
			; LBX_Load_Entry+208P
			; LBX_Load_s15453+1E8P
			; LBX_Load_s15453+200P
			; LBX_Load_HelpNewTerrCity+1CDP
			; LBX_Load_HelpNewTerrCity+1E5P
			; LBX_Load_Entry_4bytes+1D1P
			; LBX_Load_Entry_4bytes+1EBP

argOffset= word	ptr  6
argSrc=	word ptr  8

push	bp
mov	bp, sp
push	ds
push	si
mov	si, [bp+argSrc]
mov	ax, [bp+argOffset]
mov	ds, ax
lodsw			; AX = SI
mov	bx, ax
lodsw			; AX = SI
mov	dx, ax
mov	ax, bx
pop	si
pop	ds
pop	bp
retf			; Return Far from Procedure
ST_Read_4B_From_Buffer_At_Offset endp



; Store	AX in word ES:DI, update DI
; ES = argSegment
; DI = argOffset
; AX = argValue
; Attributes: bp-based frame

fncStoSB proc far	; CODE XREF: LBX_s16F45+1CFP
			; LBX_s16F45+1DFP
			; LBX_Load_FontsStyleData+99P
			; LBX_Load_FontsStyleData+B5P
			; sub_1922A+23P
			; sub_19257:loc_1927AP
			; seg017:loc_192A7P
			; seg017:loc_192D4P
			; seg017:loc_19301P
			; seg017:012CP
			; sub_19399+23P
			; sub_193DD:loc_193FDP
			; sub_193DD:loc_19413P
			; sub_193DD+47P
			; sub_193DD+58P
			; sub_193DD:loc_19446P
			; sub_194C2:loc_194DBP
			; sub_194C2+33P
			; sub_194C2+48P
			; sub_194C2:loc_1951FP
			; sub_194C2:loc_19534P
			; sub_19958+3BP
			; sub_19D78+4BP
			; sub_1A0DC+3BP
			; sub_1A5F1+3BP
			; idk_Set_FontsLbx1_256arr_to_1+12P
			; idk_Set_FontsLbx1_256arr_to_0+11P
			; sub_1C40F+68P
			; sub_1C40F:loc_1C48BP
			; sub_1C40F:loc_1C4A1P
			; sub_21D16+EP

argSegment= word ptr  6
argOffset= word	ptr  8
argValue= word ptr  0Ah

push	bp
mov	bp, sp
push	es
push	di
mov	ax, [bp+argSegment]
mov	es, ax
mov	di, [bp+argOffset]
mov	ax, [bp+argValue]
stosb			; Store	String
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
fncStoSB endp



; Attributes: bp-based frame

; int __cdecl __far fncStoSW(int argSegment, int argOffset, int	argValue)
fncStoSW proc far	; CODE XREF: ST_AllocateSpace+52P
			; ST_AllocateSpace+65P
			; ST_AllocateSpace+75P
			; ST_AllocateSpace+88P
			; idk_LoadSw10_StoreSw14+21P
			; idk_LoadSw14_StoreSw10+21P
			; sub_149FA+61P
			; sub_149FA+72P
			; sub_149FA:loc_14A7DP
			; sub_149FA+94P
			; sub_149FA+A5P
			; sub_149FA+B6P
			; sub_14AC3+28P
			; sub_14AF8+71P
			; sub_14AF8+84P
			; sub_14AF8+97P
			; sub_14AF8+AAP
			; sub_14AF8+BDP
			; LBX_Load_Entry+303P
			; LBX_Load_s15453+3B5P
			; LBX_EmsMapMem+1ADP
			; LBX_s16F45+10AP
			; LBX_s16F45+1EFP
			; idk_PreEmmPgCnt+1CEP
			; sub_17A50+4CP
			; sub_17A50+5DP
			; sub_17A50+6EP
			; sub_17A50+7FP
			; sub_17A50:loc_17AE0P
			; sub_17AFA+4AP
			; sub_17AFA+5BP
			; sub_17AFA+6CP
			; sub_17AFA+7DP
			; sub_17AFA+8EP
			; sub_19316+1EP
			; seg017:0144P
			; seg017:0168P
			; sub_19D78+32P
			; hrmStoreSWSB:loc_1EECAP
			; hrmStoreSWSB:loc_1EEDCP
			; hrmStoreSWSB+37P
			; hrmStoreSWSB:loc_1EF01P
			; hrmStoreSWSB+5BP
			; idk_WriteImageHeader_s1F3F8+12P
			; idk_WriteImageHeader_s1F3F8+24P
			; idk_WriteImageHeader_s1F3F8+37P
			; idk_WriteImageHeader_s1F3F8+49P
			; idk_WriteImageHeader_s1F3F8+5BP
			; sub_1F655+47P
			; idk_VidLib_s1F743+F2P
			; sub_1F8FD+3EP
			; sub_1FA6E+58P
			; sub_1FAD4+DP
			; LBX_Intro_MemAndReadAndMem+58P
			; LBX_Intro_MemAndReadAndMem+6BP
			; LBX_Load_IntroLbx_s21977+4CP
			; sub_21C58+24P
			; ST_LoadSound+210P
			; ST_LoadSound+32DP
			; idk_ResourceLbx+25P

argSegment= word ptr  6
argOffset= word	ptr  8
argValue= word ptr  0Ah

push	bp
mov	bp, sp
push	es
push	di
mov	ax, [bp+argSegment]
mov	es, ax
mov	di, [bp+argOffset]
mov	ax, [bp+argValue]
stosw			; ES:DI	= AX
pop	di
pop	es
pop	bp
retf			; Return Far from Procedure
fncStoSW endp



; Attributes: bp-based frame

fncStoSWx2 proc	far

argSegment= word ptr  6
argOffset= word	ptr  8
argValue1= word	ptr  0Ah
argValue2= word	ptr  0Ch

push	bp
mov	bp, sp
push	es
push	di

loc_14773:
mov	ax, [bp+argSegment]

loc_14776:
mov	es, ax

loc_14778:
mov	di, [bp+argOffset]

loc_1477B:
mov	ax, [bp+argValue1]

loc_1477E:		; Store	String
stosw

loc_1477F:
mov	ax, [bp+argValue2]
stosw			; Store	String
pop	di
pop	es
pop	bp

locret_14786:		; Return Far from Procedure
retf
fncStoSWx2 endp

seg007 ends
