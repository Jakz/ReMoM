;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	   Copyright (c) 2009 by Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: AC-7625-2E2D-92			    |
; |				 Valued	Client				    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AABF5C934234A70885DEA7A0C8B3B5DE

; File Name   :	E:\MoM\IDA\IDA50sigs_20141030\MAGIC.EXE
; Format      :	MS-DOS executable (perhaps overlayed)
; Base Address:	1000h Range: 10000h-3C7E0h Loaded length: 2C7E0h
; Entry	Point :	1000:0
; Overlays: base=0002EFE0, size=0001B0B0, EXEinfo=00023D80
; OS type	  :  MS	DOS
; Application type:  Executable	16bit

Ideal
include	uni.inc	; see unicode subdir of	ida for	info on	unicode

p386n
model large

include	"MAGIC.inc"



; Segment type:	Pure code
segment	seg033 byte public 'CODE' use16
assume cs:seg033
;org 6
assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing
byte_23ED6 db 0, 1Eh, 0A0h, 2 dup(0), 30h, 0A1h, 2 dup(0)
db 2Eh,	0A2h, 2	dup(0),	20h, 0A3h, 2 dup(0)
db 12h,	0A4h, 2	dup(0),	21h, 0A5h, 2 dup(0)
db 22h,	0A6h, 2	dup(0),	23h, 0A7h, 2 dup(0)
db 17h,	0A8h, 2	dup(0),	24h, 0A9h, 2 dup(0)
db 25h,	0AAh, 2	dup(0),	26h, 0ABh, 2 dup(0)
db 32h,	0ACh, 2	dup(0),	31h, 0ADh, 2 dup(0)
db 18h,	0AEh, 2	dup(0),	19h, 0AFh, 2 dup(0)
db 10h,	0B0h, 2	dup(0),	13h, 0B1h, 2 dup(0)
db 1Fh,	0B2h, 2	dup(0),	14h, 0B3h, 2 dup(0)
db 16h,	0B4h, 2	dup(0),	2Fh, 0B5h, 2 dup(0)
db 11h,	0B6h, 2	dup(0),	2Dh, 0B7h, 2 dup(0)
db 15h,	0B8h, 2	dup(0),	2Ch, 0B9h, 0


; Attributes: bp-based frame

proc wtf_s23F3E	far	; CODE XREF: ILSe_MAINMENU_screen+390P
			; idk_Mouse_s2B8B1+5EP
			; sub_3CFC0+11AP
			; sub_3DBA6+152P
			; sub_3E1DE+1CDP
			; sub_3EBA0+ABP
			; sub_3F3C6+6DP
			; idk_Load_NEWGAME_LBX+3BP
			; sub_3F7D8:loc_3F866P
			; sub_3FBE0+F2P
			; sub_4067D+E8P
			; idk_BuildingWorlds+35P
			; sub_4D540:loc_4D57DP
			; sub_4D540:loc_4D596P
			; ST_LoadMusicSoundfxIntro+60P
			; idk_OVR_LoadLbxHelp:loc_55CB5P
			; sub_56450:loc_56464P
			; sub_56450:loc_565E6P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_23F3F:
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	cx, [bp+arg_0]
mov	[idk_Mouse_w360A8], cx
sub	ax, ax		; Integer Subtraction
mov	bx, [bp+arg_2]
mov	[idk_Mouse_w360C0], bx
dec	cx		; Decrement by 1
jz	short loc_23F74	; Jump if Zero (ZF=1)

loc_23F5A:
mov	dx, cx
mov	ax, 12

loc_23F5F:		; Unsigned Multiplication of AL	or AX
mul	dx

loc_23F61:		; Add
add	bx, ax

loc_23F63:		; CODE XREF: wtf_s23F3E+34j
sub	ax, ax		; Integer Subtraction
cmp	ax, [bx+4]	; Compare Two Operands
jnz	short loc_23F6F	; Jump if Not Zero (ZF=0)
cmp	ax, [bx+6]	; Compare Two Operands
jz	short loc_23F74	; Jump if Zero (ZF=1)

loc_23F6F:		; CODE XREF: wtf_s23F3E+2Aj
sub	bx, 12		; Integer Subtraction
loop	loc_23F63	; Loop while CX	!= 0

loc_23F74:		; CODE XREF: wtf_s23F3E+1Aj
			; wtf_s23F3E+2Fj
mov	ax, [bx+2]

loc_23F77:
mov	[idk_Mouse_w360AA], ax
mov	ax, [bx]
mov	[idk_Mouse_w3609A], ax
pop	ds

loc_23F80:
pop	bp
retf			; Return Far from Procedure
endp wtf_s23F3E



; Attributes: bp-based frame

proc idk_Mouse_s23F82 far
			; CODE XREF: sub_1E547:loc_1E5CCP
			; sub_1E547+94P
			; Mouse_InterruptCallback+86p
			; sub_24D35:loc_24D91p
			; sub_24DAE+79DP
			; rschKBD_s2669B+280P
			; sub_27913:loc_279D0P
			; sub_27A2B+20P
			; sub_27AFB+1FP
			; sub_27E4B+254P
			; sub_2B470+39BP
			; sub_2E303+1EP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp

loc_23F83:
mov	bp, sp

loc_23F85:
push	ds
push	es

loc_23F87:
mov	ax, seg	dseg

loc_23F8A:
mov	ds, ax
mov	es, ax
assume es:dseg

loc_23F8E:
mov	ax, [idk_Mouse_w3609A]
mov	[idk_Mouse_w3609C], ax

loc_23F94:
mov	bx, [idk_Mouse_w360C0]

loc_23F98:
mov	cx, [idk_Mouse_w360A8]
dec	cx		; Decrement by 1

loc_23F9D:		; Jump if Zero (ZF=1)
jz	short loc_23FCD

loc_23F9F:
mov	dx, cx
mov	ax, 12
mul	dx		; Unsigned Multiplication of AL	or AX

loc_23FA6:		; Add
add	bx, ax

loc_23FA8:		; CODE XREF: idk_Mouse_s23F82:loc_23FCBj
mov	ax, [bx+4]
cmp	[bp+arg_0], ax	; Compare Two Operands
jb	short loc_23FC8	; Jump if Below	(CF=1)

loc_23FB0:
mov	ax, [bx+6]

loc_23FB3:		; Compare Two Operands
cmp	[bp+arg_2], ax

loc_23FB6:		; Jump if Below	(CF=1)
jb	short loc_23FC8

loc_23FB8:
mov	ax, [bx+8]

loc_23FBB:		; Compare Two Operands
cmp	ax, [bp+arg_0]

loc_23FBE:		; Jump if Below	(CF=1)
jb	short loc_23FC8

loc_23FC0:
mov	ax, [bx+0Ah]
cmp	ax, [bp+arg_2]	; Compare Two Operands

loc_23FC6:		; Jump if Not Below (CF=0)
jnb	short loc_23FCD

loc_23FC8:		; CODE XREF: idk_Mouse_s23F82+2Cj
			; idk_Mouse_s23F82:loc_23FB6j
			; idk_Mouse_s23F82:loc_23FBEj
sub	bx, 12		; Integer Subtraction

loc_23FCB:		; Loop while CX	!= 0
loop	loc_23FA8

loc_23FCD:		; CODE XREF: idk_Mouse_s23F82:loc_23F9Dj
			; idk_Mouse_s23F82:loc_23FC6j
mov	ax, [bx+2]

loc_23FD0:
mov	[idk_Mouse_w360AA], ax

loc_23FD3:
mov	ax, [bx]

loc_23FD5:
mov	[idk_Mouse_w3609A], ax

loc_23FD8:
pop	es
assume es:nothing
pop	ds

loc_23FDA:
pop	bp
retf			; Return Far from Procedure
endp idk_Mouse_s23F82




proc sub_23FDC far	; CODE XREF: sub_1E525+4P
			; sub_26026+3DP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w3609A]
pop	ds
retf			; Return Far from Procedure
endp sub_23FDC




proc idk_Get_Mouse_w360AA far
			; CODE XREF: sub_24DAE+2EP
			; sub_24DAE+7A4P
			; sub_24DAE+B54P
			; sub_26026+44P
			; rschKBD_s2669B+287P
			; sub_27913+C4P
			; sub_27A2B+27P
			; sub_27AFB+26P
			; sub_27E4B:loc_280A6P
			; sub_2B470+3A2P
push	ds

loc_23FE8:
mov	ax, seg	dseg

loc_23FEB:
mov	ds, ax

loc_23FED:
mov	ax, [idk_Mouse_w360AA]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360AA




proc GetMouseButtonsStatus far
			; CODE XREF: idk_CheckInputOrSleep_s13F7E:loc_13F99P
			; sub_24DAE+729P
			; sub_24DAE:loc_258A9P
			; sub_24DAE:loc_258E2P
			; sub_24DAE:loc_25B76P
			; sub_24DAE:loc_25B84P
			; sub_27C84:loc_27CABP
			; sub_27CC0+2EP
			; sub_27CC0:loc_27E22P
			; sub_28141:loc_2815CP
			; sub_28141+164P
			; sub_28141:loc_28541P
			; sub_28583:loc_2859EP
			; sub_28583+105P
			; sub_28583:loc_2890DP
push	es
push	ds

loc_23FF4:
mov	ax, seg	dseg

loc_23FF7:
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24015	; Jump if Zero (ZF=1)

IfMouseLeftHandedSwapButtonPressBits:
mov	ax, 3
mov	bx, 0
mov	cx, 0
mov	dx, 0
cli			; Clear	Interrupt Flag
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row

loc_2400F:		; Set Interrupt	Flag
sti

loc_24010:		; call	  swap2lowbits
and	bx, 11b
mov	ax, bx

loc_24015:		; CODE XREF: GetMouseButtonsStatus+Cj
pop	ds

loc_24016:
pop	es
retf			; Return Far from Procedure
endp GetMouseButtonsStatus




proc MOUSE_WaitForButtonStatus far
			; CODE XREF: MOUSE_SetupRangeRoutine+65p
			; DOS_MouseReset+11p
push	si
push	di
push	es
push	ds

LOOP:			; CODE XREF: MOUSE_WaitForButtonStatus+17j
mov	ax, 3
mov	bx, 0
mov	cx, 0
mov	dx, 0
cli			; Clear	Interrupt Flag
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag
and	bx, 11b		; Logical AND
jnz	short LOOP	; Jump if Not Zero (ZF=0)
mov	ax, bx
pop	ds
pop	es

loc_24035:
pop	di

loc_24036:
pop	si
retf			; Return Far from Procedure
endp MOUSE_WaitForButtonStatus



; Attributes: bp-based frame

proc MOUSE_SetupRangeRoutine far
			; CODE XREF: idk_Mouse_s2B8B1+65P
push	bp
mov	bp, sp
sub	sp, 2		; Integer Subtraction
push	si
push	di
push	es
push	ds
cli			; Clear	Interrupt Flag
mov	ax, 0
mov	bx, 0
mov	cx, 0
mov	dx, 0
int	33h		; - MS MOUSE - RESET DRIVER AND	READ STATUS
			; Return: AX = status
			; BX = number of buttons
cmp	ax, 0		; If (AX != 0) Then Set	(ZF = 1)
jnz	short CONTINUE	; Jump if Not Zero (ZF=0)

SKIP:			; Set Interrupt	Flag
sti
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

CONTINUE:		; CODE XREF: MOUSE_SetupRangeRoutine+1Cj
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
mov	[FLAG_MouseLeftHanded],	1
mov	[FLAG_Mouse_Skip], 0
mov	dx, [word_360BC]
mov	cx, [word_360BA]
mov	[idk_Mouse_w360A4], cx
mov	[idk_Mouse_w360A6], dx
mov	ax, 7
mov	bx, 0
mov	cx, 0
mov	dx, 638
int	33h		; - MS MOUSE - DEFINE HORIZONTAL CURSOR	RANGE
			; CX = minimum column, DX = maximum column
mov	ax, 8
mov	bx, 0
mov	cx, 0
mov	dx, 199
int	33h		; - MS MOUSE - DEFINE VERTICAL CURSOR RANGE
			; CX = minimum row, DX = maximum row
push	cs
call	near ptr MOUSE_WaitForButtonStatus ; Call Procedure

loc_240A0:
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 12
mov	cx, 1
mov	dx, offset Mouse_InterruptCallback
int	33h		; - MS MOUSE - DEFINE INTERRUPT	SUBROUTINE PARAMETERS
			; CX = call mask, ES:DX	-> FAR routine
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	[FLAG_Mouse_w360AC], 0
mov	[FLAG_Mouse_w360B4], 0
mov	ax, 0FFFFh
sti			; Set Interrupt	Flag
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp

locret_240CD:		; Return Far from Procedure
retf
endp MOUSE_SetupRangeRoutine




proc set_w360A2_1 far	; CODE XREF: idk_Mouse_s2B8B1:loc_2B8DFP
			; idk_Mouse_s2B8B1+74P
push	ds

loc_240CF:
mov	ax, seg	dseg
mov	ds, ax

loc_240D4:
mov	[w360A2], 1
pop	ds
retf			; Return Far from Procedure
endp set_w360A2_1




proc DOS_MouseReset far	; CODE XREF: EXIT_CleanUp+8P
			; idk_CleanupPrintExit_s14391+1EP
			; ST_execl_WizardsExe:loc_143F8P
			; sub_14489+DP
push	si
push	di
push	es
push	ds

loc_240E0:
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24119	; Jump if Zero (ZF=1)
push	cs
call	near ptr MOUSE_WaitForButtonStatus ; Call Procedure

loc_240F0:
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	[FLAG_Mouse_w360AC], 0
mov	[FLAG_Mouse_w360B4], 0
push	cs

loc_24103:		; Call Procedure
call	near ptr get__Mouse_w360A4
nop			; No Operation
mov	[word_360BA], ax
push	cs
call	near ptr get__Mouse_w360A6 ; Call Procedure
nop			; No Operation
mov	[word_360BC], ax
cli			; Clear	Interrupt Flag
mov	ax, 21h

loc_24116:		; - MS MOUSE - SOFTWARE	RESET
int	33h		; Return: AX = FFFFh if	mouse driver installed
			; AX = 0021h if	mouse driver not installed
			; BX = 2 if mouse driver is installed
sti			; Set Interrupt	Flag

loc_24119:		; CODE XREF: DOS_MouseReset+Ej
mov	[FLAG_MouseLeftHanded],	0
pop	ds
pop	es
pop	di
pop	si
retf			; Return Far from Procedure
endp DOS_MouseReset



; NOTE:	the mouse interupt subroutine is a callback, called with a far call.

proc MOUSE_ExchangeInterrupt far
			; CODE XREF: sub_24DAE:loc_254D2P
			; sub_27CC0:loc_27CE9P
			; sub_27CC0+156P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24154	; Jump if Zero (ZF=1)
cli			; Clear	Interrupt Flag

loc_24135:
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 14h
mov	cx, 1
mov	dx, 2BEh
int	33h		; - MS MOUSE - EXCHANGE	INTERRUPT SUBROUTINES
			; CX = call mask, ES:DX	-> FAR routine
			; Return: CX = call mask of previous interrupt routine
			; ES:DX	= FAR address of previous interrupt routine
mov	ax, 0FFFFh
mov	[FLAG_Set_FLAG_Mouse_Skip], 1

loc_2414E:
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag

loc_24154:		; CODE XREF: MOUSE_ExchangeInterrupt+Ej
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp MOUSE_ExchangeInterrupt




proc hrmMsExchIntSub far
			; CODE XREF: sub_24DAE:loc_24E03P
			; sub_24DAE+12AP
			; sub_24DAE:loc_24FBBP
			; sub_24DAE:loc_25260P
			; sub_24DAE:loc_253C4P
			; sub_24DAE+A52P
			; sub_24DAE:loc_2588DP
			; sub_24DAE:loc_25C26P
			; sub_24DAE+E8FP
			; sub_24DAE:loc_25C5CP
			; sub_24DAE:loc_25CD8P
			; sub_27CC0:loc_27E01P
			; sub_27CC0+171P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_24189	; Jump if Zero (ZF=1)
cli			; Clear	Interrupt Flag
mov	ax, seg	seg033
mov	es, ax
assume es:seg033
mov	ax, 14h
mov	cx, 101011b
mov	dx, offset Mouse_InterruptCallback
int	33h		; - MS MOUSE - EXCHANGE	INTERRUPT SUBROUTINES
			; CX = call mask, ES:DX	-> FAR routine
			; Return: CX = call mask of previous interrupt routine
			; ES:DX	= FAR address of previous interrupt routine
mov	ax, 0FFFFh
mov	[FLAG_Set_FLAG_Mouse_Skip], 1
mov	ax, 3
int	33h		; - MS MOUSE - RETURN POSITION AND BUTTON STATUS
			; Return: BX = button status, CX = column, DX =	row
sti			; Set Interrupt	Flag

loc_24189:		; CODE XREF: hrmMsExchIntSub+Ej
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp hrmMsExchIntSub



; Attributes: bp-based frame

proc Mouse_InterruptCallback far
			; DATA XREF: MOUSE_SetupRangeRoutine+73o
			; hrmMsExchIntSub+1Co

var_A= word ptr	-0Ah
var_8= word ptr	-8
var_6= word ptr	-6
var_4= word ptr	-4

push	bp
mov	bp, sp
sub	sp, 0Ah		; Integer Subtraction
cli			; Clear	Interrupt Flag
pushf			; Push Flags Register onto the Stack
push	ds
push	ax
cld			; Clear	Direction Flag
mov	ax, 31D1h
mov	ds, ax
mov	ax, cx
shr	ax, 1		; Shift	Logical	Right
mov	[idk_Mouse_w360A4], ax
mov	[idk_Mouse_w360A6], dx
cmp	[FLAG_Mouse_Skip], 0 ; Compare Two Operands
jz	short loc_241B3	; Jump if Zero (ZF=1)
jmp	loc_24266	; Jump

loc_241B3:		; CODE XREF: Mouse_InterruptCallback+20j
push	si
push	di
push	es
push	bx
push	cx
push	dx
mov	[FLAG_Mouse_Skip], 1
push	bx
push	dx
shr	cx, 1		; Shift	Logical	Right
push	cx
push	cs
call	near ptr sub_2460E ; Call Procedure
nop			; No Operation
add	sp, 6		; Add

loc_241CC:		; Compare Two Operands
cmp	[FLAG_Set_FLAG_Mouse_Skip], 0
jnz	short loc_241D6	; Jump if Not Zero (ZF=0)
jmp	loc_2425A	; Jump

loc_241D6:		; CODE XREF: Mouse_InterruptCallback+43j
mov	[FLAG_Set_FLAG_Mouse_Skip], 0
mov	bx, dx
mov	dx, 1111000100b
mov	ax, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
in	al, dx		; EGA port: sequencer data register
mov	[bp+var_4], ax
mov	dx, 3CEh
in	al, dx		; EGA: graph 1 and 2 addr reg:
			;
mov	[bp+var_A], ax
mov	ax, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
in	al, dx		; EGA port: graphics controller	data register

loc_241F7:
mov	[bp+var_6], ax
mov	dx, 3CEh
mov	ax, 8
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
in	al, dx		; EGA port: graphics controller	data register
mov	[bp+var_8], ax
mov	al, 0FFh
out	dx, al		; EGA port: graphics controller	data register
push	bx
push	cx
mov	ax, [idk_Mouse_w360A8]
cmp	ax, 2		; Compare Two Operands
jb	short loc_24217	; Jump if Below	(CF=1)
push	cs
call	near ptr idk_Mouse_s23F82 ; Call Procedure

loc_24217:		; CODE XREF: Mouse_InterruptCallback+83j
push	cs
call	near ptr idk_ChkMousDoEga ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_24648 ; Call Procedure
nop			; No Operation
push	cs
call	near ptr sub_24A74 ; Call Procedure
nop			; No Operation
add	sp, 4		; Add
mov	dx, 3C4h
mov	ax, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1
mov	ax, [bp+var_4]
out	dx, al		; EGA port: sequencer data register
mov	dx, 3CEh
mov	ax, 4
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1
mov	ax, [bp+var_6]
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3CEh
mov	ax, 8
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; bit mask
			; Bits 0-7 select bits to be masked in all planes
inc	dx		; Increment by 1
mov	ax, [bp+var_8]
out	dx, al		; EGA port: graphics controller	data register
mov	dx, 3CEh
mov	ax, [bp+var_A]
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; set/reset.
			; Data bits 0-3	select planes for write	mode 00
mov	[FLAG_Set_FLAG_Mouse_Skip], 1

loc_2425A:		; CODE XREF: Mouse_InterruptCallback+45j
pop	dx
pop	cx
pop	bx
pop	es
pop	di
pop	si
mov	[FLAG_Mouse_Skip], 0

loc_24266:		; CODE XREF: Mouse_InterruptCallback+22j
pop	ax
pop	ds
popf			; Pop Stack into Flags Register
sti			; Set Interrupt	Flag
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp Mouse_InterruptCallback



; FLAG_w360BE =	FLAG_w3609E, FLAG_w3609E = 0

proc Disable_Set_FLAG_Mouse_Skip far
			; CODE XREF: DOS_FindFirst+BP
			; NoXrefs_DosGetDtaFindFirst:loc_140E5P
			; ST_DosFindFile+BP
			; ST_ScreenDump:loc_1DB71P
			; sub_1E547+FP
			; sub_1E60D:loc_1E611P
			; TestKeyPress+3p
			; sub_24DAE:IS_KeyCode_146P
			; sub_24DAE+BDEP
			; rschKBD_s2669B:loc_2687EP
			; sub_27CC0:loc_27D2EP
			; sub_27CC0:loc_27DAFP
			; sub_27E4B+229P
			; sub_28141+72P
			; sub_2B470:loc_2B7FEP
			; sub_2E00A:loc_2E042P
			; sub_2E303+5P
push	ds		; FLAG_w3609E =	FLAG_w3609E; FLAG_w3609E = 0;
push	bx


mov	bx, seg	dseg
mov	ds, bx		; DS = DSEG
mov	bx, [FLAG_Set_FLAG_Mouse_Skip]
mov	[temp_Set_FLAG_Mouse_Skip], bx
sub	bx, bx		; BX = 0
mov	[FLAG_Set_FLAG_Mouse_Skip], bx


pop	bx
pop	ds
retf			; Return Far from Procedure
endp Disable_Set_FLAG_Mouse_Skip



; This seems like to be	some /global/ error checking.
; All references are FLAG_w360BE & FLAG_w3609E.
; FLAG_w360BE has 2 references - set & swap.
; FLAG_w3609E has 10 references.
; NOTE(JWB)(2020-09-05): Also, may a lock flag.
; NOTE(JWB)(2020-12-19):
; ST_DOS_FindFile sets this to
; 0 on failure,	-1 on success
;

proc Restore_Set_FLAG_Mouse_Skip far
			; CODE XREF: DOS_FindFirst:loc_140B3P
			; DOS_FindFirst+59P
			; NoXrefs_DosGetDtaFindFirst+3FP
			; ST_DosFindFile+58P
			; ST_DosFindFile+72P
			; ST_ScreenDump+3F3P
			; sub_1E547:loc_1E600P
			; sub_1E60D+45P
			; TestKeyPress+10p
			; TestKeyPress+1Ap
			; sub_24DAE+B8P
			; sub_24DAE+C1DP
			; rschKBD_s2669B:loc_26970P
			; sub_27CC0+B6P
			; sub_27CC0+137P
			; sub_27E4B:loc_28105P
			; sub_28141+40EP
			; sub_2B470+416P
			; sub_2E00A:loc_2E195P
			; sub_2E303:loc_2E349P
push	ds
push	bx
mov	bx, seg	dseg	; make sure DS points to the Data Segment, as it should
mov	ds, bx
mov	bx, [temp_Set_FLAG_Mouse_Skip]
mov	[FLAG_Set_FLAG_Mouse_Skip], bx
pop	bx
pop	ds
retf			; Return Far from Procedure
endp Restore_Set_FLAG_Mouse_Skip

off_24298 dd 31D1B81Eh
mov	ds, ax

loc_2429E:
mov	ax, [FLAG_MouseLeftHanded]
cmp	ax, 0		; Compare Two Operands
jz	short loc_242A8	; Jump if Zero (ZF=1)
pop	ds
retf			; Return Far from Procedure

loc_242A8:		; CODE XREF: seg033:03D4j
mov	ax, [w360A2]
pop	ds
retf			; Return Far from Procedure



proc TestKeyPress far	; CODE XREF: idk_CheckInputOrSleep_s13F7E:loc_13F8CP
			; sub_24DAE+36P
			; sub_26026+62P
			; o_1_a_87_s_0_tpsig2_84P
			; sub_27C84:loc_27C94P
			; sub_27CC0:loc_27D06P
			; sub_27CC0:loc_27D87P
			; sub_28141:loc_282E2P
			; sub_28583:loc_286C5P
push	ds
push	es
push	cs
call	near ptr Disable_Set_FLAG_Mouse_Skip ; FLAG_w360BE = FLAG_w3609E, FLAG_w3609E =	0
mov	ah, 11h
int	16h		; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model	339,XT2,XT286,PS)
			; Return: ZF clear if keystroke	available
			; AH = scan code \ meaningless if ZF = 1
			; AL = character /
			; ZF set if kbd	buffer empty

loc_242B7:		; Jump if Zero (ZF=1)
jz	short noKeyPress

yesKeyPress:
mov	ax, 1
push	cs
call	near ptr Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	es
pop	ds
retf			; Return Far from Procedure

noKeyPress:		; CODE XREF: TestKeyPress:loc_242B7j
mov	ax, 0
push	cs
call	near ptr Restore_Set_FLAG_Mouse_Skip ; FLAG_w3609E = FLAG_w360BE
pop	es
pop	ds
retf			; Return Far from Procedure
endp TestKeyPress



; https://sites.google.com/site/pcdosretro/scancodes
; Is there a specifc set of codes they used?
; What's Borland's position?

proc ST_GetKeyboardCode	far
			; CODE XREF: rschKBD_s2669B+BP
			; o_1_a_87_s_0_tpsig2_84+9P
			; sub_27C84:loc_27C8FP
			; sub_27CC0+4FP
			; sub_27CC0+D0P
			; sub_28141:loc_28303P
			; sub_28583:loc_286E6P
push	es
push	ds
mov	ah, 10h
int	16h		; KEYBOARD - GET ENHANCED KEYSTROKE (AT	model 339,XT2,XT286,PS)
			; Return: AH = scan code, AL = character
cmp	ax, 11Bh	; Escape
			;	01	 1B
			; 00000001 00011011
			;	 1	 27
			;
jnz	short loc_242DE	; Jump if Not Zero (ZF=0)
mov	ax, 27
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242DE:		; CODE XREF: ST_GetKeyboardCode+9j
cmp	ax, 4BE0h	; Keypad 4 / Left Arrow
			;	4B	 E0
			; 01001011 11100000
			;	75	224
			;
jnz	short loc_242E9	; Jump if Not Zero (ZF=0)
mov	ax, 1
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242E9:		; CODE XREF: ST_GetKeyboardCode+14j
cmp	ax, 4DE0h	; Keypad 6 / Right Arrow
jnz	short loc_242F4	; Jump if Not Zero (ZF=0)
mov	ax, 2
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242F4:		; CODE XREF: ST_GetKeyboardCode+1Fj
cmp	ax, 48E0h	; Keypad 8 / Up	Arrow
jnz	short loc_242FF	; Jump if Not Zero (ZF=0)
mov	ax, 3
pop	ds
pop	es
retf			; Return Far from Procedure

loc_242FF:		; CODE XREF: ST_GetKeyboardCode+2Aj
cmp	ax, 50E0h	; Keypad 2 / Down Arrow
jnz	short loc_2430A	; Jump if Not Zero (ZF=0)
mov	ax, 4
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2430A:		; CODE XREF: ST_GetKeyboardCode+35j
cmp	ax, 49E0h	; Keypad 9 / Page Up
jnz	short loc_24315	; Jump if Not Zero (ZF=0)
mov	ax, 5
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24315:		; CODE XREF: ST_GetKeyboardCode+40j
cmp	ax, 51E0h	; Keypad 3 / Page Down
jnz	short loc_24320	; Jump if Not Zero (ZF=0)
mov	ax, 6
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24320:		; CODE XREF: ST_GetKeyboardCode+4Bj
cmp	ax, 47E0h	; Keypad 7 / Home
jnz	short loc_2432B	; Jump if Not Zero (ZF=0)
mov	ax, 7
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2432B:		; CODE XREF: ST_GetKeyboardCode+56j
cmp	ax, 4FE0h	; Keypad 1 / End
jnz	short loc_24336	; Jump if Not Zero (ZF=0)
mov	ax, 8
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24336:		; CODE XREF: ST_GetKeyboardCode+61j
cmp	ax, 52E0h	; Keypad 0 / Insert
jnz	short loc_24341	; Jump if Not Zero (ZF=0)

loc_2433B:
mov	ax, 9

loc_2433E:
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24341:		; CODE XREF: ST_GetKeyboardCode+6Cj
cmp	ax, 53E0h	; Delete
			; Keypad . / Delete
jnz	short loc_2434C	; Jump if Not Zero (ZF=0)
mov	ax, 10
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2434C:		; CODE XREF: ST_GetKeyboardCode+77j
cmp	ax, 0E08h	; Backspace
			;	0E	 08
			; 00001110 00001000
			;	14	  8
			;
jnz	short loc_24357	; Jump if Not Zero (ZF=0)
mov	ax, 11
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24357:		; CODE XREF: ST_GetKeyboardCode+82j
cmp	ax, 1C0Dh	; Enter
jnz	short loc_24362	; Jump if Not Zero (ZF=0)
mov	ax, 12
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24362:		; CODE XREF: ST_GetKeyboardCode+8Dj
cmp	ax, 0F09h	; Tab
jnz	short loc_2436D	; Jump if Not Zero (ZF=0)
mov	ax, 13
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2436D:		; CODE XREF: ST_GetKeyboardCode+98j
cmp	ax, 3B00h	; F1 (Program Function Key 1)
jnz	short loc_24378	; Jump if Not Zero (ZF=0)
mov	ax, 14
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24378:		; CODE XREF: ST_GetKeyboardCode+A3j
cmp	ax, 3C00h	; F2 (Program Function Key 2)
jnz	short loc_24383	; Jump if Not Zero (ZF=0)
mov	ax, 15
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24383:		; CODE XREF: ST_GetKeyboardCode+AEj
cmp	ax, 3D00h	; F3 (Program Function Key 3)
jnz	short loc_2438E	; Jump if Not Zero (ZF=0)
mov	ax, 16
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2438E:		; CODE XREF: ST_GetKeyboardCode+B9j
cmp	ax, 3E00h	; F4 (Program Function Key 4)
jnz	short loc_24399	; Jump if Not Zero (ZF=0)
mov	ax, 17
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24399:		; CODE XREF: ST_GetKeyboardCode+C4j
cmp	ax, 3F00h	; F5 (Program Function Key 5)
jnz	short loc_243A4	; Jump if Not Zero (ZF=0)
mov	ax, 18
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243A4:		; CODE XREF: ST_GetKeyboardCode+CFj
cmp	ax, 4000h	; F6 (Program Function Key 6)
jnz	short loc_243AF	; Jump if Not Zero (ZF=0)
mov	ax, 19
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243AF:		; CODE XREF: ST_GetKeyboardCode+DAj
cmp	ax, 4100h	; F7 (Program Function Key 7)
jnz	short loc_243BA	; Jump if Not Zero (ZF=0)
mov	ax, 20
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243BA:		; CODE XREF: ST_GetKeyboardCode+E5j
cmp	ax, 4200h	; F8 (Program Function Key 8)
jnz	short loc_243C5	; Jump if Not Zero (ZF=0)
mov	ax, 21
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243C5:		; CODE XREF: ST_GetKeyboardCode+F0j
cmp	ax, 4300h	; F9 (Program Function Key 9)
jnz	short loc_243D0	; Jump if Not Zero (ZF=0)
mov	ax, 22
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243D0:		; CODE XREF: ST_GetKeyboardCode+FBj
cmp	ax, 4400h	; F10 (Program Function	Key 10)
jnz	short loc_243DB	; Jump if Not Zero (ZF=0)
mov	ax, 23
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243DB:		; CODE XREF: ST_GetKeyboardCode+106j
cmp	ah, 47h		; Home
jnz	short loc_243E6	; Jump if Not Zero (ZF=0)
mov	ax, 26
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243E6:		; CODE XREF: ST_GetKeyboardCode+111j
cmp	ah, 49h		; Page Up
jnz	short loc_243F1	; Jump if Not Zero (ZF=0)
mov	ax, 25
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243F1:		; CODE XREF: ST_GetKeyboardCode+11Cj
cmp	ah, 4Fh		; End
jnz	short loc_243FC	; Jump if Not Zero (ZF=0)
mov	ax, 28
pop	ds
pop	es
retf			; Return Far from Procedure

loc_243FC:		; CODE XREF: ST_GetKeyboardCode+127j
cmp	ah, 51h		; Page Down
jnz	short loc_24407	; Jump if Not Zero (ZF=0)
mov	ax, 29
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24407:		; CODE XREF: ST_GetKeyboardCode+132j
cmp	ah, 48h		; Up Arrow
jnz	short loc_24412	; Jump if Not Zero (ZF=0)
mov	ax, 3
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24412:		; CODE XREF: ST_GetKeyboardCode+13Dj
cmp	ah, 50h		; Down Arrow
jnz	short loc_2441D	; Jump if Not Zero (ZF=0)
mov	ax, 4
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2441D:		; CODE XREF: ST_GetKeyboardCode+148j
cmp	ah, 4Bh		; Left Arrow
jnz	short loc_24428	; Jump if Not Zero (ZF=0)
mov	ax, 1
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24428:		; CODE XREF: ST_GetKeyboardCode+153j
cmp	ah, 4Dh		; Right	Arrow
jnz	short loc_24433	; Jump if Not Zero (ZF=0)
mov	ax, 2
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24433:		; CODE XREF: ST_GetKeyboardCode+15Ej
cmp	ah, 4Eh		; ? Alternate -	Plus ?
jnz	short loc_2443E	; Jump if Not Zero (ZF=0)
mov	ax, 43
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2443E:		; CODE XREF: ST_GetKeyboardCode+169j
cmp	ah, 4Ah		; ? Alternate -	Minus ?
jnz	short loc_24449	; Jump if Not Zero (ZF=0)
mov	ax, 45
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24449:		; CODE XREF: ST_GetKeyboardCode+174j
cmp	ah, 4Ch		; Numpad 5 / Center
jnz	short loc_24454	; Jump if Not Zero (ZF=0)
mov	ax, 30
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24454:		; CODE XREF: ST_GetKeyboardCode+17Fj
cmp	ax, 74E0h	; ? Control - Right Arrow ?
jnz	short loc_2445F	; Jump if Not Zero (ZF=0)
mov	ax, 128
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2445F:		; CODE XREF: ST_GetKeyboardCode+18Aj
cmp	ax, 73E0h	; ? Control - Left Arrow ?
jnz	short loc_2446A	; Jump if Not Zero (ZF=0)
mov	ax, 129
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2446A:		; CODE XREF: ST_GetKeyboardCode+195j
cmp	ax, 8DE0h	; ? Control - Up Arrow ?
jnz	short loc_24475	; Jump if Not Zero (ZF=0)
mov	ax, 130
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24475:		; CODE XREF: ST_GetKeyboardCode+1A0j
cmp	ax, 91E0h	; ? Control - Down Arrow ?
jnz	short loc_24480	; Jump if Not Zero (ZF=0)
mov	ax, 131
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24480:		; CODE XREF: ST_GetKeyboardCode+1ABj
cmp	ax, 7400h	; ? Control - Right Arrow ?
jnz	short loc_2448B	; Jump if Not Zero (ZF=0)
mov	ax, 128
pop	ds
pop	es
retf			; Return Far from Procedure

loc_2448B:		; CODE XREF: ST_GetKeyboardCode+1B6j
cmp	ax, 7300h	; ? Control - Left Arrow ?
jnz	short loc_24496	; Jump if Not Zero (ZF=0)
mov	ax, 129
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24496:		; CODE XREF: ST_GetKeyboardCode+1C1j
cmp	ax, 8D00h	; ? Control - Up Arrow ?

loc_24499:		; Jump if Not Zero (ZF=0)
jnz	short loc_244A1

loc_2449B:
mov	ax, 130
pop	ds
pop	es

locret_244A0:		; Return Far from Procedure
retf

loc_244A1:		; CODE XREF: ST_GetKeyboardCode:loc_24499j
cmp	ax, 9100h	; ? Control - Down Arrow ?

loc_244A4:		; Jump if Not Zero (ZF=0)
jnz	short loc_244AC
mov	ax, 131
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244AC:		; CODE XREF: ST_GetKeyboardCode:loc_244A4j
cmp	ax, 7700h	; ? Home ?
jnz	short loc_244B7	; Jump if Not Zero (ZF=0)
mov	ax, 132
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244B7:		; CODE XREF: ST_GetKeyboardCode+1E2j
cmp	ax, 8400h	; ? Control - Page Up ?
jnz	short loc_244C2	; Jump if Not Zero (ZF=0)
mov	ax, 133

loc_244BF:
pop	ds

loc_244C0:
pop	es
retf			; Return Far from Procedure

loc_244C2:		; CODE XREF: ST_GetKeyboardCode+1EDj
cmp	ax, 7500h	; ? Control - End ?
jnz	short loc_244CD	; Jump if Not Zero (ZF=0)
mov	ax, 134
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244CD:		; CODE XREF: ST_GetKeyboardCode+1F8j
cmp	ax, 7600h	; ? Control - Page Down	?
jnz	short loc_244D8	; Jump if Not Zero (ZF=0)
mov	ax, 135
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244D8:		; CODE XREF: ST_GetKeyboardCode+203j
cmp	ax, 92Ah	; ? Shift 8 / *	?
jnz	short loc_244E2	; Jump if Not Zero (ZF=0)
sub	ax, ax		; 0
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244E2:		; CODE XREF: ST_GetKeyboardCode+20Ej
cmp	ax, 0E00Dh	; ? Alternate -	Backspace ?
jnz	short loc_244ED	; Jump if Not Zero (ZF=0)
mov	ax, 12
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244ED:		; CODE XREF: ST_GetKeyboardCode+218j
cmp	ax, 1F13h	; ? Control - s	?
jnz	short loc_244F8	; Jump if Not Zero (ZF=0)
mov	ax, 144
pop	ds
pop	es
retf			; Return Far from Procedure

loc_244F8:		; CODE XREF: ST_GetKeyboardCode+223j
cmp	ax, 8500h	; F11 (Program Function	Key 11)
			;	85	 00
			; 10000101 00000000
			;      133	  0
			;
jnz	short loc_24503	; Jump if Not Zero (ZF=0)
mov	ax, 145
pop	ds
pop	es
retf			; Return Far from Procedure

loc_24503:		; CODE XREF: ST_GetKeyboardCode+22Ej
cmp	ax, 8600h	; F12 (Program Function	Key 12)
jnz	short loc_2450B	; Jump if Not Zero (ZF=0)
mov	ax, 146

loc_2450B:		; CODE XREF: ST_GetKeyboardCode+239j
mov	bx, 6
mov	dx, 106
add	dx, 4		; Add

loc_24514:		; CODE XREF: ST_GetKeyboardCode+255j
mov	cx, [cs:bx]	; WTF -	Why can	I not understand these?
			;
cmp	ax, cx		; CX - AX
jz	short loc_24524	; Jump if Zero (ZF=1)
add	bx, 4		; Add
cmp	bx, dx		; Meaning it's only going to try this
			; ((106	+ 4) - 6) / 4 =	26 times?
			;
jz	short loc_24529	; Jump if Zero (ZF=1)
jmp	short loc_24514	; Jump

loc_24524:		; CODE XREF: ST_GetKeyboardCode+24Cj
inc	bx		; Increment by 1
inc	bx		; Increment by 1
mov	ax, [cs:bx]

loc_24529:		; CODE XREF: ST_GetKeyboardCode+253j
pop	ds
pop	es
retf			; Return Far from Procedure
endp ST_GetKeyboardCode




proc get__Mouse_w360A4 far
			; CODE XREF: ILSe_MAINMENU_screen+39DP
			; sub_1E547:loc_1E55BP
			; sub_1E547:loc_1E5BAP
			; DOS_MouseReset:loc_24103p
			; sub_24DAE+1EP
			; sub_24DAE+85P
			; sub_24DAE+98P
			; sub_24DAE+ABP
			; sub_24DAE:loc_258F2P
			; sub_25EA0+DP
			; sub_26026+9CP
			; sub_26026+AFP
			; sub_26026+C2P
			; sub_26026:loc_26680P
			; sub_27A2B+8P
			; sub_27AFB+7P
			; sub_27AFB:loc_27BE2P
			; sub_27CC0+83P
			; sub_27CC0+96P
			; sub_27CC0+A9P
			; sub_27CC0+104P
			; sub_27CC0+117P
			; sub_27CC0+12AP
			; sub_27E4B+91P
			; sub_2A235+48P
			; sub_2B470+375P
			; sub_2CF44:loc_2DD95P
			; sub_2E00A+75P
			; sub_2E00A+15BP
			; sub_2E303+AP
push	ds
mov	ax, seg	dseg

loc_24530:
mov	ds, ax
mov	ax, [idk_Mouse_w360A4]
pop	ds
retf			; Return Far from Procedure
endp get__Mouse_w360A4




proc get__Mouse_w360A6 far
			; CODE XREF: ILSe_MAINMENU_screen+397P
			; sub_1E547:loc_1E563P
			; sub_1E547+6DP
			; DOS_MouseReset+2Fp
			; sub_24DAE+26P
			; sub_24DAE+7FP
			; sub_24DAE+92P
			; sub_24DAE+A5P
			; sub_24DAE+B4CP
			; sub_25EA0+15P
			; sub_26026+96P
			; sub_26026+A9P
			; sub_26026+BCP
			; sub_26026+662P
			; sub_27A2B+FP
			; sub_27AFB+FP
			; sub_27AFB+127P
			; sub_27CC0+7DP
			; sub_27CC0+90P
			; sub_27CC0+A3P
			; sub_27CC0+FEP
			; sub_27CC0+111P
			; sub_27CC0+124P
			; sub_27E4B+99P
			; sub_2A235+136P
			; sub_2B470+380P
			; sub_2CF44+E91P
			; sub_2E00A+7CP
			; sub_2E00A+162P
			; sub_2E303+11P
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w360A6]
pop	ds
retf			; Return Far from Procedure
endp get__Mouse_w360A6



; Attributes: bp-based frame

proc CALL_PositionMouseCursor far
			; CODE XREF: sub_1E547+9EP
			; sub_24D35:loc_24D85p
			; sub_24DAE+B1P
			; sub_24DAE:loc_259C4P
			; sub_26026+C8P
			; rschKBD_s2669B+2ABP
			; sub_27913:loc_279FBP
			; sub_27CC0+AFP
			; sub_27CC0+130P
			; sub_27E4B+2A2P
			; sub_2B470+3E9P
			; idk_Mouse_s2B8B1+4DP
			; idk_Mouse_s2B8B1+8DP
			; sub_2E00A+9EP
			; sub_2E00A+184P
			; sub_2E00A+1D0P

arg0_Column= word ptr  6
arg2_Row= word ptr  8

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg0_Column]
mov	[idk_Mouse_w360A4], ax
mov	ax, [bp+arg2_Row]
mov	[idk_Mouse_w360A6], ax
cmp	[FLAG_MouseLeftHanded],	0 ; Compare Two	Operands
jz	short loc_2456A	; Jump if Zero (ZF=1)
push	ax		; arg2_Row
push	[bp+arg0_Column] ; arg0_Column
push	cs
call	near ptr DOS_PositionMouseCursor ; Call	Procedure
nop			; No Operation
add	sp, 4		; Add

loc_2456A:		; CODE XREF: CALL_PositionMouseCursor+1Aj
pop	ds
pop	bp
retf			; Return Far from Procedure
endp CALL_PositionMouseCursor ;	sp-analysis failed



; Attributes: bp-based frame

; int __cdecl __far DOS_PositionMouseCursor(int	arg0_Column, int arg2_Row)
proc DOS_PositionMouseCursor far
			; CODE XREF: CALL_PositionMouseCursor+21p

arg0_Column= word ptr  6
arg2_Row= word ptr  8

push	bp
mov	bp, sp
push	ds
mov	cx, [bp+arg0_Column]
shl	cx, 1		; Shift	Logical	Left
mov	dx, [bp+arg2_Row]
mov	ax, 4
cli			; Clear	Interrupt Flag
int	33h		; DOS -	MS MOUSE - POSITION MOUSE CURSOR
			; CX = column, DX = row
sti			; Set Interrupt	Flag
pop	ds
pop	bp
retf			; Return Far from Procedure
endp DOS_PositionMouseCursor




proc idk_Get_Mouse_w360AE far
			; CODE XREF: sub_24DAE:MouseStatusIsRightButtonP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idk_Mouse_w360AE]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360AE




proc idk_Get_Mouse_w360B0 far
			; CODE XREF: sub_24DAE:loc_2552FP
push	ds
mov	ax, seg	dseg
mov	ds, ax

loc_24594:
mov	ax, [idk_Mouse_w360B0]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360B0




proc idk_Get_Mouse_w360B2 far
			; CODE XREF: sub_24DAE:loc_254F2P
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [idkMouse_w360B2]
pop	ds
retf			; Return Far from Procedure
endp idk_Get_Mouse_w360B2




proc get_w360AC_set0 far ; CODE	XREF: sub_24D35+4Cp
			; sub_24DAE:loc_254E3P
			; sub_24DAE:loc_2551AP
			; sub_24DAE:loc_258C7P
			; sub_24DAE:loc_25BB9P
			; sub_27C84+30P
			; sub_27CC0+37P
			; sub_27CC0:loc_27D7DP
			; sub_27CC0+176P
			; sub_28141+16DP
			; sub_28583+24P
			; sub_28583+10EP
			; sub_28583+39EP
			; sub_2A755+A7BP
			; sub_2B1F9+24EP
			; sub_2B9C4+9P
push	ds
mov	ax, seg	dseg

loc_245A8:
mov	ds, ax
mov	ax, [FLAG_Mouse_w360AC]
sub	bx, bx		; Integer Subtraction
mov	[FLAG_Mouse_w360AC], bx
pop	ds
retf			; Return Far from Procedure
endp get_w360AC_set0




; int __cdecl __far get_w360B4_set0()
proc get_w360B4_set0 far
			; CODE XREF: idk_CheckInputOrSleep_s13F7E+25P
			; sub_24DAE+771P
			; sub_24DAE+9D5P
			; sub_24DAE:loc_258CCP
			; sub_24DAE+E10P
			; sub_27C84+35P
			; sub_27CC0+17BP
			; sub_28583+29P
			; sub_28583:loc_28926P
			; sub_2A755+A80P
			; sub_2B1F9+253P
			; sub_2B9C4+EP
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [FLAG_Mouse_w360B4]
sub	bx, bx		; Integer Subtraction
mov	[FLAG_Mouse_w360B4], bx
pop	ds
retf			; Return Far from Procedure
endp get_w360B4_set0



; Attributes: bp-based frame

proc sub_245C6 far	; CODE XREF: sub_24DAE:loc_259DCP

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	[FLAG_Mouse_w360B4], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_245C6



; Attributes: bp-based frame

proc sub_245E4 far	; CODE XREF: sub_24D35+43p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp
mov	bp, sp
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	[FLAG_Mouse_w360B4], 1
mov	[FLAG_Mouse_w360AC], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
mov	ax, [bp+arg_4]
mov	[idkMouse_w360B2], ax
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_245E4



; Attributes: bp-based frame

proc sub_2460E far	; CODE XREF: Mouse_InterruptCallback+37p

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

push	bp

loc_2460F:
mov	bp, sp
push	ds
push	ds

loc_24613:
mov	ax, seg	dseg
mov	ds, ax
mov	ax, [bp+arg_4]
and	ax, 11b		; Logical AND
cmp	ax, 0		; Compare Two Operands
jnz	short loc_24627	; Jump if Not Zero (ZF=0)
pop	ds
pop	ds
pop	bp
retf			; Return Far from Procedure

loc_24627:		; CODE XREF: sub_2460E+13j
mov	[idkMouse_w360B2], ax

loc_2462A:
mov	[FLAG_Mouse_w360AC], 1
mov	[FLAG_Mouse_w360B4], 1
mov	ax, [bp+arg_0]
mov	[idk_Mouse_w360AE], ax
mov	ax, [bp+arg_2]
mov	[idk_Mouse_w360B0], ax
sub	ax, ax		; Integer Subtraction

loc_24644:
pop	ds
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_2460E



; Attributes: bp-based frame

proc sub_24648 far	; CODE XREF: ILSe_MAINMENU_screen+3A3P
			; sub_1E547:loc_1E5D6P
			; Mouse_InterruptCallback+8Fp
			; sub_24D35:loc_24D99p
			; sub_24DAE+8BP
			; sub_24DAE+BFCP
			; sub_26026+21P
			; sub_26026+A2P
			; rschKBD_s2669B+2BFP
			; sub_27913+FCP
			; sub_27CC0+89P
			; sub_27CC0+10AP
			; sub_27E4B:loc_280CFP
			; sub_2B470+3CBP
			; sub_2E00A+88P
			; sub_2E00A+16EP
			; sub_2E00A+1BAP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_43AC= word ptr  43B2h

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609A], 0 ;	Compare	Two Operands
jnz	short loc_24673	; Jump if Not Zero (ZF=0)
cmp	[word_360B8], 0	; Compare Two Operands
jz	short loc_2466D	; Jump if Zero (ZF=1)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_2466D:		; CODE XREF: sub_24648+1Bj
mov	[word_360B8], 1

loc_24673:		; CODE XREF: sub_24648+14j
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si
mov	bx, 3
add	ax, bx		; Add
sub	ax, 50h	; 'P'   ; Integer Subtraction
js	short loc_2469C	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2469C:		; CODE XREF: sub_24648+50j
mov	ax, [bp+arg_2]

loc_2469F:
mov	cx, 50h	; 'P'
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+43B2h], si
add	di, 2		; Add
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_6], bl

loc_246BB:
mov	ax, [bp+arg_2]
mov	bx, 10h
add	ax, bx		; Add
sub	ax, 0C8h ; 'È'  ; Integer Subtraction
js	short loc_246CA	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_246CA:		; CODE XREF: sub_24648+7Ej
mov	[es:di+43B2h], bx

loc_246CF:		; Add
add	di, 2
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_246E1:		; CODE XREF: sub_24648+C9j
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_246E6:		; CODE XREF: sub_24648+BFj
mov	cx, [bp+var_4]

loc_246E9:		; CODE XREF: sub_24648+ADj
lodsw			; Load String
mov	[es:di+43B2h], ax
add	di, 2		; Add
add	si, 4Eh	; 'N'   ; Add
loop	loc_246E9	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_246E6	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]
cmp	bl, 4		; Compare Two Operands
jnz	short loc_246E1	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_24648



; Attributes: bp-based frame

proc sub_2471B far	; CODE XREF: sub_2E303+27P

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds

loc_24725:
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609A], 0 ;	Compare	Two Operands
jnz	short loc_2474D	; Jump if Not Zero (ZF=0)
cmp	[idk_Mouse_w3609C], 0 ;	Compare	Two Operands
jnz	short loc_2474D	; Jump if Not Zero (ZF=0)
cmp	[word_360B8], 0	; Compare Two Operands
jz	short loc_24747	; Jump if Zero (ZF=1)
pop	ds

loc_24740:
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24747:		; CODE XREF: sub_2471B+22j
mov	[word_360B8], 1

loc_2474D:		; CODE XREF: sub_2471B+14j
			; sub_2471B+1Bj
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si

loc_2476E:
mov	bx, 3
add	ax, bx		; Add
sub	ax, 50h	; 'P'   ; Integer Subtraction
js	short loc_2477A	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2477A:		; CODE XREF: sub_2471B+5Bj
mov	ax, [bp+arg_2]
mov	cx, 50h	; 'P'
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+4862h], si
add	di, 2		; Add
mov	[es:di+4862h], bx
add	di, 2		; Add
mov	[bp+var_6], bl
mov	ax, [bp+arg_2]
mov	bx, 10h
add	ax, bx		; Add
sub	ax, 0C8h ; 'È'  ; Integer Subtraction
js	short loc_247A8	; Jump if Sign (SF=1)

loc_247A6:		; Integer Subtraction
sub	bx, ax

loc_247A8:		; CODE XREF: sub_2471B+89j
mov	[es:di+4862h], bx
add	di, 2		; Add
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, 3CEh
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_247BF:		; CODE XREF: sub_2471B+D4j
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_247C4:		; CODE XREF: sub_2471B+CAj
mov	cx, [bp+var_4]

loc_247C7:		; CODE XREF: sub_2471B+B8j
lodsw			; Load String
mov	[es:di+4862h], ax
add	di, 2		; Add

loc_247D0:		; Add
add	si, 4Eh	; 'N'
loop	loc_247C7	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_247C4	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]

loc_247EC:		; Compare Two Operands
cmp	bl, 4
jnz	short loc_247BF	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2471B



; Attributes: bp-based frame

proc idk_VGA_s247F9 far	; CODE XREF: idk_Mouse_s2B8B1+AAP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	ax, ds
mov	es, ax
assume es:dseg
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, VIDEO_RAM	; Add
mov	ds, ax
mov	si, [bp+arg_0]
shr	si, 1		; Shift	Logical	Right
shr	si, 1		; Shift	Logical	Right
mov	ax, si
mov	bx, 3
add	ax, bx		; Add
sub	ax, 80		; Integer Subtraction
js	short loc_24831	; Jump if Sign (SF=1)

loc_2482F:		; Integer Subtraction
sub	bx, ax

loc_24831:		; CODE XREF: idk_VGA_s247F9+34j
mov	ax, [bp+arg_2]
mov	cx, 80
mul	cx		; Unsigned Multiplication of AL	or AX
add	si, ax		; Add
sub	di, di		; Integer Subtraction
mov	[es:di+43B2h], si
add	di, 2		; Add
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_6], bl
mov	ax, [bp+arg_2]
mov	bx, 16
add	ax, bx		; Add
sub	ax, 200		; Integer Subtraction
js	short loc_2485F	; Jump if Sign (SF=1)
sub	bx, ax		; Integer Subtraction

loc_2485F:		; CODE XREF: idk_VGA_s247F9+62j
mov	[es:di+43B2h], bx
add	di, 2		; Add
mov	[bp+var_4], bx
mov	[bp+var_2], si
sub	bl, bl		; Integer Subtraction
mov	al, 4
mov	dx, GC_INDEX
out	dx, al		; EGA: graph 1 and 2 addr reg:
			; read map select.
			; Data bits 0-2	select map # for read mode 00.
inc	dx		; Increment by 1

loc_24876:		; CODE XREF: idk_VGA_s247F9+ADj
mov	al, bl
out	dx, al		; EGA port: graphics controller	data register
sub	bh, bh		; Integer Subtraction

loc_2487B:		; CODE XREF: idk_VGA_s247F9+A3j
mov	cx, [bp+var_4]

loc_2487E:		; CODE XREF: idk_VGA_s247F9+91j
lodsw			; Load String
mov	[es:di+43B2h], ax
add	di, 2		; Add
add	si, 78		; Add
loop	loc_2487E	; Loop while CX	!= 0
mov	si, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	si, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_2487B	; Jump if Not Zero (ZF=0)
inc	bl		; Increment by 1
mov	si, [bp+var_2]
cmp	bl, 4		; Compare Two Operands
jnz	short loc_24876	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_VGA_s247F9




proc idk_Dseg_RepMovSw far
			; CODE XREF: sub_2E303:loc_2E344P
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	es, ax
assume es:dseg
mov	di, offset idk_Dseg_RepMovSw_DI
mov	si, offset idk_Dseg_RepMovSw_SI
mov	cx, offset idk_Dseg_RepMovSw_CX
rep movsw		; Move Byte(s) from String to String
pop	ds
pop	es
assume es:nothing
pop	di
pop	si
retf			; Return Far from Procedure
endp idk_Dseg_RepMovSw



; Attributes: bp-based frame

proc idk_ChkMousDoEga far ; CODE XREF: sub_1E547+8AP
			; Mouse_InterruptCallback+8Ap
			; sub_24D35:loc_24D95p
			; sub_24DAE+75P
			; sub_24DAE:loc_25991P
			; sub_26026+14P
			; sub_26026+8CP
			; rschKBD_s2669B+2B2P
			; sub_27913+EFP
			; sub_27CC0+73P
			; sub_27CC0+F4P
			; sub_27E4B+277P
			; sub_28141:loc_2854AP
			; sub_2B470+3BEP
			; sub_2E00A+4DP
			; sub_2E00A:loc_2E0BBP
			; sub_2E00A:loc_2E19CP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax

loc_248DA:		; Compare Two Operands
cmp	[idk_Mouse_w3609C], 0

loc_248DF:		; Jump if Not Zero (ZF=0)
jnz	short loc_248E9
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_248E9:		; CODE XREF: idk_ChkMousDoEga:loc_248DFj
sub	si, si		; Integer Subtraction
mov	di, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_6], al
mov	ax, [si+43B2h]
add	si, 2		; Add
mov	[bp+var_4], ax
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
sub	al, al		; Integer Subtraction
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
mov	es, ax
mov	bl, 1
mov	dx, 964
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_24922:		; CODE XREF: idk_ChkMousDoEga+86j
mov	al, bl
out	dx, al		; EGA port: sequencer data register
sub	bh, bh		; Integer Subtraction

loc_24927:		; CODE XREF: idk_ChkMousDoEga+7Cj
mov	cx, [bp+var_4]

loc_2492A:		; CODE XREF: idk_ChkMousDoEga+6Aj
mov	ax, [si+43B2h]
stosw			; Store	String
add	si, 2		; Add
add	di, 78		; Add
loop	loc_2492A	; Loop while CX	!= 0
mov	di, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_24927	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left
mov	di, [bp+var_2]
cmp	bl, 16		; Compare Two Operands
jnz	short loc_24922	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp idk_ChkMousDoEga



; Attributes: bp-based frame

proc sub_2495B far	; CODE XREF: sub_1E547:loc_1E5AFP
			; sub_1E547+B4P
			; sub_2E303:loc_2E33FP

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

push	bp

loc_2495C:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
cmp	[idk_Mouse_w3609C], 0 ;	Compare	Two Operands
jnz	short loc_24979	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24979:		; CODE XREF: sub_2495B+14j
mov	ax, 1

loc_2497C:		; Integer Subtraction
sub	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left

loc_24988:		; Add
add	ax, VIDEO_RAM
mov	es, ax
sub	si, si		; Integer Subtraction
mov	di, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_6], al
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_4], ax
mov	bl, 1
mov	dx, 964
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
inc	dx		; Increment by 1

loc_249B6:		; CODE XREF: sub_2495B+8Aj
mov	al, bl
out	dx, al		; EGA port: sequencer data register

loc_249B9:		; Integer Subtraction
sub	bh, bh

loc_249BB:		; CODE XREF: sub_2495B+80j
mov	cx, [bp+var_4]

loc_249BE:		; CODE XREF: sub_2495B+6Ej
mov	ax, [idk_Dseg_RepMovSw_DI+si]
stosw			; Store	String
add	si, 2		; Add
add	di, 78		; Add
loop	loc_249BE	; Loop while CX	!= 0
mov	di, [bp+var_2]
inc	bh		; Increment by 1

loc_249D0:		; Integer Subtraction
sub	ah, ah
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_249BB	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left
mov	di, [bp+var_2]

loc_249E2:		; Compare Two Operands
cmp	bl, 16
jnz	short loc_249B6	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_2495B



; Attributes: bp-based frame

proc sub_249EF far

var_6= byte ptr	-6
var_4= word ptr	-4
var_2= word ptr	-2

; FUNCTION CHUNK AT 0B3D SIZE 00000067 BYTES

push	bp

loc_249F0:
mov	bp, sp
sub	sp, 6		; Integer Subtraction
push	si
push	di
push	es
push	ds

loc_249F9:
mov	ax, seg	dseg
mov	ds, ax

loc_249FE:		; Compare Two Operands
cmp	[idk_Mouse_w3609C], 0
jnz	short loc_24A0D	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
pop	di
pop	si
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_249EF

; START	OF FUNCTION CHUNK FOR sub_249EF

loc_24A0D:		; CODE XREF: sub_249EF+14j
sub	si, si		; Integer Subtraction
mov	di, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add
mov	[bp+var_2], di
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add

loc_24A20:
mov	[bp+var_6], al
mov	ax, [idk_Dseg_RepMovSw_DI+si]
add	si, 2		; Add

loc_24A2A:
mov	[bp+var_4], ax
mov	ax, 0A800h
mov	es, ax
assume es:nothing
mov	bl, 1
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3

loc_24A3A:		; Increment by 1
inc	dx

loc_24A3B:		; CODE XREF: sub_249EF+7Bj
mov	al, bl
out	dx, al		; EGA port: sequencer data register

loc_24A3E:		; Integer Subtraction
sub	bh, bh

loc_24A40:		; CODE XREF: sub_249EF+71j
mov	cx, [bp+var_4]

loc_24A43:		; CODE XREF: sub_249EF+5Fj
mov	ax, [si+43B2h]
stosw			; Store	String
add	si, 2		; Add
add	di, 4Eh	; 'N'   ; Add
loop	loc_24A43	; Loop while CX	!= 0

loc_24A50:
mov	di, [bp+var_2]
inc	bh		; Increment by 1
sub	ah, ah		; Integer Subtraction
mov	al, bh
shl	ax, 1		; Shift	Logical	Left
add	di, ax		; Add
cmp	bh, [bp+var_6]	; Compare Two Operands
jnz	short loc_24A40	; Jump if Not Zero (ZF=0)
shl	bl, 1		; Shift	Logical	Left

loc_24A64:
mov	di, [bp+var_2]

loc_24A67:		; Compare Two Operands
cmp	bl, 10h
jnz	short loc_24A3B	; Jump if Not Zero (ZF=0)
pop	ds
pop	es
assume es:nothing

loc_24A6E:
pop	di
pop	si

loc_24A70:
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
; END OF FUNCTION CHUNK	FOR sub_249EF


;
; get__Mouse_w360A6()
; get__Mouse_w360A4()
;
; Attributes: bp-based frame

proc sub_24A74 far	; CODE XREF: sub_1E547:loc_1E5E0P
			; Mouse_InterruptCallback+94p
			; sub_24D35:loc_24D9Dp
			; sub_24DAE+9EP
			; sub_24DAE+C09P
			; sub_26026+30P
			; sub_26026+B5P
			; rschKBD_s2669B+2CEP
			; sub_27913+10BP
			; sub_27CC0+9CP
			; sub_27CC0+11DP
			; sub_27E4B+293P
			; sub_2B470+3DAP
			; sub_2E00A+93P
			; sub_2E00A+179P
			; sub_2E00A+1C5P

arg_Mouse_w360A4= word ptr  6
arg_Mouse_w360A6= word ptr  8

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	dx, [idk_Mouse_w3609A]
cmp	dx, 0		; Compare Two Operands
jz	short loc_24A94	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_Mouse_w360A4]
mov	cx, [bp+arg_Mouse_w360A6]
push	cs
call	near ptr sub_24AC0 ; Call Procedure
nop			; No Operation

loc_24A94:		; CODE XREF: sub_24A74+13j
pop	ds
pop	es
pop	di
pop	si

loc_24A98:
pop	bp
retf			; Return Far from Procedure
endp sub_24A74



; Attributes: bp-based frame

proc sub_24A9A far	; CODE XREF: sub_2E303:loc_2E333P

arg_0= word ptr	 6
arg_2= word ptr	 8

push	bp
mov	bp, sp
push	si
push	di
push	es
push	ds
mov	ax, seg	dseg
mov	ds, ax
mov	dx, [idk_Mouse_w3609A]
cmp	dx, 0		; Compare Two Operands
jz	short loc_24ABA	; Jump if Zero (ZF=1)
mov	bx, [bp+arg_0]

loc_24AB2:
mov	cx, [bp+arg_2]
push	cs
call	near ptr sub_24B91 ; Call Procedure
nop			; No Operation

loc_24ABA:		; CODE XREF: sub_24A9A+13j
pop	ds
pop	es
pop	di
pop	si
pop	bp
retf			; Return Far from Procedure
endp sub_24A9A



; Attributes: bp-based frame

proc sub_24AC0 far	; CODE XREF: sub_24A74+1Cp

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, seg	dseg
mov	ds, ax
cmp	dx, 0		; Compare Two Operands
jnz	short loc_24ADC	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24ADC:		; CODE XREF: sub_24AC0+12j
dec	dx		; Decrement by 1
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, [ptrFontsLbx2_@80] ; Add
mov	[bp+var_2], dx
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, cx		; Add
mov	ax, [idk_VGA_w35ED6]
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, dx		; Add
add	ax, VIDEO_RAM	; Add
mov	es, ax
mov	ax, 200
sub	ax, cx		; Integer Subtraction
jbe	short loc_24B89	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	ax, 17		; Compare Two Operands
js	short loc_24B15	; Jump if Sign (SF=1)
mov	ax, 10h

loc_24B15:		; CODE XREF: sub_24AC0+50j
mov	[bp+var_4], ax
mov	ax, bx
mov	ah, 1
and	al, 3		; Logical AND

loc_24B1E:		; Jump if Zero (ZF=1)
jz	short loc_24B28
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_24B24:		; CODE XREF: sub_24AC0+66j
shl	ah, 1		; Shift	Logical	Left
loop	loc_24B24	; Loop while CX	!= 0

loc_24B28:		; CODE XREF: sub_24AC0:loc_24B1Ej
mov	dx, SC_INDEX
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	dx, bx
shr	dx, 1		; Shift	Logical	Right
shr	dx, 1		; Shift	Logical	Right
mov	cx, 320
sub	cx, bx		; Integer Subtraction
jbe	short loc_24B89	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	cx, 11h		; Compare Two Operands
js	short loc_24B43	; Jump if Sign (SF=1)
mov	cx, 16

loc_24B43:		; CODE XREF: sub_24AC0+7Ej
mov	bl, cl
mov	bh, [byte ptr bp+var_4]
mov	si, 0
mov	cx, [bp+var_2]
mov	ds, cx

loc_24B50:		; CODE XREF: sub_24AC0:loc_24B87j
mov	di, dx
mov	dx, SC_DATA
mov	al, ah
out	dx, al		; EGA port: sequencer data register
mov	dx, di
mov	cl, bh
xor	ch, ch		; Logical Exclusive OR

loc_24B5E:		; CODE XREF: sub_24AC0+A6j
			; sub_24AC0+AFj
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jnz	short loc_24B6B	; Jump if Not Zero (ZF=0)
add	di, 80		; Add
loop	loc_24B5E	; Loop while CX	!= 0
jmp	short loc_24B71	; Jump
db 90h

loc_24B6B:		; CODE XREF: sub_24AC0+A1j
stosb			; Store	String
add	di, 79		; Add
loop	loc_24B5E	; Loop while CX	!= 0

loc_24B71:		; CODE XREF: sub_24AC0+A8j
mov	cl, 16
sub	cl, bh		; Integer Subtraction
xor	ch, ch		; Logical Exclusive OR
add	si, cx		; Add
dec	bl		; Decrement by 1
jz	short loc_24B89	; Jump if Zero (ZF=1)
shl	ah, 1		; Shift	Logical	Left
cmp	ah, 9		; Compare Two Operands
js	short loc_24B87	; Jump if Sign (SF=1)
inc	dx		; Increment by 1
mov	ah, 1

loc_24B87:		; CODE XREF: sub_24AC0+C2j
jmp	short loc_24B50	; Jump

loc_24B89:		; CODE XREF: sub_24AC0+4Bj
			; sub_24AC0+79j
			; sub_24AC0+BBj
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure
endp sub_24AC0



; Attributes: bp-based frame

proc sub_24B91 far	; CODE XREF: sub_24A9A+1Cp

var_4= word ptr	-4
var_2= word ptr	-2

push	bp
mov	bp, sp
sub	sp, 4		; Integer Subtraction
push	es
push	ds
push	si
push	di
mov	ax, seg	dseg
mov	ds, ax
cmp	dx, 0		; Compare Two Operands
jnz	short loc_24BAD	; Jump if Not Zero (ZF=0)
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp
pop	bp
retf			; Return Far from Procedure

loc_24BAD:		; CODE XREF: sub_24B91+12j
dec	dx		; Decrement by 1

loc_24BAE:		; Shift	Logical	Left
shl	dx, 1

loc_24BB0:		; Shift	Logical	Left
shl	dx, 1
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, [ptrFontsLbx2_@80] ; Add
mov	[bp+var_2], dx

loc_24BBD:
mov	dx, cx
shl	dx, 1		; Shift	Logical	Left
shl	dx, 1		; Shift	Logical	Left
add	dx, cx		; Add
mov	ax, 1
sub	ax, [idk_VGA_w35ED6] ; Integer Subtraction
mov	ah, al
xor	al, al		; Logical Exclusive OR
shl	ax, 1		; Shift	Logical	Left
shl	ax, 1		; Shift	Logical	Left
add	ax, 0A000h	; Add
add	ax, dx		; Add
mov	es, ax
mov	ax, 0C8h ; 'È'
sub	ax, cx		; Integer Subtraction
jbe	short loc_24C5E	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	ax, 11h		; Compare Two Operands
js	short loc_24BEA	; Jump if Sign (SF=1)
mov	ax, 10h

loc_24BEA:		; CODE XREF: sub_24B91+54j
mov	[bp+var_4], ax
mov	ax, bx
mov	ah, 1
and	al, 3		; Logical AND
jz	short loc_24BFD	; Jump if Zero (ZF=1)
mov	cl, al
xor	ch, ch		; Logical Exclusive OR

loc_24BF9:		; CODE XREF: sub_24B91+6Aj
shl	ah, 1		; Shift	Logical	Left
loop	loc_24BF9	; Loop while CX	!= 0

loc_24BFD:		; CODE XREF: sub_24B91+62j
mov	dx, 3C4h
mov	al, 2
out	dx, al		; EGA: sequencer address reg
			; map mask: data bits 0-3 enable writes	to bit planes 0-3
mov	dx, bx
shr	dx, 1		; Shift	Logical	Right

loc_24C07:		; Shift	Logical	Right
shr	dx, 1
mov	cx, 140h
sub	cx, bx		; Integer Subtraction
jbe	short loc_24C5E	; Jump if Below	or Equal (CF=1 | ZF=1)
cmp	cx, 11h		; Compare Two Operands
js	short loc_24C18	; Jump if Sign (SF=1)
mov	cx, 10h

loc_24C18:		; CODE XREF: sub_24B91+82j
mov	bl, cl
mov	bh, [byte ptr bp+var_4]
mov	si, 0
mov	cx, [bp+var_2]
mov	ds, cx

loc_24C25:		; CODE XREF: sub_24B91:loc_24C5Cj
mov	di, dx
mov	dx, 3C5h
mov	al, ah

loc_24C2C:		; EGA port: sequencer data register
out	dx, al
mov	dx, di

loc_24C2F:
mov	cl, bh
xor	ch, ch		; Logical Exclusive OR

loc_24C33:		; CODE XREF: sub_24B91:loc_24C3Bj
			; sub_24B91+B3j
lodsb			; Load String
cmp	al, 0		; Compare Two Operands
jnz	short loc_24C40	; Jump if Not Zero (ZF=0)

loc_24C38:		; Add
add	di, 50h	; 'P'

loc_24C3B:		; Loop while CX	!= 0
loop	loc_24C33
jmp	short loc_24C46	; Jump
align 2

loc_24C40:		; CODE XREF: sub_24B91+A5j
stosb			; Store	String
add	di, 4Fh	; 'O'   ; Add
loop	loc_24C33	; Loop while CX	!= 0

loc_24C46:		; CODE XREF: sub_24B91+ACj
mov	cl, 10h
sub	cl, bh		; Integer Subtraction
xor	ch, ch		; Logical Exclusive OR

loc_24C4C:		; Add
add	si, cx
dec	bl		; Decrement by 1
jz	short loc_24C5E	; Jump if Zero (ZF=1)

loc_24C52:		; Shift	Logical	Left
shl	ah, 1
cmp	ah, 9		; Compare Two Operands
js	short loc_24C5C	; Jump if Sign (SF=1)
inc	dx		; Increment by 1
mov	ah, 1

loc_24C5C:		; CODE XREF: sub_24B91+C6j
jmp	short loc_24C25	; Jump

loc_24C5E:		; CODE XREF: sub_24B91+4Fj
			; sub_24B91+7Dj
			; sub_24B91+BFj
pop	di
pop	si
pop	ds
pop	es
mov	sp, bp

loc_24C64:
pop	bp
retf			; Return Far from Procedure
endp sub_24B91




proc sub_24C66 far	; CODE XREF: sub_25D32+AP
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
mov	di, 0
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left

loc_24C77:		; CODE XREF: sub_24C66+12j
stosw			; Store	String
loop	loc_24C77	; Loop while CX	!= 0
mov	ax, 0
mov	[word_36A22], ax
mov	[word_36A24], ax
retf			; Return Far from Procedure
endp sub_24C66




proc set_w36A24_0 far	; CODE XREF: sub_25D4E+AP
mov	[word_36A24], 0
retf			; Return Far from Procedure
endp set_w36A24_0




proc set_w36A26_1 far	; CODE XREF: sub_25D32+FP
			; sub_25D4E+FP
mov	[word_36A26], 1
retf			; Return Far from Procedure
endp set_w36A26_1




proc sub_24C92 far	; CODE XREF: sub_24CE7+1Bp
			; sub_24D35+15p
			; sub_25D6A+9P
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
mov	di, [word_36A22]
shr	di, 1		; Shift	Logical	Right
mov	bx, [word_36A2A]
cmp	di, bx		; Compare Two Operands
jz	short loc_24CA9	; Jump if Zero (ZF=1)
stosw			; Store	String

loc_24CA9:		; CODE XREF: sub_24C92+14j
mov	[word_36A26], 0
retf			; Return Far from Procedure
endp sub_24C92




proc sub_24CB0 far	; CODE XREF: sub_25DAB+41P
push	es
push	ds
push	si
push	di
mov	[word_36A22], 0
mov	ax, [word_36A28]
mov	es, ax
mov	ax, 0FFFFh
xor	di, di		; Logical Exclusive OR
mov	bx, [word_36A2A]
shl	bx, 1		; Shift	Logical	Left
jmp	short loc_24CCF	; Jump
nop			; No Operation

loc_24CCD:		; CODE XREF: sub_24CB0+26j
inc	di		; Increment by 1
inc	di		; Increment by 1

loc_24CCF:		; CODE XREF: sub_24CB0+1Aj
cmp	[es:di], ax	; Compare Two Operands
jz	short loc_24CD8	; Jump if Zero (ZF=1)
cmp	di, bx		; Compare Two Operands
jnz	short loc_24CCD	; Jump if Not Zero (ZF=0)

loc_24CD8:		; CODE XREF: sub_24CB0+22j
mov	[word_36A22], di
mov	ax, di
pop	di
pop	si
pop	ds
pop	es
retf			; Return Far from Procedure
mov	ax, [word_36A26]
retf			; Return Far from Procedure
endp sub_24CB0



; Attributes: bp-based frame

proc sub_24CE7 far

arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah

; FUNCTION CHUNK AT 0E3B SIZE 0000002A BYTES

push	bp
mov	bp, sp
push	ds
push	es
push	si
push	di
mov	ax, [word_36A28]
mov	es, ax
mov	si, [word_36A22]
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left
cmp	si, cx		; Compare Two Operands
jnz	short loc_24D0B	; Jump if Not Zero (ZF=0)
push	cs
call	near ptr sub_24C92 ; Call Procedure
pop	di
pop	si
pop	es
pop	ds
pop	bp
retf			; Return Far from Procedure
endp sub_24CE7

; START	OF FUNCTION CHUNK FOR sub_24CE7

loc_24D0B:		; CODE XREF: sub_24CE7+18j
mov	di, si
shr	di, 1		; Shift	Logical	Right
add	di, cx		; Add
mov	ax, [bp+arg_0]

loc_24D14:
mov	[es:si], ax
mov	ax, [bp+arg_2]
xor	ah, ah		; Logical Exclusive OR
mov	[es:di], al
mov	ax, [bp+arg_4]
add	di, [word_36A2A] ; Add

loc_24D26:
mov	[es:di], al
inc	si		; Increment by 1
inc	si		; Increment by 1
mov	[word_36A22], si
pop	di
pop	si
pop	es
pop	ds
pop	bp
retf			; Return Far from Procedure
; END OF FUNCTION CHUNK	FOR sub_24CE7



proc sub_24D35 far
push	ds
push	es
push	si
push	di

loc_24D39:
mov	ax, [word_36A28]
mov	es, ax
mov	si, [word_36A24]
mov	ax, [word_36A22]
cmp	ax, si		; Compare Two Operands

loc_24D47:		; Jump if Not Zero (ZF=0)
jnz	short loc_24D52

loc_24D49:		; CODE XREF: sub_24D35+31j
push	cs
call	near ptr sub_24C92 ; Call Procedure
pop	di
pop	si
pop	es
pop	ds
retf			; Return Far from Procedure

loc_24D52:		; CODE XREF: sub_24D35:loc_24D47j
mov	cx, [word_36A2A]
shl	cx, 1		; Shift	Logical	Left
mov	di, si
shr	di, 1		; Shift	Logical	Right
add	di, cx		; Add
xor	bx, bx		; Logical Exclusive OR

loc_24D60:
mov	ax, [es:si]
cmp	ax, 0FFFFh	; Compare Two Operands
jz	short loc_24D49	; Jump if Zero (ZF=1)
mov	bl, [es:di]
xor	cx, cx		; Logical Exclusive OR

loc_24D6D:		; Add
add	di, [word_36A2A]
mov	cl, [es:di]
push	cx
push	bx

loc_24D76:
push	ax
push	cs
call	near ptr sub_245E4 ; Call Procedure
cmp	cl, 0		; Compare Two Operands
jnz	short loc_24D84	; Jump if Not Zero (ZF=0)
push	cs
call	near ptr get_w360AC_set0 ; Call	Procedure

loc_24D84:		; CODE XREF: sub_24D35+49j
push	cs

loc_24D85:		; Call Procedure
call	near ptr CALL_PositionMouseCursor

loc_24D88:
mov	ax, [idk_Mouse_w360A8]

loc_24D8B:		; Compare Two Operands
cmp	ax, 2

loc_24D8E:		; Jump if Below	(CF=1)
jb	short loc_24D94
push	cs

loc_24D91:		; Call Procedure
call	near ptr idk_Mouse_s23F82

loc_24D94:		; CODE XREF: sub_24D35:loc_24D8Ej
push	cs

loc_24D95:		; Call Procedure
call	near ptr idk_ChkMousDoEga

loc_24D98:
push	cs

loc_24D99:		; Call Procedure
call	near ptr sub_24648

loc_24D9C:
push	cs

loc_24D9D:		; Call Procedure
call	near ptr sub_24A74

loc_24DA0:		; Add
add	sp, 6

loc_24DA3:		; Increment by 1
inc	si

loc_24DA4:		; Increment by 1
inc	si

loc_24DA5:
mov	[word_36A24], si

loc_24DA9:
pop	di

loc_24DAA:
pop	si

loc_24DAB:
pop	es

loc_24DAC:
pop	ds

locret_24DAD:		; Return Far from Procedure
retf
endp sub_24D35

ends seg033
