


20211119:
    IDK what this scrap of notes was meant to be.
    I think I though I was going to type up, right quick, some tight, pseud-code, but that obviously went right off the rails.
    So, I'ma try again.

LBX Load Entry
    ...
    ... Allocate g_LBX_Header, Extract LBX_Name, LBX Header Format ...
    EMM LBX Load Entry
    ... Curr == Prev ... Curr != Prev ... g_LBX_FilePath ... LBX Header Format Type ...
    ... TEST LBX MagSig ... TEST LBX Entry Count ...
    ... Entry Offset Table - Begin & End ... Entry Size Bytes ... Entry Size Paragraphs ...
    LOAD TYPE!!!!!
        {0,1,2} (Single, Replace, Append)
        LBX_Data_Seg = SA_Allocate_MemBlk() OR SAMB_data OR SAMB.used
    READ FILE
        Load_To_Seg = LBX_Data_Seg
        Read 32 KB
        ... Entry_Size_Bytes - 32 KB in bytes, Load_To_Seg + 32 KB in pages


? 32KB Chunk Read Size ?

LBX_EntryLoader()
EMM_LBX_EntryLoader()
EMM_LBX_RecLoader()
EMM_LBXR_DirectLoad() - only 1 chunk? .:. 2 EMM Logical Pages ?











Functions
EMM_LBX_EntryLoader

int __cdecl __far EMM_LBX_EntryLoader(char *Hnd_Name@, int Entry_Index, int LBX_Alloc_Seg, int Load_Type, int Format)



External Variables
G_LBX_Force_LoadFmt

G_LBX_Force_LoadFmt
dseg:3E6A   G_LBX_Force_LoadFmt dw 0
Xref:
    LBX_EntryLoader
    LBX_GentEntryData


Local Variables

Arguments & Variables
Passed By-Value
Passed By-Reference
Passed On-Stack





LBX_LdHdr_Exists
Xref:
    LBX_EntryLoader
    LBX_GetEntryData
    LBX_RecordLoader
    LBXR_DirectLoader

LBX_farmalloc()
Xref:
    LBX_EntryLoader
    LBX_GetEntryData
    LBX_RecordLoader
    LBXR_DirectLoader

IDA:
int __cdecl __far LBX_EntryLoader(char *FileName@, int Entry_Index, unsigned int LBX_Alloc_Seg, int Load_Type, int Format_Type)


BCpp31LR; Page 155 (PDF Page 168)
farmalloc
Function    Allocates from far heap.
Syntax      #include <alloc.h>
            void far *farmalloc(unsigned long nbytes);
Remarks farmalloc allocates a block of memory nbytes bytes long from the far heap.
...far pointers are used to access the allocated blocks
...int the large memory model, it takes unsigned long parameters
Return value    farmalloc returns a pointer to the newly allocated block,
                or null if not enough space exists for the new block.
```c
    char far *fptr;
    /* allocate memory for the far pointer */
    fptr = (char far *) farmalloc(32);
    movedata (FP_SEG(str),  FP_OFF(str),
              FP_SEG(fptr), FP_OFF(fptr),
              strlen(str)) ;
    farfree(fptr);
```
```c
if (fptr != NULL)
```
```x86asm
mov  ax, [bp+Amt_Paragraphs]            ; _AX = 32
xor  dx, dx                             ; _DX = 0_
mov  cl, 4                              ; _CL = 4
call LXLSH@                             ; ? _DX:_AX = _DX:_AX * 2^4 = _DX:_AX * 16 = 32 * 16 = 512
                                        ; long shift left, far entry point
                                        ; dx:ax = operand to shift, cl = shift amount
                                        ; source: borlandc\crtl\clib\h_llsh.asm

add  ax, 16                             ; _AX = _AX + 16
adc  dx, 0                              ; _DX = _DX + 0 + _CF (_CF set from previous ADD instruction)

mov  [LBX_Alloc_Segment], dx
mov  [LBX_Alloc_Offset], ax

mov  ax, [LBX_Alloc_Segment]
inc  ax
mov  [bp+LBX_Data_Start_Seg], ax
call RAM_Update_WorstFree
mov  ax, [bp+LBX_Data_Start_Seg]
                                        ; return _DX:(_AX = _DX + 1)
                                        ; because the segment address is added to the offset but only shifted over 4 bits,
                                        ; it means that adding 1 to the segment register shifts the position by 16 bytes.
```
So, ...
it returns _DX:_AX which, is a SEGMENT:OFFSET.
But, ...
the offset is rurns is actually 16 bytes into the the allocation returned by farmalloc().
And, ...
presumably, there is somewhere that makes use of those first 16 bytes that get eschewed here...
~= char far *fptr = MK_FP([LBX_Alloc_Segment],[LBX_Alloc_Offset])
dseg:A5C0   LBX_Alloc_Offset  dw 0      16 byte offset address
dseg:A5C2   LBX_Alloc_Segment dw 0      16 byte segment address
Xref:
    LBX_farmalloc
    UU_LBX_Alloc_Free
    LBX_Alloc_Space
    CRP_LBX_farmalloc2
Recalculating...
Those 16 bytes are the LBX_Alloc_Space_Header struct
struc   LBX_Alloc_Space_Header          ; (sizeof=0x10, standard type)
    safety_malloc_bsize     dw ?
    safety_malloc_prevreal  dw ?
    MemSig1                 dw ?
    MemSig2                 dw ?
    Size_Paras              dw ?
    Used_Paras              dw ?
    unused_0C               dw ?
    Marked_Paras            dw ?
ends    LBX_Alloc_Space_Header
?
LBX_farmalloc does not set the values for the LBX_Alloc_Space_Header
?
?
LBX_farmalloc vs. LBX_Alloc_Space
?
Mayhap, see if this specific function is also /hard-coded/ in MoO2, since the LBX header size was bumped up to 2048 bytes

Anyway, upon return, LBX_Load_Entry only references _AX
LBX_LastLoadHdr = LBX_farmalloc()
dseg:A5CA   LBX_LastLoadHdr@ dw 0
So, LBX_LastLoadHdr is the offset and LBX_Alloc_Segment is assumed to be its segment...
...meaning those first 16+512=528 bytes are assumed/expected/hard-coded to be the /current/ LBX Header?
So, that flag is just whether or not the global LBX header far heap memory has been allocated...






e.g.,
Load 'Font Style Data' - FONTS.LBX,0
LBXE_LoadSingle(FONTS.LBX, 0)
LBX_EntryLoader(FONTS.LBX, 0, 0, 0, 0)

.:. LBX File Name & LBX Entry Index
?
LBX_Alloc_Seg
Load_Type
Format_Type
?

_SI = argLbxFileName
_DI = argLbxEntryIndex


If ( !(argLbxEntryIndex >= 0) )
    LBX_Error(argLbxFileName, argLbxEntryIndex)


If ( LBX_LdHdr_Exists == 0 )
    LBX_LdHdr_Exists = 1
    LBX_LastLoadHdr@ = LBX_FarMalloc(32)           // 32 'pages'  16 * 32 = 512 = LBX_HEADER_LENGTH


_SI = STR_StripFileExt(_SI)     // "FONTS" from "fonts.lbx"

if (argFormatType == 0 && G_LBX_Force_LoadFmt != 2)
{
    varLBX_File_Format = 0
}
else
{
    varLBX_File_Format = 1
}

/*
    Is it already loaded into EMM?
*/
EMM_LBX_EntryLoader(LbxName, LbxEntryIndex, LBX_Alloc_Seg, Load_Type, LBX_File_Format)
int __cdecl __far EMM_MapnRead(unsigned int Target_Off, unsigned int Target_Seg, unsigned int Data_Off, unsigned int Data_Seg, int Amt_Bytes, int EMM_Handle)

?
LBX_Entry_Index * 4
...starting from 8 or 520...520 being 8+512 or 512+8...

This is definitely calculating the offset into the the Entry Offset Address Table.
And, then reading the Entry Offset Start Address and Entry Offset End Address.

But, there is no such things as an LBX that has 512 bytes of something between the Header Preamble and the Offset Table.
So, it seems much more likely that this is skipping 512 bytes of something else and then the usual 8 bytes of the Header Preamble.

argLbxFrmtTyp= word ptr  0Eh            ; 0 - entry addresses start at 0:8
                                        ; 1 - entry addresses start at 20:8


if (format != 0)
{
    ...DX:AX...
    AX = LBX Entry Index
    CWD
    Long Left-Shift by 2
    AX = AX + 520
}
else
{
    ...DX:AX...
    AX = LBX Entry Index
    CWD
    Long Left-Shift by 2
    AX = AX + 8
}
?
